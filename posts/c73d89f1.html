<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/vvfavi.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/vvfavi.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/vvfavi.png">
  <link rel="mask-icon" href="/images/vvfavi.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"doreality.xyz","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="本文首发地址：简单网络驱动（基于 Linux-4.15.x 版本内核）  本文设计并实现了一个简单的网络设备驱动程序（基于 Linux-4.15.x 版本内核）—— A Simpler Network Device Driver（下文简称 sndd）。   源码地址（仅供学习交流）：https:&#x2F;&#x2F;gitee.com&#x2F;doreality&#x2F;sndd   参考《Linux 设备驱动程序（第3版）》（">
<meta property="og:type" content="article">
<meta property="og:title" content="「SNDD」简单网络设备驱动程序">
<meta property="og:url" content="https://doreality.xyz/posts/c73d89f1.html">
<meta property="og:site_name" content="DoReality">
<meta property="og:description" content="本文首发地址：简单网络驱动（基于 Linux-4.15.x 版本内核）  本文设计并实现了一个简单的网络设备驱动程序（基于 Linux-4.15.x 版本内核）—— A Simpler Network Device Driver（下文简称 sndd）。   源码地址（仅供学习交流）：https:&#x2F;&#x2F;gitee.com&#x2F;doreality&#x2F;sndd   参考《Linux 设备驱动程序（第3版）》（">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://doreality.xyz/posts/c73d89f1/arch.png">
<meta property="og:image" content="https://doreality.xyz/posts/c73d89f1/image-20220119171132389.png">
<meta property="og:image" content="https://doreality.xyz/posts/c73d89f1/image-20220119170213353.png">
<meta property="og:image" content="https://doreality.xyz/posts/c73d89f1/image-20220119170534639.png">
<meta property="og:image" content="https://doreality.xyz/posts/c73d89f1/image-20220119170606879.png">
<meta property="og:image" content="https://doreality.xyz/posts/c73d89f1/image-20220119170733902.png">
<meta property="og:image" content="https://doreality.xyz/posts/c73d89f1/image-20220119165929027.png">
<meta property="article:published_time" content="2022-01-19T10:42:09.000Z">
<meta property="article:modified_time" content="2023-04-07T16:44:51.504Z">
<meta property="article:author" content="doreality">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Device Driver">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://doreality.xyz/posts/c73d89f1/arch.png">

<link rel="canonical" href="https://doreality.xyz/posts/c73d89f1.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>「SNDD」简单网络设备驱动程序 | DoReality</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="DoReality" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">DoReality</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://doreality.xyz/posts/c73d89f1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="doreality">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DoReality">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          「SNDD」简单网络设备驱动程序
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-19 18:42:09" itemprop="dateCreated datePublished" datetime="2022-01-19T18:42:09+08:00">2022-01-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-08 00:44:51" itemprop="dateModified" datetime="2023-04-08T00:44:51+08:00">2023-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Projects/" itemprop="url" rel="index"><span itemprop="name">Projects</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>本文首发地址：<a target="_blank" rel="noopener" href="https://bbs.csdn.net/topics/604346832">简单网络驱动（基于 Linux-4.15.x 版本内核）</a></p>
</blockquote>
<p>本文设计并实现了一个简单的网络设备驱动程序（基于 Linux-4.15.x 版本内核）—— A Simpler Network Device Driver（下文简称 <code>sndd</code>）。</p>
<ul>
<li>
<p>源码地址（仅供学习交流）：<a target="_blank" rel="noopener" href="https://gitee.com/doreality/sndd">https://gitee.com/doreality/sndd</a></p>
</li>
<li>
<p>参考《Linux 设备驱动程序（第3版）》（以下简称“LDD3”）第 17 章“网络驱动程序”的<code>snull</code>模块实现</p>
</li>
<li>
<p>P.S. 下文所提到的“网络设备驱动程序”、“网络设备驱动”、“网络驱动程序”、“网络驱动”都指的是同一个概念。</p>
</li>
</ul>
<span id="more"></span>
<h2 id="前言">前言</h2>
<h3 id="几个概念理解">几个概念理解</h3>
<ol>
<li>
<p>为什么要选择 Linux ？</p>
<p>在源码公开和支持模块化这样优点的加成下，Linux 系统非常适合作为学习编写设备驱动程序的环境。</p>
</li>
<li>
<p>什么是设备驱动程序？</p>
<p>设备驱动程序，是应用程序和除了CPU、内存等硬件设备之外的几乎所有外设打交道的桥梁。应用程序使用OS提供的统一接口——系统调用，就像使用了一把万能钥匙，可以打开并访问各种不同外设，而并不用关心这些设备本身的样子。</p>
<p>例如块设备，应用程序说打开它，然后读写一些数据，那么直接使用<code>open</code>，<code>read</code>，<code>write</code>这些系统调用就好了，并不需要考虑数据是怎么在光盘或者磁盘上使用什么不同的介质存储、被组织排列成什么顺序。</p>
</li>
<li>
<p>有哪些设备驱动程序？</p>
<p>正因为有越来越多不同的设备出现，设备驱动也是种类繁杂，一般可以分为三类：字符设备驱动、块设备驱动和网络设备驱动。这样分类有利于模块化编程，但是，当然，对于复杂的设备，也可以把这些都综合为一个模块（以灵活性为代价）。</p>
<p>对于字符设备驱动和块设备驱动来说，Linux 系统都会在<code>/dev</code>目录下创建一个文件节点，把它们都抽象为一个文件，可以打开关闭、可以读写也可以进行配置。</p>
</li>
<li>
<p>但是网络设备驱动有所不同。</p>
<p>网络设备是要和外界互联的，网络驱动程序要异步地接收来自外界的数据包，然后向内核请求，把这些数据包发送给内核。这和块设备只响应内核的要求、只向固定缓冲区发送数据，是完全不同的。网络驱动没有必要留一个<code>/dev</code>下的节点，因为对它打开关闭也好、读写也罢，并没有实质的意义。网络驱动要做的就是，在收到数据包的时候，发送给内核；在内核要发送数据包的时候，它进行封装（自己的硬件头部）然后发送。</p>
</li>
</ol>
<h3 id="网络驱动在哪里">网络驱动在哪里</h3>
<p>如果说网络驱动是一把万能钥匙，那也是开大门的钥匙吧，那就是在内核了。这是在应用程序和驱动程序的角度来看。</p>
<p>如果说从网络的分层来看，网络驱动程序就是很底层了。LDD3 中提到，Linux 的网络子系统被设计为和协议完全无关。协议隐藏在驱动程序之后，而物理传输又被隐藏在协议之后。内核和网络驱动之间的交互，可能每次处理的是一个网络数据包。</p>
<p>但是同样值得指出的是，驱动接收的是外界发送的数据包，但是传输时要给上层传递下来的数据包封装一个 MAC 的头部信息。所以驱动会使用硬件协议，但是处理传输的是 IP 数据包。</p>

<p>（图源：百度百科——网络驱动程序接口规范）</p>
<h2 id="sndd-设计">sndd 设计</h2>
<p><code>sndd</code> 实现一个基于内存的网络驱动模块，模拟了网络接口和远程主机通信的过程。</p>
<p><code>sndd</code> 中使用的接口不依赖于任何硬件，是纯软件实现的数据包传输和发送。</p>
<p>在二层协议上选择以太网协议，处理传输的是 IP 数据包（对其他非 IP 数据包的修改会破坏原本数据包）。</p>
<p>由于使用以太网协议，在实际测试的时候可以使用 <code>tcpdump</code> 工具进行抓包验证数据包的传输。</p>
<h3 id="网络拓扑">网络拓扑</h3>
<p>驱动模拟了四个网络接口，接口名：<code>sndd0</code>，<code>sndd1</code>，<code>sndd2</code> 和 <code>sndd3</code></p>
<p>对应的主机名为 <code>lc0</code>，<code>lc1</code>，<code>lc2</code> 和 <code>lc3</code></p>
<p>四个接口位于四个不同的子网，网络名分别为 <code>snet0</code>，<code>snet1</code>，<code>snet2</code> 和 <code>snet3</code></p>
<p>在三个网段中，各自分别有一台主机，主机名：<code>rm0</code>，<code>rm1</code>，<code>rm2</code> 和 <code>rm3</code></p>
<p>网络结构如下图所示：</p>
<img src="/posts/c73d89f1/arch.png" class="">
<p>驱动要实现的功能如下：</p>
<ul>
<li>从主机发送到 <code>rm0</code> 的数据包，要从 <code>sn3</code> 接收到</li>
<li>从主机发送到 <code>rm3</code> 的数据包，要从 <code>sn0</code> 接收到</li>
<li>从主机发送到 <code>rm1</code> 的数据包，要从 <code>sn2</code> 接收到</li>
<li>从主机发送到 <code>rm2</code> 的数据包，要从 <code>sn1</code> 接收到</li>
</ul>
<p>为了实现上述功能，给各接口和主机分配 IP 地址如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 网络号 &#x2F;etc&#x2F;networks</span><br><span class="line">snet0 192.168.4.0</span><br><span class="line">snet1 192.168.5.0</span><br><span class="line">snet2 192.168.6.0</span><br><span class="line">snet3 192.168.7.0</span><br><span class="line"></span><br><span class="line"># 主机号 &#x2F;etc&#x2F;hosts</span><br><span class="line">192.168.4.1 lc0  </span><br><span class="line">192.168.4.2 rm0</span><br><span class="line">192.168.5.2 lc1</span><br><span class="line">192.168.5.1 rm1</span><br><span class="line">192.168.6.1 lc2</span><br><span class="line">192.168.6.2 rm2</span><br><span class="line">192.168.7.2 lc3</span><br><span class="line">192.168.7.1 rm3</span><br></pre></td></tr></table></figure>
<p>同时，在终端里配置网络接口：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ifconfig sndd0 lc0 netmask 255.255.255.0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ifconfig sndd1 lc1 netmask 255.255.255.0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ifconfig sndd2 lc2 netmask 255.255.255.0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ifconfig sndd3 lc3 netmask 255.255.255.0</span></span><br></pre></td></tr></table></figure>
<p>根据所设置的 IP 地址，为了实现功能，要在驱动中接收到数据包时，修改 IP 数据包的头部中的源 IP 地址和目的 IP 地址：</p>
<ul>
<li>把第 3 个 octet 依次修改（4-&gt;5，5-&gt;4，6-&gt;7，7-&gt;6）</li>
<li>把第 4 个 octet 修改（1-&gt;2，2-&gt;1）</li>
</ul>
<h3 id="模块结构">模块结构</h3>
<p>实现一个简单的模块，至少需要包含如下几个部分：</p>
<ol>
<li>模块注册和注销</li>
<li>模块初始化</li>
<li>模块的具体操作</li>
</ol>
<p>对于要实现的简单网络设备驱动，</p>
<p>包含的数据结构：</p>
<ol>
<li>接口数据结构 <code>struct net_device *</code></li>
<li>操作数据结构
<ul>
<li><code>struct header_ops</code></li>
<li><code>struct net_device_ops</code></li>
</ul>
</li>
<li>自定义数据包 <code>struct sndd_packet</code></li>
<li>接口的私有信息 <code>struct sndd_priv</code></li>
</ol>
<p>包含操作：</p>
<ol>
<li>注册 <code>sndd_init_module()</code></li>
<li>注销 <code>sndd_cleanup()</code></li>
<li>初始化 <code>sndd_init()</code></li>
<li>打开 <code>sndd_open()</code></li>
<li>关闭 <code>sndd_release()</code></li>
<li>传输 / 接收
<ul>
<li>传输 <code>sndd_tx()</code></li>
<li>接收 <code>sndd_rx()</code></li>
</ul>
</li>
<li>数据处理
<ul>
<li>修改 header <code>sndd_header()</code></li>
<li>单个缓冲区
<ul>
<li><code>sndd_get_tx_buffer()</code></li>
<li><code>sndd_release_buffer()</code></li>
</ul>
</li>
<li>缓冲池
<ul>
<li>建立：<code>sndd_setup_pool()</code></li>
<li>回收：<code>sndd_teardown_pool()</code></li>
</ul>
</li>
<li>缓冲队列
<ul>
<li><code>sndd_enqueue_buf()</code></li>
<li><code>sndd_dequeue_buf()</code></li>
</ul>
</li>
</ul>
</li>
<li>中断 <code>sndd_regular_interrupt()</code></li>
<li>统计 <code>net_device_stats *sndd_stats()</code></li>
<li>I / O 控制 <code>sndd_ioctl()</code></li>
</ol>
<p>使用一些简化：</p>
<ul>
<li>传输和接收采用中断机制，而不是轮询（NAPI）</li>
<li>不设置传输超时判断</li>
<li>硬件地址由软件模拟</li>
<li>不使用 ARP，采用软件模拟</li>
<li>不修改 MTU</li>
</ul>
<h2 id="sndd-实现">sndd 实现</h2>
<ol>
<li>模块的注册、注销和初始化</li>
</ol>
<p>首先是每个模块的注册和注销函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module_init(sndd_init_module);</span><br><span class="line">module_exit(sndd_cleanup);</span><br></pre></td></tr></table></figure>
<p>注册，完成的功能就是给每个接口申请内存（在这个步骤里要进行接口的初始化 <code>sndd_init</code>），最关键的就是使用注册函数<code>register_netdev(sndd_devs[i])</code>，把接口注册到内核中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Register the module</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sndd_init_module</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> result, i, ret = -ENOMEM;</span><br><span class="line"></span><br><span class="line">	sndd_interrupt = sndd_regular_interrupt;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allocate the devices */</span></span><br><span class="line">	sndd_devs[<span class="number">0</span>] = alloc_netdev(<span class="keyword">sizeof</span>(struct sndd_priv), <span class="string">&quot;sndd%d&quot;</span>,</span><br><span class="line">			NET_NAME_UNKNOWN, sndd_init);</span><br><span class="line">	sndd_devs[<span class="number">1</span>] = alloc_netdev(<span class="keyword">sizeof</span>(struct sndd_priv), <span class="string">&quot;sndd%d&quot;</span>,</span><br><span class="line">			NET_NAME_UNKNOWN, sndd_init);</span><br><span class="line">	sndd_devs[<span class="number">2</span>] = alloc_netdev(<span class="keyword">sizeof</span>(struct sndd_priv), <span class="string">&quot;sndd%d&quot;</span>,</span><br><span class="line">			NET_NAME_UNKNOWN, sndd_init);</span><br><span class="line">	sndd_devs[<span class="number">3</span>] = alloc_netdev(<span class="keyword">sizeof</span>(struct sndd_priv), <span class="string">&quot;sndd%d&quot;</span>,</span><br><span class="line">			NET_NAME_UNKNOWN, sndd_init);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sndd_devs[<span class="number">0</span>] == <span class="literal">NULL</span> || sndd_devs[<span class="number">1</span>] == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	ret = -ENODEV;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>;  i++)</span><br><span class="line">		<span class="keyword">if</span> ((result = register_netdev(sndd_devs[i])))</span><br><span class="line">			printk(<span class="string">&quot;sndd: error %i registering device \&quot;%s\&quot;\n&quot;</span>,</span><br><span class="line">					result, sndd_devs[i]-&gt;name);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			ret = <span class="number">0</span>;</span><br><span class="line">   out:</span><br><span class="line">	<span class="keyword">if</span> (ret) </span><br><span class="line">		sndd_cleanup();</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注销，就是注册的倒序，先从内核中注销，然后清除内部的数据结构，最后释放接口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Unregister the module</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sndd_cleanup</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>;  i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sndd_devs[i]) &#123;</span><br><span class="line">			unregister_netdev(sndd_devs[i]);</span><br><span class="line">			sndd_teardown_pool(sndd_devs[i]);</span><br><span class="line">			free_netdev(sndd_devs[i]); </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The init function (sometimes called probe).</span></span><br><span class="line"><span class="comment"> * It is invoked by register_netdev()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sndd_init</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sndd_priv</span> *<span class="title">priv</span>;</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * Then, assign other fields in dev, using ether_setup() and some</span></span><br><span class="line"><span class="comment">	 * hand assignments</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ether_setup(dev); <span class="comment">/* assign some of the fields */</span></span><br><span class="line">	dev-&gt;netdev_ops = &amp;sndd_netdev_ops;</span><br><span class="line">	dev-&gt;header_ops = &amp;sndd_header_ops;</span><br><span class="line">	<span class="comment">/* keep the default flags, just add NOARP */</span></span><br><span class="line">	dev-&gt;flags           |= IFF_NOARP;</span><br><span class="line">	dev-&gt;features        |= NETIF_F_HW_CSUM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Then, initialize the priv field. This encloses the statistics</span></span><br><span class="line"><span class="comment">	 * and a few private fields.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	priv = netdev_priv(dev);</span><br><span class="line">	<span class="built_in">memset</span>(priv, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct sndd_priv));</span><br><span class="line"></span><br><span class="line">	spin_lock_init(&amp;priv-&gt;lock);</span><br><span class="line">	priv-&gt;dev = dev;</span><br><span class="line"></span><br><span class="line">	sndd_rx_ints(dev, <span class="number">1</span>);		<span class="comment">/* enable receive interrupts */</span></span><br><span class="line">	sndd_setup_pool(dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>数据包的传输</li>
</ol>
<p>从上层接收到的数据包，要先封装硬件协议（这里是以太网协议）的头部，然后放入发送队列。</p>
<p>每一个数据包都包含在一个 <code>sk_buff</code> 结构中，就是一个 socket 缓冲区。</p>
<p>最后调用 <code>sndd_hw_tx</code> 实现网络驱动的具体操作，就是修改源和目的，实现一个回环功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Transmit a packet (called by the kernel)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sndd_tx</span><span class="params">(struct sk_buff *skb, struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">	<span class="keyword">char</span> *data, shortpkt[ETH_ZLEN];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sndd_priv</span> *<span class="title">priv</span> =</span> netdev_priv(dev);</span><br><span class="line"></span><br><span class="line">	data = skb-&gt;data;</span><br><span class="line">	len = skb-&gt;len;</span><br><span class="line">	<span class="keyword">if</span> (len &lt; ETH_ZLEN) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(shortpkt, <span class="number">0</span>, ETH_ZLEN);</span><br><span class="line">		<span class="built_in">memcpy</span>(shortpkt, skb-&gt;data, skb-&gt;len);</span><br><span class="line">		len = ETH_ZLEN;</span><br><span class="line">		data = shortpkt;</span><br><span class="line">	&#125;</span><br><span class="line">	netif_trans_update(dev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Remember the skb, so we can free it at interrupt time */</span></span><br><span class="line">	priv-&gt;skb = skb;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* actual deliver of data is device-specific, and not shown here */</span></span><br><span class="line">	sndd_hw_tx(data, len, dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* Our simple device can not fail */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>数据包的接收</li>
</ol>
<p>由于是使用中断驱动，当数据包异步到达的时候，中断程序调用 <code>sndd_rx</code> 将数据包和附加信息发送到上层。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Receive a packet: retrieve, encapsulate and pass over to upper levels</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sndd_rx</span><span class="params">(struct net_device *dev, struct sndd_packet *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sndd_priv</span> *<span class="title">priv</span> =</span> netdev_priv(dev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The packet has been retrieved from the transmission</span></span><br><span class="line"><span class="comment">	 * medium. Build an skb around it, so upper layers can handle it</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	skb = dev_alloc_skb(pkt-&gt;datalen + <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (!skb) &#123;</span><br><span class="line">		<span class="keyword">if</span> (printk_ratelimit())</span><br><span class="line">			printk(KERN_NOTICE <span class="string">&quot;sndd rx: low on mem - packet dropped\n&quot;</span>);</span><br><span class="line">		priv-&gt;stats.rx_dropped++;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	skb_reserve(skb, <span class="number">2</span>); <span class="comment">/* align IP on 16B boundary */</span>  </span><br><span class="line">	<span class="built_in">memcpy</span>(skb_put(skb, pkt-&gt;datalen), pkt-&gt;data, pkt-&gt;datalen);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Write metadata, and then pass to the receive level */</span></span><br><span class="line">	skb-&gt;dev = dev;</span><br><span class="line">	skb-&gt;protocol = eth_type_trans(skb, dev);</span><br><span class="line">	skb-&gt;ip_summed = CHECKSUM_UNNECESSARY; <span class="comment">/* don&#x27;t check it */</span></span><br><span class="line">	priv-&gt;stats.rx_packets++;</span><br><span class="line">	priv-&gt;stats.rx_bytes += pkt-&gt;datalen;</span><br><span class="line">	netif_rx(skb);</span><br><span class="line">  out:</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多具体的实现可见源代码并参考 LDD3 中的 <code>snull</code> 模块。</p>
<h2 id="sndd-测试">sndd 测试</h2>
<p>利用 <code>Makefile</code> 生产 <code>.ko</code> 加载到内核之后，使用 <code>ping</code> 和 <code>tcpdump</code> 可以测试本驱动。</p>
<h3 id="Makefile">Makefile</h3>
<p>和 LDD3 中所给示例基本是一样的。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Comment/uncomment the following line to disable/enable debugging</span></span><br><span class="line"><span class="comment">#DEBUG = y</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add your debugging flag (or not) to CFLAGS</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(DEBUG)</span>,y)</span><br><span class="line">  DEBFLAGS = -O -g -DSNULL_DEBUG <span class="comment"># &quot;-O&quot; is needed to expand inlines</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  DEBFLAGS = -O2</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">EXTRA_CFLAGS += <span class="variable">$(DEBFLAGS)</span></span><br><span class="line">EXTRA_CFLAGS += -I..</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line"><span class="comment"># call from kernel build system</span></span><br><span class="line">obj-m	:= sndd.o</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">KERNELDIR ?= /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build</span><br><span class="line">PWD       := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">default:</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions *.mod modules.order *.symvers</span><br><span class="line"></span><br><span class="line">depend .depend dep:</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(EXTRA_CFLAGS)</span> -M *.c &gt; .depend</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (.depend,<span class="variable">$(<span class="built_in">wildcard</span> .depend)</span>)</span><br><span class="line"><span class="keyword">include</span> .depend</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<h3 id="模块测试">模块测试</h3>
<ol>
<li>
<p>编译并装载模块</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo insmod sndd.ko</span></span><br></pre></td></tr></table></figure>
 <img src="/posts/c73d89f1/image-20220119171132389.png" class="">
<p>模块加载到内核之后，模拟的网络接口就出现了，使用 <code>ifconfig</code> 命令可以查看：</p>
 <img src="/posts/c73d89f1/image-20220119170213353.png" class="">
</li>
<li>
<p>配置网络</p>
<p>如前所述，配置网络和主机号，同时绑定接口的 IP。</p>
 <img src="/posts/c73d89f1/image-20220119170534639.png" class="">
 <img src="/posts/c73d89f1/image-20220119170606879.png" class="">
 <img src="/posts/c73d89f1/image-20220119170733902.png" class="">
</li>
<li>
<p>测试</p>
<p>测试效果如下图。</p>
 <img src="/posts/c73d89f1/image-20220119165929027.png" class="">
<p>当发出<code>ping -c1 1 rm0</code>命令，发送目的地址为 <code>rm0</code> 的数据包请求时，按顺序发送了如下事件：</p>
<ol>
<li>
<p>在 <code>sndd0</code> 上观察到，从 <code>lc0 &gt; rm0</code> 发起了一次请求；</p>
</li>
<li>
<p>在 <code>sndd1</code> 上观察到，从 <code>rm1 &gt; lc1</code> 发起了一次请求；</p>
</li>
<li>
<p>在 <code>sndd1</code> 上观察到，从 <code>lc1 &gt; rm1</code> 发起了一次回应；</p>
</li>
<li>
<p>在 <code>sndd0</code> 上观察到，从 <code>rm0 &gt; lc0</code> 发起了一次回应。</p>
</li>
</ol>
<p>这个过程就实现了一个扩展的回环网络，从 <code>lc0</code> 到 <code>lc1</code>，然后从 <code>lc1</code> 再到 <code>lc0</code>，实现了一次双向的通信。</p>
<p>同理，使用 <code>ping</code> 访问 <code>rm1</code>，<code>rm2</code> 和 <code>rm3</code> 时，也实现了这样的过程。</p>
</li>
</ol>
<h2 id="小结">小结</h2>
<ol>
<li>模块化编程要注意，卸载模块的时候，一定要把申请的所有内存都释放，否则会影响内核下一次启动；</li>
<li>网络驱动比起字符驱动和块设备驱动，会更抽象一点，实际的使用需要结合具体的网络设备来编写；</li>
<li>配置测试接口的 IP 时，要多测试一下，如果突然不好用了重新使用 <code>ifconfig</code> 配置一下；</li>
<li>在实际网络中使用的时候，必须要有传输超时和并发控制（这里没有给出，但是 LDD3 中都有涉及）；</li>
<li>除了中断的方式处理数据接收和发送，还可以使用轮询（NAPI）的方式，常用于流量非常大的高速接口（如宽带接口）；</li>
<li>网络驱动其实并不关注协议内容，也不关注头部和数据的划分，但是，需要比较了解协议的结构，才能在传输和发送时更好处理。</li>
</ol>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>LDD3 的 <code>snull</code> 示例参考代码（基于新版内核修改）：<a target="_blank" rel="noopener" href="https://github.com/martinezjavier/ldd3">https://github.com/martinezjavier/ldd3</a></p>
</li>
<li>
<p><code>snull</code> 在新版内核上编译不通过问题：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wh8_2011/article/details/50374935">Linux设备驱动程序(LDD)中snull的编译问题</a></p>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Linux/" rel="tag"># Linux</a>
              <a href="/tags/Device-Driver/" rel="tag"># Device Driver</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/4342490b.html" rel="prev" title="Jupyter Notebook 基础使用">
      <i class="fa fa-chevron-left"></i> Jupyter Notebook 基础使用
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/c400d692.html" rel="next" title="Cousera 视频快速加载">
      Cousera 视频快速加载 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3"><span class="nav-number">1.1.</span> <span class="nav-text">几个概念理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E9%A9%B1%E5%8A%A8%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="nav-number">1.2.</span> <span class="nav-text">网络驱动在哪里</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sndd-%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.</span> <span class="nav-text">sndd 设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91"><span class="nav-number">2.1.</span> <span class="nav-text">网络拓扑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84"><span class="nav-number">2.2.</span> <span class="nav-text">模块结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sndd-%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.</span> <span class="nav-text">sndd 实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sndd-%E6%B5%8B%E8%AF%95"><span class="nav-number">4.</span> <span class="nav-text">sndd 测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Makefile"><span class="nav-number">4.1.</span> <span class="nav-text">Makefile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E6%B5%8B%E8%AF%95"><span class="nav-number">4.2.</span> <span class="nav-text">模块测试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">6.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">doreality</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">doreality</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
