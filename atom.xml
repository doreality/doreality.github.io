<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DoReality</title>
  
  
  <link href="https://doreality.xyz/atom.xml" rel="self"/>
  
  <link href="https://doreality.xyz/"/>
  <updated>2023-04-07T16:43:26.053Z</updated>
  <id>https://doreality.xyz/</id>
  
  <author>
    <name>doreality</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 GitHub Actions 自动添加 TOC 到 README</title>
    <link href="https://doreality.xyz/posts/9bb3bd63.html"/>
    <id>https://doreality.xyz/posts/9bb3bd63.html</id>
    <published>2023-04-02T15:14:35.000Z</published>
    <updated>2023-04-07T16:43:26.053Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>git push</code> 时，给 <code>main</code> 分支下的 <code>README.md</code> 自动生成目录！</p><span id="more"></span><ol><li>找到 Repo 的 「Settings」-「Actions」-「General」-「Workflow permissions」，修改为 <code>Read and write permissions</code></li><li>在 Repo 的 「Actions」中，新建 workflow<ul><li>选择 「set up a workflow yourself」</li></ul></li><li>配置，可以命名为 <code>toc.yml</code>：  <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [<span class="string">main</span>]</span><br><span class="line">    <span class="attr">paths:</span> [<span class="string">&#x27;README.md&#x27;</span>]</span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span> [<span class="string">main</span>]</span><br><span class="line">    <span class="attr">paths:</span> [<span class="string">&#x27;README.md&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">timeout-minutes:</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">curl</span> <span class="string">https://raw.githubusercontent.com/ekalinin/github-markdown-toc/master/gh-md-toc</span> <span class="string">-o</span> <span class="string">gh-md-toc</span></span><br><span class="line">          <span class="string">chmod</span> <span class="string">a+x</span> <span class="string">gh-md-toc</span></span><br><span class="line">          <span class="string">./gh-md-toc</span> <span class="string">--insert</span> <span class="string">--no-backup</span> <span class="string">README.md</span></span><br><span class="line">          <span class="string">rm</span> <span class="string">-f</span> <span class="string">./gh-md-toc</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">stefanzweifel/git-auto-commit-action@v4</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">commit_message:</span> <span class="string">Auto</span> <span class="string">update</span> <span class="string">markdown</span> <span class="string">TOC</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>Commit 后，目录中生成 <code>.github/workflow/toc.yml</code>。</li></ol><p>之后再 push 的时候，就会自动调用 workflow 在 <a href="http://README.md">README.md</a> 生成目录了。</p><p>注意：一定要把「Settings」里的读写打开，否则会生成失败。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 &lt;code&gt;git push&lt;/code&gt; 时，给 &lt;code&gt;main&lt;/code&gt; 分支下的 &lt;code&gt;README.md&lt;/code&gt; 自动生成目录！&lt;/p&gt;</summary>
    
    
    
    <category term="Tools" scheme="https://doreality.xyz/categories/Tools/"/>
    
    
    <category term="GitHub" scheme="https://doreality.xyz/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 基础篇</title>
    <link href="https://doreality.xyz/posts/318faa67.html"/>
    <id>https://doreality.xyz/posts/318faa67.html</id>
    <published>2023-04-02T09:39:14.000Z</published>
    <updated>2023-04-07T16:35:43.319Z</updated>
    
    <content type="html"><![CDATA[<ul><li>原版课程请访问：<a href="https://codewithmosh.com/">Code With Mosh</a></li><li>B 站中文字幕版：<a href="https://www.bilibili.com/video/BV13b411H7LR/?p=103&amp;share_source=copy_web&amp;vd_source=9fbcc6c828dc945d8ee14b34a7922c47">JavaScript 基础篇 - Mosh</a></li></ul><p>Operators &amp; Flow Control &amp; Object &amp; Arrays &amp; Function</p><span id="more"></span><h2 id="Operators">Operators</h2><h3 id="和">== 和 ===</h3><ul><li><code>==</code> 不严格等价，如果两边类型不同，会把右边的操作数自动转换为左边的类型，再判断值是否相等；</li><li><code>===</code> 严格等价，值和类型 Value 和 Type 都要相同才真。平时主要用三个等号。</li></ul><h3 id="非布尔值进行逻辑运算">非布尔值进行逻辑运算</h3><ul><li><code>false || 1</code>的结果是 <code>1</code>；</li><li>JS 中存在 <strong>Falsy</strong> 类假（<code>false</code>）的值：<ul><li><code>undefined</code></li><li><code>null</code></li><li><code>0</code></li><li><code>false</code></li><li><code>''</code> (empty string)</li><li><code>NaN</code> (Not a Number)</li></ul></li><li>其他所有不是 <strong>Falsy</strong> 的值都是 <strong>Truthy</strong>。</li></ul><h3 id="短路原则">|| 短路原则</h3><p><code>false || 1 || 2</code> 的结果是 <code>1</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> userColor = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> defaultColor = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line"><span class="comment">// 如果用户没有选择颜色，那么就使用默认颜色。</span></span><br><span class="line"><span class="keyword">let</span> currentColor = userColor || defaultColor;</span><br></pre></td></tr></table></figure><h3 id="Bitwise">Bitwise: <code>|</code> <code>&amp;</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> readPermission = <span class="number">4</span>; <span class="comment">// 00000100</span></span><br><span class="line"><span class="keyword">let</span> writePermission = <span class="number">2</span>; <span class="comment">// 00000010</span></span><br><span class="line"><span class="keyword">let</span> executePermission = <span class="number">1</span>; <span class="comment">// 00000001</span></span><br><span class="line"><span class="keyword">let</span> myPermission = </span><br><span class="line">readPermission | writePermission | executePermission; <span class="comment">// 给用户权限</span></span><br><span class="line"><span class="keyword">let</span> message = </span><br><span class="line">(myPermission &amp; readPermission) ? <span class="string">&#x27;yes&#x27;</span> : <span class="string">&#x27;no&#x27;</span>; <span class="comment">// 三元表达式：判断用户是否具有某权限</span></span><br></pre></td></tr></table></figure><h3 id="注意事项">注意事项</h3><ul><li>变量命名要有意义；</li><li>函数单一性功能；</li><li>密切相关的代码放在一起，和别的空行。</li></ul><h2 id="Flow-Control">Flow Control</h2><h3 id="switch">switch</h3><p><code>if-else</code> 替代 <code>switch</code>（过时）</p><h3 id="do-while">do-while</h3><p><code>do-while</code> 的函数体至少会执行一次</p><h3 id="for…in：对象遍历">for…in：对象遍历</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(key, obj[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for…of：数组遍历">for…of：数组遍历</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> arr) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Object">Object</h2><h3 id="工厂函数和构造函数">工厂函数和构造函数</h3><p>（效果一样，随便用哪个）</p><ul><li>Factory Function  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Factory Function</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCircle</span>(<span class="params">radius</span>) </span>&#123; <span class="comment">// Camel Notation</span></span><br><span class="line"><span class="comment">// return an object</span></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">radius, <span class="comment">// use parameter as value</span></span><br><span class="line"><span class="function"><span class="title">draw</span>(<span class="params"></span>)</span> &#123; <span class="comment">// no need &#x27;function&#x27; keyword</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;draw&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle1 = createCircle(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(circle1);</span><br></pre></td></tr></table></figure></li><li>Constructor Function  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constructor Function</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123; <span class="comment">// Pascal Notation</span></span><br><span class="line"><span class="built_in">this</span>.radius = radius;</span><br><span class="line"><span class="built_in">this</span>.draw = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;draw&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. create an empty js object &#123;&#125;, </span></span><br><span class="line"><span class="comment">// 2. &#x27;this&#x27; reference to &#123;&#125;</span></span><br><span class="line"><span class="comment">// 3. &#x27;this&#x27; creates propeties to obj</span></span><br><span class="line"><span class="comment">//    &#123;&#125;.radius = radius, &#123;&#125;.draw = ..</span></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="const-对象">const 对象</h3><p><code>const obj = new someObj();</code>：</p><ul><li>不能 re-assign</li><li>可以 <strong>动态</strong> 增删属性和方法。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> obj.property;</span><br></pre></td></tr></table></figure><h3 id="对象的构造器">对象的构造器</h3><p><code>obj.constructor</code></p><ul><li>使用构造函数创建的对象，构造器就是构造函数本身</li><li>使用工厂函数创建的对象，构造器是 JavaScript 内置的构造函数 <code>Object()</code>，因为工厂函数使用了 <code>&#123;&#125;</code> （<em>object literal syntax</em>），它在内部就是调用了 <code>Object()</code></li></ul><p>以下的构造对象的方法是等价的：</p><ul><li><code>new String()</code> === <code>' ', &quot; &quot;, ` ` </code></li><li><code>new Boolean()</code>=== <code>true, false</code></li><li><code>new Number()</code> === <code>1, 2, ...</code></li></ul><h3 id="函数是对象（万物是对象）">函数是对象（万物是对象）</h3><ul><li><code>new Function(parameters, statements)</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Circle1 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;radius&#x27;</span>,<span class="string">`</span></span><br><span class="line"><span class="string">this.radius = radius;</span></span><br><span class="line"><span class="string">this.draw = function() &#123;</span></span><br><span class="line"><span class="string">console.log(&#x27;draw&#x27;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">`</span>);</span><br></pre></td></tr></table></figure><ul><li><code>const circle1 = &#123;&#125;; Circle.call(circle1, 1);</code> === <code>const circle1 = new Circle(1);</code></li><li><code>Circle.call(thisArg, ArgList);</code></li><li>如果不使用 <code>new</code>，<code>this</code> 指向 <code>window</code></li></ul><h3 id="Value-Type-and-Reference-Type">Value Type and Reference Type</h3><ul><li>值拷贝类型 Primitive:<ul><li>Number</li><li>String</li><li>Boolean</li><li>Symbol</li><li>undefined</li><li>null</li></ul></li><li>引用（地址）拷贝类型 Object:<ul><li>Object</li><li>Function</li><li>Array</li></ul></li><li><code>const</code> 声明的变量：<ul><li>如果是值拷贝，则不能修改赋值；</li><li>如果是引用拷贝，则可以修改对象的属性内容，但不能 re-assign 另一个对象，因为会修改地址。</li></ul></li></ul><h3 id="对象不是可枚举">对象不是可枚举</h3><p>not iterable，不能直接直接用<code>for..of</code> 遍历：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj))&#123;&#125;</span><br><span class="line"><span class="comment">// each entry is [key, value]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entriy <span class="keyword">of</span> <span class="built_in">Object</span>.entries(obj))&#123;&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// key if in this object</span></span><br><span class="line"><span class="keyword">if</span> (key <span class="keyword">in</span> object) <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h3 id="对象拷贝">对象拷贝</h3><p>怎么把值拷贝过去？</p><ul><li>遍历拷贝</li><li><code>const newObj = Object.assign(&#123;&#125;, oldObj);</code></li><li>separate operator <code>...</code> ：<code>const another = &#123; ...circle &#125;;</code></li></ul><h3 id="JS-的-GC">JS 的 GC</h3><p>Garbage Collector 垃圾回收是自动进行的。</p><h3 id="String-Literal-和-Template-Literal">String Literal 和 Template Literal</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> message = <span class="string">&#x27;  hi there.  &#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;hello then&#x27;</span>);</span><br><span class="line">message.trim();</span><br><span class="line">message.trimLeft();</span><br><span class="line">message.trimRight();</span><br><span class="line">message.split(<span class="string">&#x27; &#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="Date">Date</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">const</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;May 11 2022 09:00&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2022</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">9</span>);</span><br><span class="line"><span class="comment">// month from 0 to 11</span></span><br><span class="line">now.getxx();</span><br><span class="line">now.setFullYear(<span class="number">2017</span>);</span><br><span class="line">now.toDateString();</span><br><span class="line">now.toTimeString();</span><br><span class="line">now.toISOString();</span><br></pre></td></tr></table></figure><h3 id="用对象的眼光观察">用对象的眼光观察</h3><p>设想，如果是你来设计某个事物，构成一个对象，会需要什么属性和方法。</p><h2 id="Arrays">Arrays</h2><h3 id="增加-Adding">增加 Adding</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [];</span><br><span class="line"><span class="comment">// End</span></span><br><span class="line">a.push(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br><span class="line"><span class="comment">// Beginning</span></span><br><span class="line">a.unshift(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// [1, 2, &#x27;a&#x27;, &#x27;b&#x27;]</span></span><br><span class="line"><span class="comment">// Mid</span></span><br><span class="line">a.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>); <span class="comment">// [1, 2, 3, 4, &#x27;a&#x27;, &#x27;b&#x27;]</span></span><br><span class="line"><span class="comment">// 2 means start index is 2</span></span><br><span class="line"><span class="comment">// 0 means delete 0 element</span></span><br><span class="line"><span class="comment">// index &gt;= length，则在末尾添加新元素</span></span><br></pre></td></tr></table></figure><h3 id="查找-Finding">查找 Finding</h3><ol><li><p>Primitive</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// find first</span></span><br><span class="line">a.indexOf(<span class="number">1</span>); <span class="comment">// 0</span></span><br><span class="line">a.indexOf(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// -1</span></span><br><span class="line">a.indexOf(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 4 (from index 2 to find)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// find last</span></span><br><span class="line">a.lastIndexOf(<span class="number">1</span>); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// exist or not</span></span><br><span class="line"><span class="keyword">if</span>(a.indexOf(<span class="number">1</span>) !== -<span class="number">1</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">if</span>(a.includes(<span class="number">1</span>))&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>Reference</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> courses = [</span><br><span class="line">&#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;a&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;b&#x27;</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// find first matched element</span></span><br><span class="line"><span class="comment">//const course = courses.find(function(course)&#123;</span></span><br><span class="line"><span class="comment">//return course.name === &#x27;a&#x27;;</span></span><br><span class="line"><span class="comment">//&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// use arrow function</span></span><br><span class="line"><span class="keyword">const</span> course = courses.find(<span class="function"><span class="params">course</span> =&gt;</span> course.name === <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// find(predicate or callback function)</span></span><br><span class="line"><span class="comment">// findIndex()</span></span><br><span class="line"><span class="comment">// 当返回值为 true，返回结果；</span></span><br><span class="line"><span class="comment">// 当返回值为 false，继续在数组中向后查找。</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="删除-Removing">删除 Removing</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// End</span></span><br><span class="line"><span class="keyword">const</span> last = numbers.pop(); </span><br><span class="line"><span class="comment">// last === 4, </span></span><br><span class="line"><span class="comment">// numbers [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Beginning</span></span><br><span class="line"><span class="keyword">const</span> first = numbers.shift();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Middle</span></span><br><span class="line">numbers.splice(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// from index 1, delete 2 elements</span></span><br><span class="line"><span class="comment">// return elements that be removed</span></span><br></pre></td></tr></table></figure><h3 id="清空-Emptying">清空 Emptying</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> another = numbers;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sol 1 单一引用时</span></span><br><span class="line">numbers = []; <span class="comment">// 但是 another 还指向那块内存空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sol 2 多个引用时</span></span><br><span class="line">numbers.length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sol 3</span></span><br><span class="line">numbers.splice(<span class="number">0</span>, numbers.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sol 4 不推荐</span></span><br><span class="line"><span class="keyword">while</span> (numbers.length &gt; <span class="number">0</span>)</span><br><span class="line">numbers.pop();</span><br></pre></td></tr></table></figure><h3 id="合并拆分-Combining-and-Slicing">合并拆分 Combining and Slicing</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> first = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> second = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// combine [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="keyword">const</span> combined = first.concat(second);</span><br><span class="line"></span><br><span class="line"><span class="comment">// s</span></span><br><span class="line"><span class="keyword">const</span> slice = combined.slice(<span class="number">1</span>); </span><br><span class="line"><span class="comment">// from index 1 to end</span></span><br><span class="line"><span class="comment">// combined.slice(1, 2): from index 1 copy 2 elem</span></span><br><span class="line"><span class="comment">// combined.slice(): copy all</span></span><br></pre></td></tr></table></figure><ul><li>如果拷贝了引用类型，那么拷贝的是它的引用  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [&#123;<span class="attr">id</span> : <span class="number">1</span>&#125;];</span><br><span class="line"><span class="keyword">const</span> b = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> combined = a.concat(b);</span><br><span class="line"><span class="comment">// [&#123;id: 1&#125;, 2, 3, 4]</span></span><br><span class="line">a[<span class="number">0</span>].id = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// [&#123;id: 10&#125;, 2, 3, 4]</span></span><br><span class="line"><span class="comment">// slice 同理，也是拷贝的引用</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Spread-Operator">Spread Operator</h3><p><code>...</code> 拆分数组，把每个元素单独返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> first = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> second = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> combined = [...first, <span class="string">&#x27;a&#x27;</span>, ...second, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> copy = [...combined];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = [...first];</span><br><span class="line"><span class="comment">// a === 1, b === 2, c === 3</span></span><br></pre></td></tr></table></figure><h3 id="遍历-Iterating">遍历 Iterating</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// for of / for in</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> number <span class="keyword">of</span> numbers) </span><br><span class="line"><span class="built_in">console</span>.log(number);</span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach</span></span><br><span class="line">numbers.forEach(<span class="function">(<span class="params">number, index</span>) =&gt;</span> </span><br><span class="line">   <span class="built_in">console</span>.log(index, number));</span><br></pre></td></tr></table></figure><h3 id="连接-Joining-Arrays">连接 Joining Arrays</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// join </span></span><br><span class="line"><span class="keyword">const</span> joined = numbers.join(<span class="string">&#x27;,&#x27;</span>); <span class="comment">// 1,2,3</span></span><br><span class="line"><span class="comment">// numbers.join() === &#x27;1,2,3&#x27; 默认用逗号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// change space&#x27; &#x27; to  hyphen&#x27;-&#x27; in url</span></span><br><span class="line"><span class="keyword">const</span> message = <span class="string">&quot;This is my first message&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> parts = message.split(<span class="string">&#x27; &#x27;</span>); <span class="comment">// word array</span></span><br><span class="line"><span class="keyword">const</span> combined = parts.join(<span class="string">&#x27;-&#x27;</span>); <span class="comment">// a string</span></span><br></pre></td></tr></table></figure><h3 id="排序-Sorting">排序 Sorting</h3><ul><li><p>原地修改，不返回新的数组。</p></li><li><p>不指定回调函数，会按照元素转换为字符串的 Unicode 顺序</p><ul><li>ASC <code>numbers.sort()</code></li><li>DESC <code>numbers.reverse()</code></li></ul></li><li><p>Reference</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> courses = [</span><br><span class="line">&#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;Node.js&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;javascript&#x27;</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按升序</span></span><br><span class="line">courses.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="comment">// a &lt; b =&gt; -1 负数表示 a 前 b 后</span></span><br><span class="line"><span class="comment">// a &gt; b =&gt; 1  正数表示 a 后 b 前</span></span><br><span class="line"><span class="comment">// a === b =&gt; 0 0 表示不交换顺序</span></span><br><span class="line"><span class="comment">// 消除大小写敏感</span></span><br><span class="line"><span class="keyword">const</span> nameA = a.name.toUpperCase();</span><br><span class="line"><span class="keyword">const</span> nameB = b.name.toUpperCase();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nameA &lt; nameB) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (nameA &gt; nameB) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>简单的排序：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a - b &lt; 0 不交换</span></span><br><span class="line"><span class="comment">// a - b &gt; 0 交换</span></span><br><span class="line"><span class="comment">// a - b === 0 不动</span></span><br><span class="line"><span class="comment">// 从小到大</span></span><br><span class="line">arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.value - b.value); </span><br></pre></td></tr></table></figure></li></ul><h3 id="测试-Testing-Elements">测试 Testing Elements</h3><p>新特性，旧浏览器可能不兼容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依次搜索每个元素，如果出现了负数就直接返回 false，不向后继续测试</span></span><br><span class="line"><span class="keyword">const</span> allPositive = numbers.every(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> value &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要出现了符合条件的一个，就返回</span></span><br><span class="line"><span class="keyword">const</span> atLeastOnePositive = numbers.some(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> value &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="筛选-Filtering">筛选 Filtering</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> filtered = numbers.filter(<span class="function"><span class="params">n</span> =&gt;</span> n &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="comment">// [1, 2]</span></span><br><span class="line"><span class="comment">// 返回符合条件的元素组合成的数组</span></span><br><span class="line"><span class="comment">// 还可以传index等参数</span></span><br></pre></td></tr></table></figure><p>同样可以筛选符合条件的对象。</p><h3 id="映射-Mapping">映射 Mapping</h3><p>把每个元素映射为其他的东西。</p><ul><li>映射成字符串：  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = filtered.map(<span class="function"><span class="params">n</span> =&gt;</span> <span class="string">&#x27;&lt;li&gt;&#x27;</span> + n + <span class="string">&#x27;&lt;\n&gt;&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> html = <span class="string">&#x27;&lt;ul&gt;&#x27;</span> + items.join(<span class="string">&#x27;&#x27;</span>) + <span class="string">&#x27;&lt;\ul&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li>映射成对象：  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// obj 的 &#123;&#125; 会被默认识别为函数体的&#123;&#125;</span></span><br><span class="line"><span class="comment">// 所以如果直接返回对象的话，要加一层 ()</span></span><br><span class="line"><span class="keyword">const</span> items = filtered.map(<span class="function"><span class="params">n</span> =&gt;</span> (&#123;<span class="attr">value</span>: n&#125;));</span><br></pre></td></tr></table></figure></li></ul><p>Chaining methods： 链式调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依次对前面生成的数组进行处理</span></span><br><span class="line"><span class="keyword">const</span> items = numbers</span><br><span class="line">.filter(<span class="function"><span class="params">n</span> =&gt;</span> n &gt;= <span class="number">0</span>)</span><br><span class="line">.map(<span class="function"><span class="params">n</span> =&gt;</span> (&#123; <span class="attr">value</span>: n &#125;))</span><br><span class="line">.filter(<span class="function"><span class="params">obj</span> =&gt;</span> obj.value &gt; <span class="number">1</span>)</span><br><span class="line">.map(<span class="function"><span class="params">obj</span> =&gt;</span> obj.value);</span><br></pre></td></tr></table></figure><h3 id="缩减-Reducing">缩减 Reducing</h3><p>把整个数组缩减成一个单一的值：数字、字符串、对象……</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, -<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sum = numbers.reduce(</span><br><span class="line">(accumulator, currentValue) =&gt; accumulator + currentValue</span><br><span class="line">);</span><br><span class="line"><span class="comment">// a = 1, c = 2 =&gt; a = 3</span></span><br><span class="line"><span class="comment">// a = 3, c = -3 =&gt; a = 0</span></span><br><span class="line"><span class="comment">// a = 0, c = 4 =&gt; a = 4</span></span><br><span class="line"><span class="comment">// sum = 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认时 a 是第一个元素，c 是第二个元素</span></span><br><span class="line"><span class="comment">// 给 reduce() 传入第二个参数初始化 a，但是会多一次运算</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Function">Function</h2><h3 id="Hoisting">Hoisting</h3><p>Function declaration will be moved to the top of the file by JavaScript engine when executing. But function expression will not.</p><ul><li><p>函数声明</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">walk();</span><br><span class="line"><span class="comment">// funtion declaration</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">walk</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;walk&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数表达式</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Uncaught ReferenceError:</span></span><br><span class="line"><span class="comment">// Cannot access &#x27;run&#x27; before initialization</span></span><br><span class="line"><span class="comment">// run();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// named / anonymous function expression</span></span><br><span class="line"><span class="keyword">const</span> run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;run&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> move = run; <span class="comment">// reference to the same af</span></span><br><span class="line">run();</span><br><span class="line">move();</span><br></pre></td></tr></table></figure></li></ul><h3 id="arguments">arguments</h3><p>每个函数内，有一个内置的对象：<code>arguments</code>，因为有迭代器 <code>Symbol.iterator</code>，所以可以使用 <code>for...of</code> 遍历：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> <span class="built_in">arguments</span>)</span><br><span class="line">        total += value;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure><h3 id="Rest-Parameter">Rest Parameter</h3><p><code>...</code> Rest Operator 和 Spread Operator 区分：</p><ol><li><code>let [a, b, c] = [...numbers]</code> 是把 numbers 数组的每个元素单独拿出来</li><li><code>function fn(a, b, ...args)</code> 是将多余的parameters 放到一个数组 args 里</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>));</span><br></pre></td></tr></table></figure><ul><li>使用 Rest Operator 的参数叫做 Rest Parameter，必须是参数列表的最后一个参数。</li></ul><h3 id="Default-Parameter">Default Parameter</h3><p>函数的参数列表中，有默认值的参数，在调用函数时，可以不显式赋值。</p><p>最佳实践是把有默认值的参数都放在最后，这样调用传参时不用 <code>undefined</code> 占位跳过（很丑）</p><h3 id="Getters-Setters">Getters &amp; Setters</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    firstName: <span class="string">&#x27;Mosh&#x27;</span>,</span><br><span class="line">    lastName: <span class="string">&#x27;Hamedani&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span> <span class="title">fullName</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> <span class="title">fullName</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> parts = value.split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.firstName = parts[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">this</span>.lastName = parts[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// setter =&gt; change(mutate) properties</span></span><br><span class="line">person.fullName = <span class="string">&#x27;John Smith&#x27;</span>;</span><br><span class="line"><span class="comment">// getter =&gt; access properties</span></span><br><span class="line"><span class="built_in">console</span>.log(person.fullName);</span><br></pre></td></tr></table></figure><h3 id="try-catch">try &amp; catch</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// some codes, then</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;An error.&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line"><span class="comment">// deal with the error</span></span><br><span class="line"><span class="comment">// or give some feedback to user</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Scope-Local-vs-Global">Scope (Local vs Global)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> color = <span class="string">&#x27;red&#x27;</span>; <span class="comment">// global</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> color = <span class="string">&#x27;blue&#x27;</span>; <span class="comment">// local</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(color); <span class="comment">// blue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>局部变量会覆盖掉同名的全局变量。</li><li>全局变量可以在任意地方访问，所以要避免声明和使用全局变量，因为可能在某个位置就把需要的值改变了。</li></ul><h3 id="Let-vs-Var">Let vs Var</h3><ol><li>在函数内部，作用域范围：<ul><li><code>var</code> 声明的变量是 function-scoped，在函数内部任意位置都能访问</li><li>ES6（ES2015）开始使用 <code>let</code> 和 <code>const</code> 声明变量是 block-scoped，在代码块（for 循环 或者 if 语句）之外都无法访问，但是在内部的代码块中可以访问。</li></ul></li><li>全局作用域：<ul><li><code>var</code> 声明的全局变量，会添加到 <code>window</code> 对象的属性中，而 <code>window</code> 对象是唯一的，可能会覆盖其本身的同名属性。所以应该避免给 <code>window</code> 对象添加成员。</li><li><code>let</code> 不会添加到全局对象。</li></ul></li></ol><p>在 Global 作用域定义的函数，也会添加到 <code>window</code>对象的成员，也应该避免（使用 module）。</p><p>另外，<code>var</code> 声明的变量，可以重复声明。</p><h3 id="‘this’">‘this’</h3><p>The <code>this</code> keyword references “the <strong>object</strong> that is executing the current function”.</p><p><code>this</code> in:</p><ul><li>method -&gt; obj</li><li>function -&gt; global (<code>window</code> in browser, <code>global</code> in node)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> video = &#123;</span><br><span class="line">    title: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    tags: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">    <span class="function"><span class="title">showTags</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tags.forEach(<span class="function">(<span class="params">tag</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.title, tag);</span><br><span class="line">        &#125;, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">video.showTags();</span><br></pre></td></tr></table></figure><ul><li><code>forEach</code> 的第一个参数是一个回调函数 callbackfn，执行回调函数的是 <code>window</code> 对象，而不是 <code>video</code> 对象，所以这个回调函数不是 method，回调函数中使用的 <code>this</code> 就是 <code>window</code></li><li>增加第二个参数 <code>thisArg</code> 传入一个对象，那么回调函数中 <code>this</code> 指代的就是传入的对象。</li></ul><p>但是，并不是所有函数都可以传入 <code>thisArg</code>。</p><h3 id="Change-‘this’">Change ‘this’</h3><ol><li>中继变量 <code>self</code></li><li><code>bind</code> 方法</li><li>箭头函数，继承 <code>this</code></li></ol><p>（不好的办法）在 <code>this</code> 被修改之前，给一个别名 <code>const self = this</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">showTags</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line"><span class="built_in">this</span>.tags.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">tag</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(self.title, tag);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数对象的内置方法：<code>call, apply, bind</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">playVideo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">playVideo.call(&#123; <span class="attr">name</span>:<span class="string">&#x27;apple&#x27;</span> &#125;, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">playVideo.apply(&#123; <span class="attr">name</span>:<span class="string">&#x27;apple&#x27;</span> &#125;, [<span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line">playVideo.bind(&#123; <span class="attr">name</span>:<span class="string">&#x27;apple&#x27;</span> &#125;, [<span class="number">1</span>, <span class="number">2</span>])();</span><br><span class="line"></span><br><span class="line">playVideo(); <span class="comment">// window</span></span><br></pre></td></tr></table></figure><ul><li><code>call()</code> 把第一个参数绑定 <code>this</code>，单独传入参数，调用；</li><li><code>apply()</code> 把第一个参数绑定 <code>this</code>，用数组方式传入参数，调用；</li><li><code>bind()</code> 把第一个参数绑定 <code>this</code>，不调用。</li></ul><p>（旧办法）<code>bind</code> 匿名函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">showTags</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.tags.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">tag</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.title, tag);</span><br><span class="line">&#125;.bind(<span class="built_in">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（ES6 新办法）箭头函数会继承容器函数的 <code>this</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">showTags</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.tags.forEach(<span class="function"><span class="params">tag</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.title, tag);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;原版课程请访问：&lt;a href=&quot;https://codewithmosh.com/&quot;&gt;Code With Mosh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;B 站中文字幕版：&lt;a href=&quot;https://www.bilibili.com/video/BV13b411H7LR/?p=103&amp;amp;share_source=copy_web&amp;amp;vd_source=9fbcc6c828dc945d8ee14b34a7922c47&quot;&gt;JavaScript 基础篇 - Mosh&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Operators &amp;amp; Flow Control &amp;amp; Object &amp;amp; Arrays &amp;amp; Function&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://doreality.xyz/categories/Development/"/>
    
    
    <category term="JavaScript" scheme="https://doreality.xyz/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>终端命令提示符 prompt 样式定制</title>
    <link href="https://doreality.xyz/posts/47012712.html"/>
    <id>https://doreality.xyz/posts/47012712.html</id>
    <published>2022-07-15T02:40:15.000Z</published>
    <updated>2023-04-07T16:07:20.037Z</updated>
    
    <content type="html"><![CDATA[<p>终端的命令提示符样式定制：macOS / Linux</p><span id="more"></span><p>如果使用的是 oh-my-zsh，不同的主题就可以对应不同的命令提示符配置，但是要个性化配置可以参考如下：</p><ul><li><p><a href="https://blog.csdn.net/S_gy_Zetrov/article/details/80158409?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-1-80158409-blog-119827463.pc_relevant_vip_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-1-80158409-blog-119827463.pc_relevant_vip_default&amp;utm_relevant_index=2">oh-my-zsh修改主题添加全路径显示</a></p></li><li><p><a href="https://blog.csdn.net/nyist_zxp/article/details/108089181">Linux 终端命令提示符总结</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;终端的命令提示符样式定制：macOS / Linux&lt;/p&gt;</summary>
    
    
    
    <category term="Tools" scheme="https://doreality.xyz/categories/Tools/"/>
    
    
    <category term="oh-my-zsh" scheme="https://doreality.xyz/tags/oh-my-zsh/"/>
    
  </entry>
  
  <entry>
    <title>macOS 修改主机名等</title>
    <link href="https://doreality.xyz/posts/66790ec6.html"/>
    <id>https://doreality.xyz/posts/66790ec6.html</id>
    <published>2022-07-15T02:37:48.000Z</published>
    <updated>2022-07-15T03:01:00.058Z</updated>
    
    <content type="html"><![CDATA[<p>修改终端上显示的主机名。</p><span id="more"></span><ul><li><a href="https://blog.csdn.net/HDFQQ188816190/article/details/116521499">Mac 修改主机名、计算机名、本地主机名、xcode作者名、终端前缀</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;修改终端上显示的主机名。&lt;/p&gt;</summary>
    
    
    
    <category term="Tools" scheme="https://doreality.xyz/categories/Tools/"/>
    
    
    <category term="macOS" scheme="https://doreality.xyz/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>在终端中进入 Python 的 venv</title>
    <link href="https://doreality.xyz/posts/4f8c09df.html"/>
    <id>https://doreality.xyz/posts/4f8c09df.html</id>
    <published>2022-06-24T14:38:56.000Z</published>
    <updated>2023-04-07T16:26:27.910Z</updated>
    
    <content type="html"><![CDATA[<p>怎么从终端进入一个 Python 的虚拟环境 <code>venv</code>？</p><span id="more"></span><ol><li>进入</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$source</span> <span class="string">&quot;the venv root path&quot;</span>/bin/activate</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;怎么从终端进入一个 Python 的虚拟环境 &lt;code&gt;venv&lt;/code&gt;？&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://doreality.xyz/categories/Development/"/>
    
    
    <category term="Python" scheme="https://doreality.xyz/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>mac 如何彻底删除 Python</title>
    <link href="https://doreality.xyz/posts/4594a661.html"/>
    <id>https://doreality.xyz/posts/4594a661.html</id>
    <published>2022-06-23T08:29:36.000Z</published>
    <updated>2023-04-07T16:12:27.062Z</updated>
    
    <content type="html"><![CDATA[<p>完全删除 mac 中的不同版本的 Python</p><span id="more"></span><ul><li><a href="http://t.zoukankan.com/zhangchenliang-p-8204543.html">Mac 删除/卸载 自己安装的python</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;完全删除 mac 中的不同版本的 Python&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://doreality.xyz/categories/Development/"/>
    
    
    <category term="Python" scheme="https://doreality.xyz/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>使用 Homebrew 安装出现 git 报错</title>
    <link href="https://doreality.xyz/posts/74a7d1c5.html"/>
    <id>https://doreality.xyz/posts/74a7d1c5.html</id>
    <published>2022-06-20T03:12:38.000Z</published>
    <updated>2023-04-07T16:26:58.611Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Homebrew 安装的时候出现 git 的报错。</p><span id="more"></span><p>问题如下：</p><p>根据提示，添加两条 <code>git config</code> 即可：</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用 Homebrew 安装的时候出现 git 的报错。&lt;/p&gt;</summary>
    
    
    
    <category term="Q&amp;A" scheme="https://doreality.xyz/categories/Q-A/"/>
    
    
    <category term="Homebrew" scheme="https://doreality.xyz/tags/Homebrew/"/>
    
  </entry>
  
  <entry>
    <title>使用 Pyenv 管理 Python</title>
    <link href="https://doreality.xyz/posts/e30c74da.html"/>
    <id>https://doreality.xyz/posts/e30c74da.html</id>
    <published>2022-06-20T03:10:51.000Z</published>
    <updated>2023-04-07T16:37:13.576Z</updated>
    
    <content type="html"><![CDATA[<p>管理电脑上不同版本的 Python：</p><ul><li>参考：<a href="https://github.com/pyenv/pyenv">https://github.com/pyenv/pyenv</a></li><li>环境：macOS + Homebrew + Zsh</li></ul><span id="more"></span><h2 id="安装-Pyenv">安装 Pyenv</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$brew</span> update</span><br><span class="line"><span class="variable">$brew</span> install pyenv</span><br></pre></td></tr></table></figure><ul><li>如果 <code>brew</code> 出现了 <code>git</code> 的报错：<a href="https://doreality.xyz/posts/74a7d1c5.html">解决 Homebrew 出现 git 报错</a></li></ul><h2 id="设置-Shell">设置 Shell</h2><ol><li>添加 <code>$PYENV_ROOT</code> 到 <code>$PATH</code></li><li>添加 <code>pyenv</code> 为 shell 命令</li><li>安装 <code>pyenv</code> 到 shell function</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$echo</span> <span class="string">&#x27;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="variable">$echo</span> <span class="string">&#x27;command -v pyenv &gt;/dev/null || export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="variable">$echo</span> <span class="string">&#x27;eval &quot;$(pyenv init -)&quot;&#x27;</span> &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure><ol start="4"><li>设置完毕，重启 shell</li></ol><h2 id="安装指定版本的-Python">安装指定版本的 Python</h2><ol><li>首先安装依赖：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$brew</span> install openssl readline sqlite3 xz zlib tcl-tk</span><br></pre></td></tr></table></figure><ol start="2"><li>安装 Python</li></ol><p>例如安装 Python 3.6.10：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$pyenv</span> install 3.6.10</span><br></pre></td></tr></table></figure><p>然后经过漫长的等待，出现下列语句表示安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Installed Python-3.6.15 to /Users/doreality/.pyenv/versions/3.6.15</span><br></pre></td></tr></table></figure><h2 id="使用-Pyenv">使用 Pyenv</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$pyenv</span> versions <span class="comment"># 查看已安装的版本</span></span><br><span class="line"><span class="variable">$pyenv</span> global 3.6.15 <span class="comment"># 指定全局模式下的 Python 版本为 3.6.15</span></span><br><span class="line"><span class="variable">$pyenv</span> <span class="built_in">local</span> 3.10.10 <span class="comment"># 指定当前目录下的 Python 版本为 3.10.10</span></span><br><span class="line"><span class="variable">$pyenv</span> uninstall 3.6.15 <span class="comment"># 删除 3.6.15 版本</span></span><br></pre></td></tr></table></figure><h2 id="Pyenv-virtualenv">Pyenv virtualenv</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$pyenv</span> virtualenv 3.6.15 venv3615 <span class="comment"># 创建一个虚拟环境</span></span><br><span class="line"><span class="variable">$pyenv</span> activate venv3615 <span class="comment"># 进入该虚拟环境</span></span><br><span class="line"><span class="variable">$pyevn</span> deactivate venv3615 <span class="comment"># 退出</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;管理电脑上不同版本的 Python：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参考：&lt;a href=&quot;https://github.com/pyenv/pyenv&quot;&gt;https://github.com/pyenv/pyenv&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;环境：macOS + Homebrew + Zsh&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Development" scheme="https://doreality.xyz/categories/Development/"/>
    
    
    <category term="Python" scheme="https://doreality.xyz/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>「LCTHW」函数与指针篇（EX 14-18）</title>
    <link href="https://doreality.xyz/posts/4b675d3.html"/>
    <id>https://doreality.xyz/posts/4b675d3.html</id>
    <published>2022-06-01T14:59:03.000Z</published>
    <updated>2023-04-07T16:30:46.814Z</updated>
    
    <content type="html"><![CDATA[<p>Learn C The Hard Way, notes for ex14 to ex18.</p><span id="more"></span><h2 id="Exercise-14-Writing-and-Using-Functions">Exercise 14. Writing and Using Functions</h2><ul><li>用 for 读一个字符串：不用判断长度，可以判断 <code>\0</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; arg[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = arg[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ctype-h">ctype.h</h3><table><thead><tr><th>funtion</th><th>meaning</th></tr></thead><tbody><tr><td><code>isalnum()</code></td><td>checks for an alphanumeric character; it is equivalent to (isalpha© || isdigit©).</td></tr><tr><td><code>isalpha()</code></td><td>checks for an alphabetic character; in the standard “C” locale, it is equivalent to (isupper© || islower©).  In some locales, there may be additional characters for which isalpha() is true–letters which are neither uppercase nor lowercase.</td></tr><tr><td><code>isascii()</code></td><td>checks whether c is a 7-bit unsigned char value that fits into the ASCII character set.</td></tr><tr><td><code>isblank()</code></td><td>checks for a blank character; that is, a space or a tab.</td></tr><tr><td><code>iscntrl()</code></td><td>checks for a control character.</td></tr><tr><td><code>isdigit()</code></td><td>checks for a digit (0 through 9).</td></tr><tr><td><code>isgraph()</code></td><td>checks for any printable character except space.</td></tr><tr><td><code>islower()</code></td><td>checks for a lowercase character.</td></tr><tr><td><code>isprint()</code></td><td>checks for any printable character including space.</td></tr><tr><td><code>ispunct()</code></td><td>checks for any printable character which is not a space or an alphanumeric character.</td></tr><tr><td><code>isspace()</code></td><td>checks for white-space characters.  In the “C” and “POSIX” locales, these are: space, form-feed (‘\f’), newline (‘\n’), carriage return (‘\r’), horizontal  tab(‘\t’), and vertical tab (‘\v’).</td></tr><tr><td><code>isupper()</code></td><td>checks for an uppercase letter.</td></tr><tr><td><code>isxdigit()</code></td><td>checks for hexadecimal digits, that is, one of 0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F.</td></tr></tbody></table><h3 id="Forward-Declaration">Forward Declaration</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// forward declarations: solve chicken-and-egg problems</span></span><br><span class="line"><span class="comment">// use it before actually define it.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">can_print_it</span><span class="params">(<span class="keyword">char</span> ch)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_letters</span><span class="params">(<span class="keyword">char</span> arg[], <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_arguments</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// call can_print_it</span></span><br><span class="line"><span class="comment">// call print_letters</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">print_letters(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因：</p><ol><li>最终要创建自己的头文件，头文件中包含的都是前置声明<ul><li>headers: declare <code>define</code>， <code>enum</code>， type，funtions</li></ul></li><li>避免 children-and-egg 问题<ul><li>如果两个函数互相调用，那么谁先定义呢？</li><li>避免了调用嵌套的困扰，不用按照调用的方式顺序定义 calling order</li><li>可以按照一些逻辑顺序进行函数的定义 logical order：例如实际使用的函数次序</li></ul></li><li><code>main()</code> 放在最后：更习惯的用法</li></ol><ul><li><p><code>can_print_it()</code> 定义成函数的原因：</p><ol><li>可以方便修改里面的内容</li><li>可以多个地方调用</li></ol></li><li><p>不要使用 K&amp;R C 的函数声明方法</p></li></ul><h2 id="Exercise-15-Pointers-Dreaded-Pointers">Exercise 15. Pointers, Dreaded Pointers</h2><ul><li><p><code>ages[i]</code>:</p><ol><li><code>i</code>: an <em>index</em> / <em>address</em> since it’s a <strong>location</strong> <em>inside</em> <code>ages</code> that we want</li><li><code>ages</code>: <em>(base) address</em> a <strong>location</strong> in the computer’s <em>memory</em> where all of these integers start</li><li>C compiler will replace <code>ages</code> anywhere you type it with the <em>address</em> of the very first integer in <code>ages</code></li></ol></li></ul><p>C 把大块的字节数组（也就是内存），抽象为不同<strong>大小</strong>的<strong>类型</strong></p><ul><li>C thinks your whole computer is one <strong>massive array of bytes</strong></li><li>What C does is <em>layer</em> on top of this massive array of bytes the concept of <code>types</code> and <code>sizes</code> of those <code>types</code></li></ul><h3 id="Pointers">Pointers</h3><p>A <strong>pointer</strong> is simply an <em>address</em> pointing somewhere inside the computer’s memory with a <em>type specifier</em> so that you get the <strong>right size of data</strong> with it.</p><p>Pointers are just <strong>numbers</strong>.</p><ol><li>Ask the OS for a chunk of memory and use a pointer to work with it. This includes strings and something you haven’t seen yet, <code>structs</code></li><li>Ask the OS for a chunk of memory and use a pointer to work with it. This includes strings and something you haven’t seen yet, <code>structs</code></li><li>Take the address of a function, so you can use it as a <em>dynamic callback</em>.</li><li>Scan complex chunks of memory, converting bytes off of a <em>network socket</em> into data structures or parsing files.</li></ol><p>其他情况，几乎都可以用 arrays 来解决，用数组的操作方法来使用指针（索引）。</p><p>These days, the syntax to access an array versus a pointer are translated into the same machine code and optimized in the same way.</p><p>只有在十分确定的情况，再用指针来<strong>优化</strong>。</p><h3 id="Pointers-NOT-Arrays">Pointers NOT Arrays</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *ptr = arr;</span><br></pre></td></tr></table></figure><ol><li><p><code>sizeof()</code></p><ul><li><code>sizeof(ptr)</code> 得到的是指针的大小，32 位机器是 4 Bytes，64 位机器是 8 Bytes；</li><li><code>sizeof(arr)</code> 得到的是数组的大小，<code>5 * sizeof(int)</code></li></ul></li><li><p>赋值</p><ul><li><code>ptr = arr</code>，是把数组的起始地址给 <code>ptr</code></li><li><code>arr = ptr</code>，error: assignment to expression with array type</li></ul></li><li><p>增减</p><ul><li><code>ptr++</code>，让指针指向接下来一个该类型的元素</li><li><code>arr++</code>，error: lvalue required as increment operand，数组名 <code>arr</code> 不是<em>左值</em></li></ul></li></ol><p>数组名也不是常指针（即指针常量，a const pointer is pointed at a static address）<code>type *const ptr</code>，由上述三点可以判断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a constant integer A</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> A;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> A; </span><br><span class="line"></span><br><span class="line"><span class="comment">// a pointer B, point at an constant integer </span></span><br><span class="line"><span class="comment">// 常量指针 / 指向常量的指针</span></span><br><span class="line"><span class="comment">// B 可以指向别的常量，B 的值可变</span></span><br><span class="line"><span class="comment">// 但是不能修改其地址内的内容，*B 不可变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *B;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *B;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a constant pointer C </span></span><br><span class="line"><span class="comment">// 常指针/指针常量</span></span><br><span class="line"><span class="comment">// C 指向的地址不再变化，C 的值不可变</span></span><br><span class="line"><span class="comment">// 但是可以修改其地址内的内容，*C 可变</span></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> C;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a constant pointer D points at a constant integer</span></span><br><span class="line"><span class="comment">// D 和 *D 都不可变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> D;</span><br></pre></td></tr></table></figure><h3 id="指针数组和数组指针">指针数组和数组指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指针数组，每个元素 names[i] 是一个指针</span></span><br><span class="line"><span class="keyword">char</span> *names[] = &#123;</span><br><span class="line"><span class="string">&quot;Alan&quot;</span>, <span class="string">&quot;Frank&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s, %s, %s, %s\n&quot;</span>, names[<span class="number">1</span>], *(names + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组指针，是一个指针，指向一维数组的地址</span></span><br><span class="line"><span class="comment">// name[i] == names + i，移动 i * N 个内存单元</span></span><br><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[N] = &#123; <span class="string">&quot; &quot;</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> (*names)[N] = &amp;<span class="built_in">string</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;string = %s, names = %s, %s\n&quot;</span>, </span><br><span class="line">   <span class="built_in">string</span>, *names, names[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><h2 id="Exercise-16-Structs-And-Pointers-to-Them">Exercise 16. Structs And Pointers to Them</h2><ol><li><p><code>strdup(const char *s)</code>，in <code>string.h</code></p><ul><li>The  <code>strdup()</code>  function  returns  a  pointer to a new string which is a duplicate of the string s.  Memory for the new string is obtained with<code> malloc</code>(3), and can be freed with <code>free</code>(3).</li><li><code>char *a = strdup(&quot;Hello, world&quot;);</code></li><li><code>char a[20]; strcpy(a, &quot;Hello, world&quot;);</code></li></ul></li><li><p><code>free(frank); frank = NULL;</code></p><ul><li>释放之后，把指针置空，否则后面如果还访问这个指针，可能会读到奇怪的内容</li><li><code>free()</code> 把指针指向的内容清空（或者说，告诉 OS 不再使用），但是指针的值没有改，可能还可以正常输出内容</li><li><code>Valgrind</code> 可以提示这个错误 <code>invalid read / invalid free()</code></li></ul></li></ol><h3 id="Memory-Leak">Memory Leak</h3><p>使用 Valgrind 检查内存泄漏：</p><p><code>valgrind --leak-check=full --show-reachable=yes -v ./ex16</code></p><h2 id="Exercise-17-Heap-and-Stack-Memory-Allocation">Exercise 17. Heap and Stack Memory Allocation</h2><ul><li>make a prototype to initialize it</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Address</span> <span class="title">addr</span> =</span> &#123;.id = i, .<span class="built_in">set</span> = <span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><ul><li>nested arrow</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Address</span> *<span class="title">addr</span> =</span> &amp;conn-&gt;db-&gt;rows[i];</span><br></pre></td></tr></table></figure><p><code>&amp;conn-&gt;db-&gt;rows[i]</code> that reads “get the <code>i</code> element of <code>rows</code>, which is in <code>db</code>, which is in <code>conn</code>, then get the address of (<code>&amp;</code>) it.”</p><ul><li><code>atoi</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atoi</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">atol</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">atoll</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;</span><br></pre></td></tr></table></figure><p>The <code>atoi()</code> function converts the initial portion of the string pointed to by nptr to int.  The behavior is the same as <code>strtol(nptr, NULL, 10);</code>  except that <code>atoi()</code> does not detect errors.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">strtol</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr, <span class="keyword">char</span> **endptr, <span class="keyword">int</span> base)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>fread</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, </span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">size_t</span> nmemb, FILE *stream)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">size_t</span> nmemb, FILE *stream)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetpos</span><span class="params">(FILE *stream, <span class="keyword">fpos_t</span> *pos)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsetpos</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">fpos_t</span> *pos)</span></span>;</span><br></pre></td></tr></table></figure><p>The function <code>fread()</code> reads <code>nmemb</code> items of data, each <code>size</code> bytes long, from the stream pointed to by <code>stream</code>, storing them at the location given by <code>ptr</code>.</p><p>成功返回读写的数据项的个数，失败返回0.</p><p>回到文件开头：<code>rewind(stream)</code> == <code>(void) fseek(stream, 0L, SEEK_SET)</code></p><ul><li><code>strncpy</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncpy</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>The <code>strncpy()</code> function is similar, except that at most <code>n</code> bytes of <code>src</code> are copied.</p><p>Warning: If there is no <em>null byte</em> among the first <code>n</code> bytes  of  <code>src</code>,  the  string placed in <code>dest</code> will <em><strong>not</strong></em> be null-terminated.</p><p>So add the null byty <code>'\0'</code> manually.</p><h3 id="Heap-and-Stack">Heap and Stack</h3><p>C is using the real CPU’s actual machinery to do its work, and that involves a chunk of RAM called the <strong>stack</strong> and another called the <strong>heap</strong>.</p><ul><li><p>Heap：<code>malloc</code> and <code>free</code>.</p><ol><li>ask OS to register a piece of memory, return a pointer</li><li>after using, give it back to OS, so that won’t <em>leak</em></li></ol></li><li><p>Stack</p><ol><li>Just like a stack data struction, LIFO</li><li>Store the local variables, even those in main function.</li><li>prevent leak</li></ol></li></ul><p>堆和栈的三个主要问题：</p><ol><li>如果在函数中，使用 <code>malloc</code>  申请了一块内存，而指针是在栈上定义的，那么函数结束之后，指针会出栈，然后内存就丢失（泄漏）</li><li>如果在栈上申请了太大的数据（large structs and array），可能会造成 <code>stack overflow</code> 栈溢出，导致错误。这时应该用 <code>malloc</code>。</li><li>如果在函数定义的局部变量，使用指针返回，那么就会得到 <code>segmentation fault</code> 段错误，因为变量在函数结束的时候已经出栈消失，指针指向一个 dead space</li></ol><p>程序结束后，操作系统会回收空间，但是有时候不会立刻回收；所以使用错误退出，<code>exit(1)</code>，让操作系统当作错误，直接回收。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Learn C The Hard Way, notes for ex14 to ex18.&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://doreality.xyz/categories/Development/"/>
    
    
    <category term="C" scheme="https://doreality.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>「LCTHW」C 语言基础篇（EX 1-13）</title>
    <link href="https://doreality.xyz/posts/5fed90c.html"/>
    <id>https://doreality.xyz/posts/5fed90c.html</id>
    <published>2022-06-01T14:50:55.000Z</published>
    <updated>2023-04-07T16:30:54.773Z</updated>
    
    <content type="html"><![CDATA[<p>Learn C The Hard Way, notes for ex01 to ex13.</p><span id="more"></span><h2 id="Exercise-2-Using-Makefiles-to-Build">Exercise 2. Using Makefiles to Build</h2><p>How <strong>Make</strong> Works?</p><blockquote><p>Implied dependencies and ancient lore.</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make ex1</span><br></pre></td></tr></table></figure><ul><li><p>可以通过 <code>ex1</code> 来推测要用来构建的文件是 <code>ex1.c</code>，同名的其他后缀的文件。</p></li><li><p>是几十年来的经验，和隐含的依赖。</p></li></ul><h2 id="Exercise-3-Formatted-Printing">Exercise 3. Formatted Printing</h2><p>使用变量不进行初始化：可能是0，也可能是随机的数据。</p><p>所以<em>一定要初始化</em>：要么是要用的值，要么是错误值（<code>-1</code> 或 <code>NULL</code>）。</p><ul><li><p><code>printf()</code> 格式输出、对齐、宽度、精度：<br><a href="https://blog.csdn.net/muge323/article/details/123402431">https://blog.csdn.net/muge323/article/details/123402431</a></p><ul><li><code>%-8.2f</code>：<ul><li><code>.2</code> 保留2位精度（包括整数部分）</li><li><code>-</code>左对齐</li><li><code>8</code>占8位宽度</li></ul></li></ul></li></ul><h2 id="Exercise-4-Using-a-Debugger">Exercise 4. Using a Debugger</h2><h3 id="GBD-LLDB">GBD / LLDB</h3><ul><li><p>总结：<a href="https://doreality.xyz/posts/3b78b4cb.html">GDB / LLDB 常用命令</a></p></li><li><p>一个参考：<a href="https://beej.us/guide/bggdb/">Beej’s Quick Guide to GDB</a></p></li><li><p>打印所有线程的栈 ：<code>thread apply all bt </code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) thread apply all bt</span><br><span class="line"></span><br><span class="line">Thread 1 (process 917):</span><br><span class="line">#0  0x0000000000400704 in crash () at ex3.c:8</span><br><span class="line">#1  0x00000000004007d4 in main (argc&#x3D;1, argv&#x3D;0xfffffffffd48) at ex3.c:24</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></li><li><p>运行程序，并在出错的时候直接返回调用栈信息：</p><p><code>gdb --batch --ex r --ex bt --ex q --args</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@ddafb7ecb5fe:~&#x2F;lc# gdb --batch --ex r --ex bt --ex q --args .&#x2F;ex3</span><br><span class="line">I am 100 years old.</span><br><span class="line">I am 72 inches tall.</span><br><span class="line">a[20] &#x3D; 0</span><br><span class="line">22.1    ,</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x0000000000400704 in crash () at ex3.c:8</span><br><span class="line">8        printf(&quot;%c&quot;, test[i]);</span><br><span class="line">#0  0x0000000000400704 in crash () at ex3.c:8</span><br><span class="line">#1  0x00000000004007d4 in main (argc&#x3D;1, argv&#x3D;0xfffffffffd48) at ex3.c:24</span><br><span class="line">A debugging session is active.</span><br><span class="line"></span><br><span class="line">Inferior 1 [process 911] will be killed.</span><br><span class="line"></span><br><span class="line">Quit anyway? (y or n) [answered Y; input not from terminal]</span><br></pre></td></tr></table></figure></li></ul><h3 id="Valgrind">Valgrind</h3><p><a href="https://doreality.xyz/posts/8e3c74d.html">Valgrind 安装</a></p><ul><li>安装和使用：<a href="https://blog.csdn.net/qq_43196193/article/details/118991318">Valgrind 的安装介绍</a></li></ul><h3 id="LINT">LINT</h3><p><code>apt-get install splint</code></p><p><code>splint ex3.c</code></p><h3 id="AddressSanitizer">AddressSanitizer</h3><p><a href="https://github.com/google/sanitizers/wiki/AddressSanitizer">AddressSanitizer GitHub Wiki</a></p><p>GCC 4.8 之后自带。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">gcc -fsanitize=address -fno-omit-frame-pointer -O1 -g test.c -o <span class="built_in">test</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">./<span class="built_in">test</span></span></span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/3a2df9b7c353">Address Sanitizer 用法</a></p><h2 id="Exercise-7-Variables-and-Types">Exercise 7. Variables and Types</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> first_name[] = <span class="string">&quot;Zed&quot;</span>;</span><br><span class="line"><span class="comment">// covered the last byte &#x27;\0&#x27;</span></span><br><span class="line">first_name[<span class="number">3</span>] = <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the pointer has lost the array&#x27;s beginning</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I have a first name %s.\n&quot;</span>, first_name + <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10737418240000000000</span></span><br><span class="line"><span class="comment">// -7709325833709551616 </span></span><br><span class="line"><span class="comment">// unsigned 把负数的补码最高位解释为正数1，而在内存中的二进制形式不变</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> universe_of_defects = <span class="number">4294967296L</span> * <span class="number">4294967295L</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The entire universe has %lu bugs.\n&quot;</span>, universe_of_defects);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(long)=%d.\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// unsigned  = 2147483649</span></span><br><span class="line"><span class="comment">// int = -2147483647</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0b10000000000000000000000000000001</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d.\n&quot;</span>, a);</span><br></pre></td></tr></table></figure><ul><li><code>char * int</code> doesn’t matter</li><li><code>long</code>: linux 64bit  sizeof = 8</li></ul><h2 id="Exercise-8-If-Else-If-Else">Exercise 8. If, Else-If, Else</h2><p>NO BOOLEAN: any integer that’s <em>0</em> is false or otherwise it’s true.</p><p>0 真，非 0 假。</p><h2 id="Exercise-9-While-Loop-and-Boolean-Expressions">Exercise 9. While-Loop and Boolean Expressions</h2><p>写 <code>while</code> 循环的时候，一定注意：</p><ol><li>循环变量初始化了吗？</li><li>每次循环最后，循环变量的值更新了吗？</li><li>如果有 <code>continue</code> 和 <code>break</code>，一定要搞清楚结果是什么<ol><li><code>continue</code> 进入下一步循环的时候，循环变量是否改变？</li><li><code>break</code> 跳出循环的时候，是不是想要的结果边界值？</li></ol></li></ol><h2 id="Exercise-10-Switch-Statements">Exercise 10. Switch Statements</h2><ul><li>Always include a <code>default:</code> branch so that you catch any missing inputs.</li><li>Don’t allow <em>fall through</em> unless you really want it. It’s also a good idea to add a <code>//fallthrough</code> comment so people know it’s on purpose.</li><li>Always write the <code>case</code> and the <code>break</code> before you write the code that goes in it.</li><li>Try to use <code>if-statements</code> instead if you can.</li></ul><ol><li>初始化</li><li>写 <code>case-break</code><ul><li>先写 <code>case</code>，然后紧跟着写 <code>break</code>，然后再写代码逻辑</li></ul></li><li>写 <code>default</code><ul><li>不要忘记，为了覆盖所有的情况，即使不会运行到，也要打印一些错误信息，同理 <code>else</code> 也要这么处理</li></ul></li><li><code>case</code> 只接受字面量常量值</li></ol><h2 id="Exercise-11-Arrays-and-Strings">Exercise 11. Arrays and Strings</h2><p>when you make string literals you should typically use the <code>char *another = &quot;Literal&quot;</code> syntax.</p><p>The source of almost all bugs in C come from forgetting to have enough space, or forgetting to put a <code>'\0'</code> at the end of a string. In fact, it’s so common and hard to get right that the majority of good C code <strong>just doesn’t use</strong> C-style strings.</p><ul><li>按照 <code>numbers[-1]</code> 这样字面量地引用数组范围外的内存，会根据类型大小向前或者向后索引到那个位置，然后输出里面的 garbage</li><li>正常应该越界就报错，但是可能会在一段范围内能运行，但是超出范围就会 <code>Segmentation Fault</code></li></ul><h2 id="Exercise-12-Sizes-and-Arrays">Exercise 12. Sizes and Arrays</h2><ul><li><p>初始化数组：<code>type name[] = &#123;initializer&#125;;</code><br>“I want an array of type that is initialized to {…}.”</p></li><li><p><code>sizeof</code> to ask C how big things are in <em>bytes</em></p><ul><li>所以会计算 <code>'\0'</code> nul_byte 空字节的大小</li></ul></li></ul><p>Linux：</p><img src="/posts/5fed90c/size_of_types.png" class="" title="Sizes for diffrent types on different machines"><p>Tips：</p><ul><li>在 32 位机器上，<strong>指针</strong>是 4 字节；64 位机器上，是 8 字节</li><li><code>long</code> 在 64 位 Windows 上是 4 字节，在 macOS / Linux 64 位上是 8 字节</li><li>其他每个系统都是一样的</li><li>int 的 2 字节应该是在 16 位机器上</li><li><code>SHRT_MAX</code> and <code>INT_MAX</code> must be at least <code>32767</code>=$2^{15} -1$</li><li><code>sizeof(char) &lt;= sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long) &lt;= sizeof(long long)</code></li></ul><h2 id="Exercise-13-For-Loops-and-Arrays-of-Strings">Exercise 13. For-Loops and Arrays of Strings</h2><p>for 循环 <code>for (Initializer; Test; Incremeneter) &#123;&#125;</code>：</p><ol><li>初始化</li><li>判断条件：<ol><li>如果为真，执行循环体，然后进入 3；</li><li>如果为假，跳出循环；</li></ol></li><li>执行 <code>Incrementer</code> 循环变量修改，然后进入 2.</li></ol><p>执行的文件名 <code>./ex13</code> 是 <code>argv[0]</code></p><h3 id="创建字符串数组-Array-of-Strings">创建字符串数组 Array  of Strings</h3><p><code>char *str = &quot;blah&quot;</code> +<code> char str[] = &#123;'b','l','a','h'&#125;</code></p><p>= <code>char *states[] = &#123;...&#125;</code></p><h3 id="逗号表达式">逗号表达式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; <span class="number">5</span>, j &lt; <span class="number">10</span>; i++, j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 只要 j &lt; 10 即可进入循环体</span></span><br><span class="line"><span class="comment">// Do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用逗号分开的表达式的值<strong>分别结算</strong>，整个表达式的值是<strong>最后一个</strong>表达式的值。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Learn C The Hard Way, notes for ex01 to ex13.&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://doreality.xyz/categories/Development/"/>
    
    
    <category term="C" scheme="https://doreality.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 多态：父类指针指向子类对象</title>
    <link href="https://doreality.xyz/posts/1466be2b.html"/>
    <id>https://doreality.xyz/posts/1466be2b.html</id>
    <published>2022-05-26T10:09:35.000Z</published>
    <updated>2023-04-07T16:36:55.672Z</updated>
    
    <content type="html"><![CDATA[<p>C++ 多态；父类（基类）指针指向子类（派生类）对象。</p><span id="more"></span><h2 id="一个小例子">一个小例子</h2><p>遇到了一个小例子（CS 106L）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//No using namespace std;!!!!</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeToOstream</span><span class="params">(<span class="built_in">std</span>::ostream&amp; myOstream, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    myOstream &lt;&lt; <span class="string">&quot;Write number to ostream: &quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myNum = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// : public basic_ostream</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ofstream <span class="title">myOfstream</span><span class="params">(<span class="string">&quot;out.txt&quot;</span>)</span></span>; </span><br><span class="line"></span><br><span class="line">    writeToOstream(<span class="built_in">cout</span>, myNum); <span class="comment">// print to the screen </span></span><br><span class="line">    writeToOstream(myOfstream, myNum); <span class="comment">// print to file </span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的细节还没掌握，暂时粗浅理解为<code>std::ofstream</code> 是 <code>std::ostream</code> 的一个派生类，并且重写了 <code>&lt;&lt;</code> 操作符。</p><p>在函数 <code>writeToOstream()</code> 参数为基类引用 <code>std::ostream&amp;</code> 时，可以让派生类对象 <code>myOfstream</code> 把内容输出到文件 <code>out.txt</code>。原因是，在基类的成员函数实现为 <code>virtual function</code> 的时候，通过基类指针，可以调用派生类中重写后的相应的成员函数。</p><p>这个就是 C++ 多态的实现：<strong>动态绑定（Dynamic Binding）</strong>。</p><h2 id="静态绑定">静态绑定</h2><p>示例<a href="https://www.ibm.com/docs/en/i/7.1?topic=only-virtual-functions-c">来源</a>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Class A&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>:</span> A &#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Class B&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(A&amp; arg)</span> </span>&#123;</span><br><span class="line">   arg.f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   B x;</span><br><span class="line">   g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出是：<code>Class A</code>。</p><p>原因：<code>x</code> 是 B 类的对象，继承了 A 的所有成员和函数，而通过 <code>g(x)</code> 把 <code>x</code> 传给一个基类 A 的引用 <code>arg</code>，通过<strong>静态绑定（Static Binding，编译时绑定）</strong>，只能访问派生类中属于<strong>基类</strong>的那部分内容，而不能调用派生类的特有的成员（例如重写的函数也不行）。</p><h2 id="动态绑定">动态绑定</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Class A&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>:</span> A &#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Class B&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(A&amp; arg)</span> </span>&#123;</span><br><span class="line">   arg.f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   B x;</span><br><span class="line">   g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码输出是： <code>Class B</code></p><p>原因：将基类中的函数添加关键字 <code>virtual</code> 变成虚函数，再在派生类中<strong>重写（override）</strong>，那么派生类中重写的函数也是虚函数。通过基类指针/引用，就可以调用<strong>派生类对象</strong>的虚函数。这提供了一个打破静态绑定规则的机制。</p><p>此时是在<strong>运行时</strong>实现的<strong>动态</strong>绑定：</p><ul><li>如果基类指针指向基类对象，那么调用的依旧是<strong>基类</strong>的函数；</li><li>如果基类指针指向派生类对象，并且调用的是对<strong>基类虚函数进行重写</strong>的虚函数，那么调用的就是<strong>派生类</strong>的成员函数。</li></ul><h3 id="重写规则">重写规则</h3><p>派生类重定义（redefine）基类的虚函数，会覆盖基类的虚函数。</p><p>重写的特点：</p><ol><li>作用域不同；</li><li>函数名、参数列表、返回值相同；</li><li>基类函数是 <code>virtual</code></li></ol><p>若派生类重定义了一个基类虚函数，但是重载（overload，函数名相同，但是返回值和参数列表不同），那么该派生类的函数就不是重写，并且也不是虚函数，同时，会隐藏基类的虚函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Class A&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>:</span> A &#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Class B&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span>:</span> B &#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Class C&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   B b; C c;</span><br><span class="line">   A* pa1 = &amp;b;</span><br><span class="line">   A* pa2 = &amp;c;</span><br><span class="line"><span class="comment">//   b.f();</span></span><br><span class="line">   pa1-&gt;f();</span><br><span class="line">   pa2-&gt;f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class A</span><br><span class="line">Class C</span><br></pre></td></tr></table></figure><p><code>B::f</code> 是重载，<code>C::f</code> 是重写且是虚函数。</p><h2 id="虚函数表">虚函数表</h2><p>C++ 实现虚函数的原理是<strong>虚函数表</strong>+<strong>虚表指针</strong>。</p><p>当一个类里存在虚函数时，</p><ul><li><p>For Class：<strong>编译器</strong>会为<strong>类</strong>创建一个虚函数表，虚函数表是一个<strong>数组</strong>，数组的元素存放的是类中<strong>虚函数的地址</strong>。</p></li><li><p>For Object：编译器为每个类的<strong>对象</strong>添加一个隐藏成员，该隐藏成员保存了指向该虚函数表的<strong>指针</strong>。该隐藏成员占据该对象的内存布局的最前端。</p></li></ul><p><strong>所以虚函数表只有一份，而有多少个对象，就对应多少个虚函数表指针</strong>。</p><h2 id="总结：多态">总结：多态</h2><p>利用虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。</p><p>换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有<strong>多种形态</strong>，或者说有多种表现方式，这种现象称为<strong>多态（Polymorphism）</strong>。</p><h2 id="参考">参考</h2><ul><li><a href="https://blog.csdn.net/qq_21989927/article/details/111226696">怎么理解C++多态的“父类指针或引用指向子类对象”？</a></li><li><a href="https://blog.csdn.net/FX677588/article/details/77727110?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-77727110-blog-111226696.pc_relevant_paycolumn_v3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-77727110-blog-111226696.pc_relevant_paycolumn_v3&amp;utm_relevant_index=2">C++父类指针指向子类对象的实现原理</a></li><li><a href="https://www.ibm.com/docs/en/i/7.1?topic=only-virtual-functions-c">Virtual functions (C++ only)</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++ 多态；父类（基类）指针指向子类（派生类）对象。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://doreality.xyz/categories/Development/"/>
    
    
    <category term="CPP" scheme="https://doreality.xyz/tags/CPP/"/>
    
    <category term="OOP" scheme="https://doreality.xyz/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>GDB / LLDB 常用命令</title>
    <link href="https://doreality.xyz/posts/3b78b4cb.html"/>
    <id>https://doreality.xyz/posts/3b78b4cb.html</id>
    <published>2022-05-22T12:57:29.000Z</published>
    <updated>2023-04-07T16:09:40.379Z</updated>
    
    <content type="html"><![CDATA[<p>GDB 和 LLDB 常用命令汇总，随用随查。</p><span id="more"></span><ul><li><p>参考： LCTHW - Learn C The Hard Way</p></li><li><p>格式：<code>完整命令</code> | <code>缩写</code></p></li></ul><h2 id="GDB">GDB</h2><p>GDB = GNU Debugger</p><h3 id="小技巧">小技巧</h3><ol><li><p><code>gdb --args</code></p><ul><li>Shell 中使用</li><li>传入参数</li></ul></li><li><p><code>thread apply all bt</code></p><ul><li>GDB 中使用</li><li>查看所有线程的调用栈情况</li></ul></li><li><p><code>gdb --batch --ex r --ex bt --ex q --args</code></p><ul><li>Shell 中使用，后面加可执行程序，例如 <code>./test</code></li><li>运行程序，如果出错（Bomb）会输出栈回溯（Stack Backtrace）信息</li><li>简易版 Valgrind</li></ul></li></ol><h3 id="常用命令">常用命令</h3><ol><li><p><code>run [args]</code> | <code>r</code></p><ul><li>Start your program with <code>[args]</code>.</li></ul></li><li><p><code>break [file:]function</code> | <code>b</code></p><ul><li>Set a break point at <code>[file:]function</code>.</li></ul></li><li><p><code>backtrace</code> | <code>bt</code></p><ul><li>Dump a backtrace of the current calling stack.</li></ul></li><li><p><code>print expr</code> | <code>p</code></p><ul><li>Print the value of <code>expr</code>.</li></ul></li><li><p><code>continue</code> | <code>c</code></p><ul><li>Continue running the program.</li></ul></li><li><p><code>next</code> | <code>n</code></p><ul><li>Next line, but step <strong>over</strong> function calls.</li></ul></li><li><p><code>step</code> | <code>s</code></p><ul><li>Next line, but step <strong>into</strong> function calls.</li></ul></li><li><p><code>quit</code> | <code>q</code></p><ul><li>Exit GDB.</li></ul></li><li><p><code>help</code> | <code>h</code></p><ul><li>List the types of commands. You can then get help on the class of command as well as the command.</li></ul></li><li><p><code>cd, pwd, make</code></p><ul><li>This is just like running these commands in your shell.</li></ul></li><li><p><code>shell</code></p><ul><li>Quickly start a shell so you can do other things.</li></ul></li><li><p><code>clear</code></p><ul><li>Clear a breakpoint.</li></ul></li><li><p><code>info break</code>, <code>info watch</code></p><ul><li>Show information about breakpoints and watchpoints.</li></ul></li><li><p><code>attach pid</code></p><ul><li>Attach to a running process so you can debug it.</li></ul></li><li><p><code>detach</code></p><ul><li>Detach from the process.</li></ul></li><li><p><code>list</code></p><ul><li>List out the next ten source lines. Add a - to list the previous ten lines.</li></ul></li></ol><h2 id="LLDB">LLDB</h2><p>The <em>LLDB</em> Debugger (LLDB) is the debugger component of the LLVM (<strong>L</strong>ow <strong>L</strong>evel <strong>V</strong>irtual <strong>M</strong>achine) project.</p><ol><li><p><code>run [args]</code> | <code>r</code></p><ul><li>Start your program with <code>[args]</code>.</li></ul></li><li><p><code>breakpoint set --name [file:]function</code> | <code>b</code></p><ul><li>Set a break point at <code>[file:]function</code>.</li></ul></li><li><p><code>thread backtrace</code> | <code>bt</code></p><ul><li>Dump a backtrace of the current calling stack.</li></ul></li><li><p><code>print expr</code> | <code>p</code></p><ul><li>Print the value of <code>expr</code>.</li></ul></li><li><p><code>continue</code> | <code>c</code></p><ul><li>Continue running the program.</li></ul></li><li><p><code>next</code> | <code>n</code></p><ul><li>Next line, but step over function calls.</li></ul></li><li><p><code>step</code> | <code>s</code></p><ul><li>Next line, but step into function calls. Shorthand is s.</li></ul></li><li><p><code>quit</code> | <code>q</code></p><ul><li>Exit LLDB.</li></ul></li><li><p><code>help</code> | <code>h</code></p><ul><li>List the types of commands. You can then get help on the class of command as well as the command itself.</li></ul></li><li><p><code>cd, pwd, make</code></p><ul><li>just like running these commands in your shell.</li></ul></li><li><p><code>shell</code></p><ul><li>Quickly start a shell so you can do other things.</li></ul></li><li><p><code>clear</code></p><ul><li>Clear a breakpoint.</li></ul></li><li><p><code>info break, info watch</code></p><ul><li>Show information about breakpoints and watchpoints.</li></ul></li><li><p><code>attach -p pid</code></p><ul><li>Attach to a running process so you can debug it.</li></ul></li><li><p><code>detach</code></p><ul><li>Detach from the process.</li></ul></li><li><p><code>list</code></p><ul><li>List out the next ten source lines. Add a - to list the previous ten sources.</li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;GDB 和 LLDB 常用命令汇总，随用随查。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://doreality.xyz/categories/Development/"/>
    
    
    <category term="GDB" scheme="https://doreality.xyz/tags/GDB/"/>
    
    <category term="LLDB" scheme="https://doreality.xyz/tags/LLDB/"/>
    
  </entry>
  
  <entry>
    <title>Valgrind 安装</title>
    <link href="https://doreality.xyz/posts/8e3c74d.html"/>
    <id>https://doreality.xyz/posts/8e3c74d.html</id>
    <published>2022-05-22T12:34:37.000Z</published>
    <updated>2023-04-07T16:09:29.433Z</updated>
    
    <content type="html"><![CDATA[<p>Valgrind：用于内存调试、内存泄漏检测以及性能分析。</p><span id="more"></span><ul><li>环境：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$uname</span> -a</span><br><span class="line">Linux ddafb7ecb5fe 5.10.104-linuxkit <span class="comment">#1 SMP PREEMPT Thu Mar 17 17:05:54 UTC 2022 aarch64 aarch64 aarch64 GNU/Linux</span></span><br></pre></td></tr></table></figure><h2 id="源码-tar-bz2-安装">源码 tar.bz2 安装</h2><ol><li><p>官网下载源代码：<a href="https://valgrind.org/downloads/">https://valgrind.org/downloads/</a></p></li><li><p>进入下载路径，解压到当前目录：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$tar</span> -xjvf valgrind-3.19.0.tar.bz2</span><br></pre></td></tr></table></figure></li><li><p>进入解压后的目录 <code>valgrind-3.19.0</code>，配置和安装：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cd</span> valgrind-3.19.0/</span><br><span class="line"></span><br><span class="line"><span class="comment"># a) 设置环境（需要标准的autoconf工具）</span></span><br><span class="line"><span class="comment"># apt-get install autoconf</span></span><br><span class="line">$./autogen.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># b) 配置 Valgrind，常用参数：--prefix=安装路径</span></span><br><span class="line"><span class="comment"># 这里/root/Valgrind 是我的Docker的路径，虚拟机或者真机自行选择</span></span><br><span class="line">$./configure --prefix=/root/Valgrind</span><br><span class="line"></span><br><span class="line"><span class="comment"># c) 编译安装</span></span><br><span class="line"><span class="variable">$make</span></span><br><span class="line"><span class="variable">$make</span> install</span><br></pre></td></tr></table></figure></li><li><p>验证是否安装成功：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$valgrind</span> ls -l</span><br><span class="line">==23775== Memcheck, a memory error detector</span><br><span class="line">==23775== Copyright (C) 2002-2015, and GNU GPLd, by Julian Seward et al.</span><br><span class="line">==23775== Using Valgrind-3.11.0 and LibVEX; rerun with -h <span class="keyword">for</span> copyright info</span><br><span class="line">==23775== Command: ls -l</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;Valgrind：用于内存调试、内存泄漏检测以及性能分析。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://doreality.xyz/categories/Development/"/>
    
    
    <category term="Linux" scheme="https://doreality.xyz/tags/Linux/"/>
    
    <category term="Valgrind" scheme="https://doreality.xyz/tags/Valgrind/"/>
    
  </entry>
  
  <entry>
    <title>Makefile 使用（一）</title>
    <link href="https://doreality.xyz/posts/5dc7c8b1.html"/>
    <id>https://doreality.xyz/posts/5dc7c8b1.html</id>
    <published>2022-05-11T17:26:13.000Z</published>
    <updated>2023-04-07T16:07:47.655Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些 Makefile 小 Tips。</p><ul><li>简单的规则格式</li><li>两个函数 <code>wildcard</code> 和 <code>patsubst</code></li><li>条件：<code>ifdef</code> / <code>ifeq</code>，<code>else</code> 和 <code>endif</code></li></ul><span id="more"></span><p>Linux 中，默认情况下，<code>make</code> 命令寻找顺序（当前目录）：</p><p><code>GNUmakefile</code> -&gt; <code>makefile</code> -&gt; <code>Makefile</code> -&gt; <code>Make.Linux</code>（自定义的，需要加 <code>-f</code>）</p><p><strong>推荐使用 <code>Makefile</code>。</strong></p><h2 id="基本的规则">基本的规则</h2><p>命令前面务必加上一个 <code>TAB</code>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">(target): (dependencies)</span></span><br><span class="line">(commands)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里是注释</span></span><br><span class="line"><span class="section">myapp: myapp.c</span></span><br><span class="line">gcc -Wall myapp.c -o myapp</span><br></pre></td></tr></table></figure><h2 id="两个函数">两个函数</h2><ul><li><code>wildcard</code>：表示通配符</li><li><code>padsubst</code>：Pattern Substring，字符串替换</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SRC: 当前目录下所有 .c 文件</span></span><br><span class="line">SRC = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"><span class="comment"># OBJ: 把 SRC 中所有的 .c 换成 .o</span></span><br><span class="line">OBJ = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(SRC)</span>)</span></span><br><span class="line"> </span><br><span class="line"><span class="section">ALL: hello</span></span><br><span class="line"></span><br><span class="line"><span class="section">hello: <span class="variable">$(OBJ)</span></span></span><br><span class="line">gcc <span class="variable">$(OBJ)</span> -o hello</span><br><span class="line"></span><br><span class="line"><span class="variable">$(OBJ)</span>: <span class="variable">$(SRC)</span> </span><br><span class="line">gcc -c <span class="variable">$(SRC)</span> -o <span class="variable">$(OBJ)</span></span><br></pre></td></tr></table></figure><h2 id="条件">条件</h2><ul><li><code>ifdef</code></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">VARIABLE = 1</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifdef</span> VARIABLE</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><ul><li><code>ifeq</code></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">VARIABLE_1 = 1</span><br><span class="line">VARIABLE_2 = 2</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(VARIABLE)</span>, <span class="variable">$(VARIABLE_2)</span>)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一些 Makefile 小 Tips。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单的规则格式&lt;/li&gt;
&lt;li&gt;两个函数 &lt;code&gt;wildcard&lt;/code&gt; 和 &lt;code&gt;patsubst&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;条件：&lt;code&gt;ifdef&lt;/code&gt; / &lt;code&gt;ifeq&lt;/code&gt;，&lt;code&gt;else&lt;/code&gt; 和 &lt;code&gt;endif&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Development" scheme="https://doreality.xyz/categories/Development/"/>
    
    
    <category term="Makefile" scheme="https://doreality.xyz/tags/Makefile/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 绘图：mermaid 和 flow graph</title>
    <link href="https://doreality.xyz/posts/20e330e7.html"/>
    <id>https://doreality.xyz/posts/20e330e7.html</id>
    <published>2022-04-10T03:35:30.000Z</published>
    <updated>2023-04-07T16:27:49.296Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown 流程图、框图、甘特图、各种图。</p><span id="more"></span><ul><li><p><code>mermaid</code>: <a href="https://www.jianshu.com/p/7864c1cf5660">Markdown语法之绘制流程图</a></p></li><li><p><code>flow</code>: <a href="https://www.jianshu.com/p/f28c94cf1204">MarkDown flow流程图示例</a></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;mermaid</span><br><span class="line">graph TD</span><br><span class="line">    start[开始] -.描述.-&gt; input[输入A,B,C]</span><br><span class="line">    input --描述--&gt; conditionA&#123;A是否大于B&#125;</span><br><span class="line">    conditionA -- YES --&gt; conditionC&#123;A是否大于C&#125;</span><br><span class="line">    conditionA -- NO --&gt; conditionB&#123;B是否大于C&#125;</span><br><span class="line">    conditionC -- YES --&gt; printA[输出A]</span><br><span class="line">    conditionC -- NO --&gt; printC[输出C]</span><br><span class="line">    conditionB -- YES --&gt; printB[输出B]</span><br><span class="line">    conditionB -- NO --&gt; printC[输出C]</span><br><span class="line">    printA &#x3D;&#x3D;&gt; stop[结束]</span><br><span class="line">    printC --&gt; stop</span><br><span class="line">    printB &#x3D;&#x3D; 描述 &#x3D;&#x3D;&gt; stop</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;flow</span><br><span class="line">start&#x3D;&gt;start: 开始</span><br><span class="line">input&#x3D;&gt;inputoutput: 输入</span><br><span class="line">operation&#x3D;&gt;operation: 操作</span><br><span class="line">condition&#x3D;&gt;condition: 操作出错？</span><br><span class="line">output&#x3D;&gt;inputoutput: 输出</span><br><span class="line">error&#x3D;&gt;operation: 请重新输入</span><br><span class="line">end&#x3D;&gt;end: 结束</span><br><span class="line"></span><br><span class="line">start-&gt;input</span><br><span class="line">input-&gt;operation</span><br><span class="line">operation-&gt;condition</span><br><span class="line">condition(no,bottom)-&gt;output</span><br><span class="line">condition(yes)-&gt;error(top)-&gt;input</span><br><span class="line">output-&gt;end</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Markdown 流程图、框图、甘特图、各种图。&lt;/p&gt;</summary>
    
    
    
    <category term="Tools" scheme="https://doreality.xyz/categories/Tools/"/>
    
    
    <category term="Markdown" scheme="https://doreality.xyz/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Cousera 视频快速加载</title>
    <link href="https://doreality.xyz/posts/c400d692.html"/>
    <id>https://doreality.xyz/posts/c400d692.html</id>
    <published>2022-03-12T09:39:08.000Z</published>
    <updated>2023-04-07T15:30:42.558Z</updated>
    
    <content type="html"><![CDATA[<p>学一些 Coursera 但是视频缓冲好慢。</p><span id="more"></span><h2 id="配置-DNS">配置 DNS</h2><ol><li>找到 <code>hosts</code>：<ul><li><code>C:\Windows\System32\drivers\etc</code> （Windows）</li><li><code>/etc/hosts</code> （macOS/Linux，Finder-「前往」-「前往文件夹」-<code>/private/etc</code>）</li></ul></li><li>添加如下内容：(不能直接添加就拷贝一份文件到外面，修改之后覆盖原来的）   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># coursera</span><br><span class="line">13.249.162.18 d3njjcbhbojbot.cloudfront.net # 网站</span><br><span class="line">18.65.219.131 d3c33hcgiwev3.cloudfront.net  # 视频</span><br></pre></td></tr></table></figure><ul><li>两个查询 DNS 的网站，可以找到想访问网址对应的各种 DNS 服务器的 IP：<ul><li><a href="https://ping.eu/nslookup/">https://ping.eu/nslookup/</a></li><li><a href="http://ping.chinaz.com/">http://ping.chinaz.com/</a></li></ul></li></ul></li><li>输入的如下网址得到相应的IP：<ul><li>网站：<code>d3njjcbhbojbot.cloudfront.net</code></li><li>视频：<code>d3c33hcgiwev3.cloudfront.net</code></li><li>可以尝试 ping 一下这些 IP，找到速度比较快的添加到 <code>hosts</code> 中即可。</li></ul></li><li>刷新 DNS，然后重新打开 Coursera即可<br>在命令行 or 终端里输入下面的命令：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Windows</span></span><br><span class="line"><span class="variable">$ipconfig</span> /flushdns</span><br><span class="line"><span class="comment"># macOS</span></span><br><span class="line"><span class="variable">$dscacheutil</span> -flushcache</span><br></pre></td></tr></table></figure></li><li>可以再 ping 一下网站和视频对应的链接，看一看 IP 是否成功。</li></ol><h2 id="参考">参考</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/144498122">Coursera视频打不开终极办法</a></li><li><a href="http://121.196.169.103/archives/coursera%E8%A7%86%E9%A2%91%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BE%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3">Cousera视频无法播放问题解决</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;学一些 Coursera 但是视频缓冲好慢。&lt;/p&gt;</summary>
    
    
    
    <category term="Tools" scheme="https://doreality.xyz/categories/Tools/"/>
    
    
    <category term="DNS" scheme="https://doreality.xyz/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>「SNDD」简单网络设备驱动程序</title>
    <link href="https://doreality.xyz/posts/c73d89f1.html"/>
    <id>https://doreality.xyz/posts/c73d89f1.html</id>
    <published>2022-01-19T10:42:09.000Z</published>
    <updated>2023-04-07T16:44:51.504Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文首发地址：<a href="https://bbs.csdn.net/topics/604346832">简单网络驱动（基于 Linux-4.15.x 版本内核）</a></p></blockquote><p>本文设计并实现了一个简单的网络设备驱动程序（基于 Linux-4.15.x 版本内核）—— A Simpler Network Device Driver（下文简称 <code>sndd</code>）。</p><ul><li><p>源码地址（仅供学习交流）：<a href="https://gitee.com/doreality/sndd">https://gitee.com/doreality/sndd</a></p></li><li><p>参考《Linux 设备驱动程序（第3版）》（以下简称“LDD3”）第 17 章“网络驱动程序”的<code>snull</code>模块实现</p></li><li><p>P.S. 下文所提到的“网络设备驱动程序”、“网络设备驱动”、“网络驱动程序”、“网络驱动”都指的是同一个概念。</p></li></ul><span id="more"></span><h2 id="前言">前言</h2><h3 id="几个概念理解">几个概念理解</h3><ol><li><p>为什么要选择 Linux ？</p><p>在源码公开和支持模块化这样优点的加成下，Linux 系统非常适合作为学习编写设备驱动程序的环境。</p></li><li><p>什么是设备驱动程序？</p><p>设备驱动程序，是应用程序和除了CPU、内存等硬件设备之外的几乎所有外设打交道的桥梁。应用程序使用OS提供的统一接口——系统调用，就像使用了一把万能钥匙，可以打开并访问各种不同外设，而并不用关心这些设备本身的样子。</p><p>例如块设备，应用程序说打开它，然后读写一些数据，那么直接使用<code>open</code>，<code>read</code>，<code>write</code>这些系统调用就好了，并不需要考虑数据是怎么在光盘或者磁盘上使用什么不同的介质存储、被组织排列成什么顺序。</p></li><li><p>有哪些设备驱动程序？</p><p>正因为有越来越多不同的设备出现，设备驱动也是种类繁杂，一般可以分为三类：字符设备驱动、块设备驱动和网络设备驱动。这样分类有利于模块化编程，但是，当然，对于复杂的设备，也可以把这些都综合为一个模块（以灵活性为代价）。</p><p>对于字符设备驱动和块设备驱动来说，Linux 系统都会在<code>/dev</code>目录下创建一个文件节点，把它们都抽象为一个文件，可以打开关闭、可以读写也可以进行配置。</p></li><li><p>但是网络设备驱动有所不同。</p><p>网络设备是要和外界互联的，网络驱动程序要异步地接收来自外界的数据包，然后向内核请求，把这些数据包发送给内核。这和块设备只响应内核的要求、只向固定缓冲区发送数据，是完全不同的。网络驱动没有必要留一个<code>/dev</code>下的节点，因为对它打开关闭也好、读写也罢，并没有实质的意义。网络驱动要做的就是，在收到数据包的时候，发送给内核；在内核要发送数据包的时候，它进行封装（自己的硬件头部）然后发送。</p></li></ol><h3 id="网络驱动在哪里">网络驱动在哪里</h3><p>如果说网络驱动是一把万能钥匙，那也是开大门的钥匙吧，那就是在内核了。这是在应用程序和驱动程序的角度来看。</p><p>如果说从网络的分层来看，网络驱动程序就是很底层了。LDD3 中提到，Linux 的网络子系统被设计为和协议完全无关。协议隐藏在驱动程序之后，而物理传输又被隐藏在协议之后。内核和网络驱动之间的交互，可能每次处理的是一个网络数据包。</p><p>但是同样值得指出的是，驱动接收的是外界发送的数据包，但是传输时要给上层传递下来的数据包封装一个 MAC 的头部信息。所以驱动会使用硬件协议，但是处理传输的是 IP 数据包。</p><p>（图源：百度百科——网络驱动程序接口规范）</p><h2 id="sndd-设计">sndd 设计</h2><p><code>sndd</code> 实现一个基于内存的网络驱动模块，模拟了网络接口和远程主机通信的过程。</p><p><code>sndd</code> 中使用的接口不依赖于任何硬件，是纯软件实现的数据包传输和发送。</p><p>在二层协议上选择以太网协议，处理传输的是 IP 数据包（对其他非 IP 数据包的修改会破坏原本数据包）。</p><p>由于使用以太网协议，在实际测试的时候可以使用 <code>tcpdump</code> 工具进行抓包验证数据包的传输。</p><h3 id="网络拓扑">网络拓扑</h3><p>驱动模拟了四个网络接口，接口名：<code>sndd0</code>，<code>sndd1</code>，<code>sndd2</code> 和 <code>sndd3</code></p><p>对应的主机名为 <code>lc0</code>，<code>lc1</code>，<code>lc2</code> 和 <code>lc3</code></p><p>四个接口位于四个不同的子网，网络名分别为 <code>snet0</code>，<code>snet1</code>，<code>snet2</code> 和 <code>snet3</code></p><p>在三个网段中，各自分别有一台主机，主机名：<code>rm0</code>，<code>rm1</code>，<code>rm2</code> 和 <code>rm3</code></p><p>网络结构如下图所示：</p><img src="/posts/c73d89f1/arch.png" class=""><p>驱动要实现的功能如下：</p><ul><li>从主机发送到 <code>rm0</code> 的数据包，要从 <code>sn3</code> 接收到</li><li>从主机发送到 <code>rm3</code> 的数据包，要从 <code>sn0</code> 接收到</li><li>从主机发送到 <code>rm1</code> 的数据包，要从 <code>sn2</code> 接收到</li><li>从主机发送到 <code>rm2</code> 的数据包，要从 <code>sn1</code> 接收到</li></ul><p>为了实现上述功能，给各接口和主机分配 IP 地址如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 网络号 &#x2F;etc&#x2F;networks</span><br><span class="line">snet0 192.168.4.0</span><br><span class="line">snet1 192.168.5.0</span><br><span class="line">snet2 192.168.6.0</span><br><span class="line">snet3 192.168.7.0</span><br><span class="line"></span><br><span class="line"># 主机号 &#x2F;etc&#x2F;hosts</span><br><span class="line">192.168.4.1 lc0  </span><br><span class="line">192.168.4.2 rm0</span><br><span class="line">192.168.5.2 lc1</span><br><span class="line">192.168.5.1 rm1</span><br><span class="line">192.168.6.1 lc2</span><br><span class="line">192.168.6.2 rm2</span><br><span class="line">192.168.7.2 lc3</span><br><span class="line">192.168.7.1 rm3</span><br></pre></td></tr></table></figure><p>同时，在终端里配置网络接口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ifconfig sndd0 lc0 netmask 255.255.255.0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ifconfig sndd1 lc1 netmask 255.255.255.0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ifconfig sndd2 lc2 netmask 255.255.255.0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ifconfig sndd3 lc3 netmask 255.255.255.0</span></span><br></pre></td></tr></table></figure><p>根据所设置的 IP 地址，为了实现功能，要在驱动中接收到数据包时，修改 IP 数据包的头部中的源 IP 地址和目的 IP 地址：</p><ul><li>把第 3 个 octet 依次修改（4-&gt;5，5-&gt;4，6-&gt;7，7-&gt;6）</li><li>把第 4 个 octet 修改（1-&gt;2，2-&gt;1）</li></ul><h3 id="模块结构">模块结构</h3><p>实现一个简单的模块，至少需要包含如下几个部分：</p><ol><li>模块注册和注销</li><li>模块初始化</li><li>模块的具体操作</li></ol><p>对于要实现的简单网络设备驱动，</p><p>包含的数据结构：</p><ol><li>接口数据结构 <code>struct net_device *</code></li><li>操作数据结构<ul><li><code>struct header_ops</code></li><li><code>struct net_device_ops</code></li></ul></li><li>自定义数据包 <code>struct sndd_packet</code></li><li>接口的私有信息 <code>struct sndd_priv</code></li></ol><p>包含操作：</p><ol><li>注册 <code>sndd_init_module()</code></li><li>注销 <code>sndd_cleanup()</code></li><li>初始化 <code>sndd_init()</code></li><li>打开 <code>sndd_open()</code></li><li>关闭 <code>sndd_release()</code></li><li>传输 / 接收<ul><li>传输 <code>sndd_tx()</code></li><li>接收 <code>sndd_rx()</code></li></ul></li><li>数据处理<ul><li>修改 header <code>sndd_header()</code></li><li>单个缓冲区<ul><li><code>sndd_get_tx_buffer()</code></li><li><code>sndd_release_buffer()</code></li></ul></li><li>缓冲池<ul><li>建立：<code>sndd_setup_pool()</code></li><li>回收：<code>sndd_teardown_pool()</code></li></ul></li><li>缓冲队列<ul><li><code>sndd_enqueue_buf()</code></li><li><code>sndd_dequeue_buf()</code></li></ul></li></ul></li><li>中断 <code>sndd_regular_interrupt()</code></li><li>统计 <code>net_device_stats *sndd_stats()</code></li><li>I / O 控制 <code>sndd_ioctl()</code></li></ol><p>使用一些简化：</p><ul><li>传输和接收采用中断机制，而不是轮询（NAPI）</li><li>不设置传输超时判断</li><li>硬件地址由软件模拟</li><li>不使用 ARP，采用软件模拟</li><li>不修改 MTU</li></ul><h2 id="sndd-实现">sndd 实现</h2><ol><li>模块的注册、注销和初始化</li></ol><p>首先是每个模块的注册和注销函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module_init(sndd_init_module);</span><br><span class="line">module_exit(sndd_cleanup);</span><br></pre></td></tr></table></figure><p>注册，完成的功能就是给每个接口申请内存（在这个步骤里要进行接口的初始化 <code>sndd_init</code>），最关键的就是使用注册函数<code>register_netdev(sndd_devs[i])</code>，把接口注册到内核中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Register the module</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sndd_init_module</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> result, i, ret = -ENOMEM;</span><br><span class="line"></span><br><span class="line">sndd_interrupt = sndd_regular_interrupt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Allocate the devices */</span></span><br><span class="line">sndd_devs[<span class="number">0</span>] = alloc_netdev(<span class="keyword">sizeof</span>(struct sndd_priv), <span class="string">&quot;sndd%d&quot;</span>,</span><br><span class="line">NET_NAME_UNKNOWN, sndd_init);</span><br><span class="line">sndd_devs[<span class="number">1</span>] = alloc_netdev(<span class="keyword">sizeof</span>(struct sndd_priv), <span class="string">&quot;sndd%d&quot;</span>,</span><br><span class="line">NET_NAME_UNKNOWN, sndd_init);</span><br><span class="line">sndd_devs[<span class="number">2</span>] = alloc_netdev(<span class="keyword">sizeof</span>(struct sndd_priv), <span class="string">&quot;sndd%d&quot;</span>,</span><br><span class="line">NET_NAME_UNKNOWN, sndd_init);</span><br><span class="line">sndd_devs[<span class="number">3</span>] = alloc_netdev(<span class="keyword">sizeof</span>(struct sndd_priv), <span class="string">&quot;sndd%d&quot;</span>,</span><br><span class="line">NET_NAME_UNKNOWN, sndd_init);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sndd_devs[<span class="number">0</span>] == <span class="literal">NULL</span> || sndd_devs[<span class="number">1</span>] == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">ret = -ENODEV;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>;  i++)</span><br><span class="line"><span class="keyword">if</span> ((result = register_netdev(sndd_devs[i])))</span><br><span class="line">printk(<span class="string">&quot;sndd: error %i registering device \&quot;%s\&quot;\n&quot;</span>,</span><br><span class="line">result, sndd_devs[i]-&gt;name);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line">   out:</span><br><span class="line"><span class="keyword">if</span> (ret) </span><br><span class="line">sndd_cleanup();</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注销，就是注册的倒序，先从内核中注销，然后清除内部的数据结构，最后释放接口。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Unregister the module</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sndd_cleanup</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>;  i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (sndd_devs[i]) &#123;</span><br><span class="line">unregister_netdev(sndd_devs[i]);</span><br><span class="line">sndd_teardown_pool(sndd_devs[i]);</span><br><span class="line">free_netdev(sndd_devs[i]); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The init function (sometimes called probe).</span></span><br><span class="line"><span class="comment"> * It is invoked by register_netdev()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sndd_init</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sndd_priv</span> *<span class="title">priv</span>;</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Then, assign other fields in dev, using ether_setup() and some</span></span><br><span class="line"><span class="comment"> * hand assignments</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ether_setup(dev); <span class="comment">/* assign some of the fields */</span></span><br><span class="line">dev-&gt;netdev_ops = &amp;sndd_netdev_ops;</span><br><span class="line">dev-&gt;header_ops = &amp;sndd_header_ops;</span><br><span class="line"><span class="comment">/* keep the default flags, just add NOARP */</span></span><br><span class="line">dev-&gt;flags           |= IFF_NOARP;</span><br><span class="line">dev-&gt;features        |= NETIF_F_HW_CSUM;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Then, initialize the priv field. This encloses the statistics</span></span><br><span class="line"><span class="comment"> * and a few private fields.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">priv = netdev_priv(dev);</span><br><span class="line"><span class="built_in">memset</span>(priv, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct sndd_priv));</span><br><span class="line"></span><br><span class="line">spin_lock_init(&amp;priv-&gt;lock);</span><br><span class="line">priv-&gt;dev = dev;</span><br><span class="line"></span><br><span class="line">sndd_rx_ints(dev, <span class="number">1</span>);<span class="comment">/* enable receive interrupts */</span></span><br><span class="line">sndd_setup_pool(dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>数据包的传输</li></ol><p>从上层接收到的数据包，要先封装硬件协议（这里是以太网协议）的头部，然后放入发送队列。</p><p>每一个数据包都包含在一个 <code>sk_buff</code> 结构中，就是一个 socket 缓冲区。</p><p>最后调用 <code>sndd_hw_tx</code> 实现网络驱动的具体操作，就是修改源和目的，实现一个回环功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Transmit a packet (called by the kernel)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sndd_tx</span><span class="params">(struct sk_buff *skb, struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">char</span> *data, shortpkt[ETH_ZLEN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sndd_priv</span> *<span class="title">priv</span> =</span> netdev_priv(dev);</span><br><span class="line"></span><br><span class="line">data = skb-&gt;data;</span><br><span class="line">len = skb-&gt;len;</span><br><span class="line"><span class="keyword">if</span> (len &lt; ETH_ZLEN) &#123;</span><br><span class="line"><span class="built_in">memset</span>(shortpkt, <span class="number">0</span>, ETH_ZLEN);</span><br><span class="line"><span class="built_in">memcpy</span>(shortpkt, skb-&gt;data, skb-&gt;len);</span><br><span class="line">len = ETH_ZLEN;</span><br><span class="line">data = shortpkt;</span><br><span class="line">&#125;</span><br><span class="line">netif_trans_update(dev);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Remember the skb, so we can free it at interrupt time */</span></span><br><span class="line">priv-&gt;skb = skb;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* actual deliver of data is device-specific, and not shown here */</span></span><br><span class="line">sndd_hw_tx(data, len, dev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* Our simple device can not fail */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>数据包的接收</li></ol><p>由于是使用中断驱动，当数据包异步到达的时候，中断程序调用 <code>sndd_rx</code> 将数据包和附加信息发送到上层。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Receive a packet: retrieve, encapsulate and pass over to upper levels</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sndd_rx</span><span class="params">(struct net_device *dev, struct sndd_packet *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sndd_priv</span> *<span class="title">priv</span> =</span> netdev_priv(dev);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The packet has been retrieved from the transmission</span></span><br><span class="line"><span class="comment"> * medium. Build an skb around it, so upper layers can handle it</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">skb = dev_alloc_skb(pkt-&gt;datalen + <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (!skb) &#123;</span><br><span class="line"><span class="keyword">if</span> (printk_ratelimit())</span><br><span class="line">printk(KERN_NOTICE <span class="string">&quot;sndd rx: low on mem - packet dropped\n&quot;</span>);</span><br><span class="line">priv-&gt;stats.rx_dropped++;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">skb_reserve(skb, <span class="number">2</span>); <span class="comment">/* align IP on 16B boundary */</span>  </span><br><span class="line"><span class="built_in">memcpy</span>(skb_put(skb, pkt-&gt;datalen), pkt-&gt;data, pkt-&gt;datalen);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Write metadata, and then pass to the receive level */</span></span><br><span class="line">skb-&gt;dev = dev;</span><br><span class="line">skb-&gt;protocol = eth_type_trans(skb, dev);</span><br><span class="line">skb-&gt;ip_summed = CHECKSUM_UNNECESSARY; <span class="comment">/* don&#x27;t check it */</span></span><br><span class="line">priv-&gt;stats.rx_packets++;</span><br><span class="line">priv-&gt;stats.rx_bytes += pkt-&gt;datalen;</span><br><span class="line">netif_rx(skb);</span><br><span class="line">  out:</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多具体的实现可见源代码并参考 LDD3 中的 <code>snull</code> 模块。</p><h2 id="sndd-测试">sndd 测试</h2><p>利用 <code>Makefile</code> 生产 <code>.ko</code> 加载到内核之后，使用 <code>ping</code> 和 <code>tcpdump</code> 可以测试本驱动。</p><h3 id="Makefile">Makefile</h3><p>和 LDD3 中所给示例基本是一样的。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Comment/uncomment the following line to disable/enable debugging</span></span><br><span class="line"><span class="comment">#DEBUG = y</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add your debugging flag (or not) to CFLAGS</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(DEBUG)</span>,y)</span><br><span class="line">  DEBFLAGS = -O -g -DSNULL_DEBUG <span class="comment"># &quot;-O&quot; is needed to expand inlines</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  DEBFLAGS = -O2</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">EXTRA_CFLAGS += <span class="variable">$(DEBFLAGS)</span></span><br><span class="line">EXTRA_CFLAGS += -I..</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line"><span class="comment"># call from kernel build system</span></span><br><span class="line">obj-m:= sndd.o</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">KERNELDIR ?= /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build</span><br><span class="line">PWD       := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">default:</span></span><br><span class="line"><span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions *.mod modules.order *.symvers</span><br><span class="line"></span><br><span class="line">depend .depend dep:</span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(EXTRA_CFLAGS)</span> -M *.c &gt; .depend</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (.depend,<span class="variable">$(<span class="built_in">wildcard</span> .depend)</span>)</span><br><span class="line"><span class="keyword">include</span> .depend</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><h3 id="模块测试">模块测试</h3><ol><li><p>编译并装载模块</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo insmod sndd.ko</span></span><br></pre></td></tr></table></figure> <img src="/posts/c73d89f1/image-20220119171132389.png" class=""><p>模块加载到内核之后，模拟的网络接口就出现了，使用 <code>ifconfig</code> 命令可以查看：</p> <img src="/posts/c73d89f1/image-20220119170213353.png" class=""></li><li><p>配置网络</p><p>如前所述，配置网络和主机号，同时绑定接口的 IP。</p> <img src="/posts/c73d89f1/image-20220119170534639.png" class=""> <img src="/posts/c73d89f1/image-20220119170606879.png" class=""> <img src="/posts/c73d89f1/image-20220119170733902.png" class=""></li><li><p>测试</p><p>测试效果如下图。</p> <img src="/posts/c73d89f1/image-20220119165929027.png" class=""><p>当发出<code>ping -c1 1 rm0</code>命令，发送目的地址为 <code>rm0</code> 的数据包请求时，按顺序发送了如下事件：</p><ol><li><p>在 <code>sndd0</code> 上观察到，从 <code>lc0 &gt; rm0</code> 发起了一次请求；</p></li><li><p>在 <code>sndd1</code> 上观察到，从 <code>rm1 &gt; lc1</code> 发起了一次请求；</p></li><li><p>在 <code>sndd1</code> 上观察到，从 <code>lc1 &gt; rm1</code> 发起了一次回应；</p></li><li><p>在 <code>sndd0</code> 上观察到，从 <code>rm0 &gt; lc0</code> 发起了一次回应。</p></li></ol><p>这个过程就实现了一个扩展的回环网络，从 <code>lc0</code> 到 <code>lc1</code>，然后从 <code>lc1</code> 再到 <code>lc0</code>，实现了一次双向的通信。</p><p>同理，使用 <code>ping</code> 访问 <code>rm1</code>，<code>rm2</code> 和 <code>rm3</code> 时，也实现了这样的过程。</p></li></ol><h2 id="小结">小结</h2><ol><li>模块化编程要注意，卸载模块的时候，一定要把申请的所有内存都释放，否则会影响内核下一次启动；</li><li>网络驱动比起字符驱动和块设备驱动，会更抽象一点，实际的使用需要结合具体的网络设备来编写；</li><li>配置测试接口的 IP 时，要多测试一下，如果突然不好用了重新使用 <code>ifconfig</code> 配置一下；</li><li>在实际网络中使用的时候，必须要有传输超时和并发控制（这里没有给出，但是 LDD3 中都有涉及）；</li><li>除了中断的方式处理数据接收和发送，还可以使用轮询（NAPI）的方式，常用于流量非常大的高速接口（如宽带接口）；</li><li>网络驱动其实并不关注协议内容，也不关注头部和数据的划分，但是，需要比较了解协议的结构，才能在传输和发送时更好处理。</li></ol><h2 id="参考">参考</h2><ul><li><p>LDD3 的 <code>snull</code> 示例参考代码（基于新版内核修改）：<a href="https://github.com/martinezjavier/ldd3">https://github.com/martinezjavier/ldd3</a></p></li><li><p><code>snull</code> 在新版内核上编译不通过问题：<a href="https://blog.csdn.net/wh8_2011/article/details/50374935">Linux设备驱动程序(LDD)中snull的编译问题</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文首发地址：&lt;a href=&quot;https://bbs.csdn.net/topics/604346832&quot;&gt;简单网络驱动（基于 Linux-4.15.x 版本内核）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文设计并实现了一个简单的网络设备驱动程序（基于 Linux-4.15.x 版本内核）—— A Simpler Network Device Driver（下文简称 &lt;code&gt;sndd&lt;/code&gt;）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;源码地址（仅供学习交流）：&lt;a href=&quot;https://gitee.com/doreality/sndd&quot;&gt;https://gitee.com/doreality/sndd&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参考《Linux 设备驱动程序（第3版）》（以下简称“LDD3”）第 17 章“网络驱动程序”的&lt;code&gt;snull&lt;/code&gt;模块实现&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;P.S. 下文所提到的“网络设备驱动程序”、“网络设备驱动”、“网络驱动程序”、“网络驱动”都指的是同一个概念。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Projects" scheme="https://doreality.xyz/categories/Projects/"/>
    
    
    <category term="Linux" scheme="https://doreality.xyz/tags/Linux/"/>
    
    <category term="Device Driver" scheme="https://doreality.xyz/tags/Device-Driver/"/>
    
  </entry>
  
  <entry>
    <title>Jupyter Notebook 基础使用</title>
    <link href="https://doreality.xyz/posts/4342490b.html"/>
    <id>https://doreality.xyz/posts/4342490b.html</id>
    <published>2022-01-05T04:49:40.000Z</published>
    <updated>2023-04-07T16:21:33.141Z</updated>
    
    <content type="html"><![CDATA[<p>Jupyter Notebook 安装与使用。</p><span id="more"></span><ol><li><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pip3 install ipython</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pip3 install <span class="string">&quot;ipython[notebook]&quot;</span></span></span><br></pre></td></tr></table></figure></li><li><p>启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ipython notebook</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;Jupyter Notebook 安装与使用。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://doreality.xyz/categories/Development/"/>
    
    
    <category term="Python" scheme="https://doreality.xyz/tags/Python/"/>
    
    <category term="Jupyter Notebook" scheme="https://doreality.xyz/tags/Jupyter-Notebook/"/>
    
  </entry>
  
  <entry>
    <title>终端运行 .sh 文件报错：zsh operation not permitted</title>
    <link href="https://doreality.xyz/posts/46c2dc33.html"/>
    <id>https://doreality.xyz/posts/46c2dc33.html</id>
    <published>2022-01-04T16:38:47.000Z</published>
    <updated>2023-04-07T16:06:30.406Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.jianshu.com/p/924c42418a11">M1 芯片运行.sh文件报zsh: operation not permitted</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/924c42418a11&quot;&gt;M1 芯片运行.sh文件报zsh: operation not permitted&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</summary>
      
    
    
    
    <category term="Q&amp;A" scheme="https://doreality.xyz/categories/Q-A/"/>
    
    
    <category term="macOS" scheme="https://doreality.xyz/tags/macOS/"/>
    
    <category term="zsh" scheme="https://doreality.xyz/tags/zsh/"/>
    
  </entry>
  
  <entry>
    <title>使用自定义端口号打开 Flask App</title>
    <link href="https://doreality.xyz/posts/6590c97f.html"/>
    <id>https://doreality.xyz/posts/6590c97f.html</id>
    <published>2022-01-02T16:33:02.000Z</published>
    <updated>2023-04-07T16:37:21.387Z</updated>
    
    <content type="html"><![CDATA[<p>Flask 默认启动端口号是 <code>5000</code>，如果被占用，就会报错，启动失败。</p><p>这时就需要自定义使用其他的端口号。</p><span id="more"></span><ol><li><p>打开时指定</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> env FLASK_APP=app.py flask run -p 5030</span></span><br></pre></td></tr></table></figure></li><li><p>在代码中指定</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">5030</span>)</span><br></pre></td></tr></table></figure><p>但是在这种情况下，执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> env FLASK_APP=app.py flask run</span></span><br></pre></td></tr></table></figure><p>仍是从 <code>5000</code> 端口打开。</p><p>此时应该直接执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python3.9 app.py</span></span><br></pre></td></tr></table></figure><p>就是按照代码指定的端口打开了，访问 <code>localhost:5030</code> 即可。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;Flask 默认启动端口号是 &lt;code&gt;5000&lt;/code&gt;，如果被占用，就会报错，启动失败。&lt;/p&gt;
&lt;p&gt;这时就需要自定义使用其他的端口号。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://doreality.xyz/categories/Development/"/>
    
    
    <category term="Flask" scheme="https://doreality.xyz/tags/Flask/"/>
    
  </entry>
  
</feed>
