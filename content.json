{"meta":{"title":"DoReality","subtitle":"","description":"","author":"doreality","url":"https://doreality.xyz","root":"/"},"pages":[{"title":"","date":"2023-04-07T15:27:38.818Z","updated":"2023-04-07T15:27:38.807Z","comments":false,"path":"tags/index.html","permalink":"https://doreality.xyz/tags/index.html","excerpt":"","text":""},{"title":"","date":"2023-04-07T15:27:58.531Z","updated":"2023-04-07T15:27:58.521Z","comments":true,"path":"categories/index.html","permalink":"https://doreality.xyz/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-03-09T10:12:58.000Z","updated":"2023-04-07T15:49:15.247Z","comments":true,"path":"about/index.html","permalink":"https://doreality.xyz/about/index.html","excerpt":"","text":"Work hard in silence, let your success be your noise. Done is better than perfect. DoReality’s Blog DoReality’s GitHub DoReality’s Gitee"}],"posts":[{"title":"使用 GitHub Actions 自动添加 TOC 到 README","slug":"tools/add-toc-to-readme-with-github-actions","date":"2023-04-02T15:14:35.000Z","updated":"2023-04-07T16:43:26.053Z","comments":true,"path":"posts/9bb3bd63.html","link":"","permalink":"https://doreality.xyz/posts/9bb3bd63.html","excerpt":"在 git push 时，给 main 分支下的 README.md 自动生成目录！","text":"在 git push 时，给 main 分支下的 README.md 自动生成目录！ 找到 Repo 的 「Settings」-「Actions」-「General」-「Workflow permissions」，修改为 Read and write permissions 在 Repo 的 「Actions」中，新建 workflow 选择 「set up a workflow yourself」 配置，可以命名为 toc.yml： 1234567891011121314151617181920212223 on: push: branches: [main] paths: [&#x27;README.md&#x27;] pull_request: branches: [main] paths: [&#x27;README.md&#x27;]jobs: build: runs-on: ubuntu-latest timeout-minutes: 5 steps: - uses: actions/checkout@v2 - run: | curl https://raw.githubusercontent.com/ekalinin/github-markdown-toc/master/gh-md-toc -o gh-md-toc chmod a+x gh-md-toc ./gh-md-toc --insert --no-backup README.md rm -f ./gh-md-toc - uses: stefanzweifel/git-auto-commit-action@v4 with: commit_message: Auto update markdown TOC Commit 后，目录中生成 .github/workflow/toc.yml。 之后再 push 的时候，就会自动调用 workflow 在 README.md 生成目录了。 注意：一定要把「Settings」里的读写打开，否则会生成失败。","categories":[{"name":"Tools","slug":"Tools","permalink":"https://doreality.xyz/categories/Tools/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://doreality.xyz/tags/GitHub/"}]},{"title":"JavaScript 基础篇","slug":"dev/frontend/js/mosh-js-basics","date":"2023-04-02T09:39:14.000Z","updated":"2023-04-07T16:35:43.319Z","comments":true,"path":"posts/318faa67.html","link":"","permalink":"https://doreality.xyz/posts/318faa67.html","excerpt":"原版课程请访问：Code With Mosh B 站中文字幕版：JavaScript 基础篇 - Mosh Operators &amp; Flow Control &amp; Object &amp; Arrays &amp; Function","text":"原版课程请访问：Code With Mosh B 站中文字幕版：JavaScript 基础篇 - Mosh Operators &amp; Flow Control &amp; Object &amp; Arrays &amp; Function Operators == 和 === == 不严格等价，如果两边类型不同，会把右边的操作数自动转换为左边的类型，再判断值是否相等； === 严格等价，值和类型 Value 和 Type 都要相同才真。平时主要用三个等号。 非布尔值进行逻辑运算 false || 1的结果是 1； JS 中存在 Falsy 类假（false）的值： undefined null 0 false '' (empty string) NaN (Not a Number) 其他所有不是 Falsy 的值都是 Truthy。 || 短路原则 false || 1 || 2 的结果是 1 1234let userColor = undefined;let defaultColor = &#x27;blue&#x27;;// 如果用户没有选择颜色，那么就使用默认颜色。let currentColor = userColor || defaultColor; Bitwise: | &amp; 1234567let readPermission = 4; // 00000100let writePermission = 2; // 00000010let executePermission = 1; // 00000001let myPermission = readPermission | writePermission | executePermission; // 给用户权限let message = (myPermission &amp; readPermission) ? &#x27;yes&#x27; : &#x27;no&#x27;; // 三元表达式：判断用户是否具有某权限 注意事项 变量命名要有意义； 函数单一性功能； 密切相关的代码放在一起，和别的空行。 Flow Control switch if-else 替代 switch（过时） do-while do-while 的函数体至少会执行一次 for…in：对象遍历 123for (let key in obj) &#123; console.log(key, obj[key]);&#125; for…of：数组遍历 123for (let value of arr) &#123; console.log(value);&#125; Object 工厂函数和构造函数 （效果一样，随便用哪个） Factory Function 1234567891011121314// Factory Functionfunction createCircle(radius) &#123; // Camel Notation // return an object return &#123; radius, // use parameter as value draw() &#123; // no need &#x27;function&#x27; keyword console.log(&#x27;draw&#x27;); &#125; &#125;;&#125;const circle1 = createCircle(1);console.log(circle1); Constructor Function 12345678910111213// Constructor Functionfunction Circle(radius) &#123; // Pascal Notation this.radius = radius; this.draw = function() &#123; console.log(&#x27;draw&#x27;); &#125;&#125;// 1. create an empty js object &#123;&#125;, // 2. &#x27;this&#x27; reference to &#123;&#125;// 3. &#x27;this&#x27; creates propeties to obj// &#123;&#125;.radius = radius, &#123;&#125;.draw = ..const circle1 = new Circle(1); const 对象 const obj = new someObj();： 不能 re-assign 可以 动态 增删属性和方法。 1delete obj.property; 对象的构造器 obj.constructor 使用构造函数创建的对象，构造器就是构造函数本身 使用工厂函数创建的对象，构造器是 JavaScript 内置的构造函数 Object()，因为工厂函数使用了 &#123;&#125; （object literal syntax），它在内部就是调用了 Object() 以下的构造对象的方法是等价的： new String() === ' ', &quot; &quot;, ` ` new Boolean()=== true, false new Number() === 1, 2, ... 函数是对象（万物是对象） new Function(parameters, statements) 123456const Circle1 = new Function(&#x27;radius&#x27;,`this.radius = radius;this.draw = function() &#123; console.log(&#x27;draw&#x27;);&#125;`); const circle1 = &#123;&#125;; Circle.call(circle1, 1); === const circle1 = new Circle(1); Circle.call(thisArg, ArgList); 如果不使用 new，this 指向 window Value Type and Reference Type 值拷贝类型 Primitive: Number String Boolean Symbol undefined null 引用（地址）拷贝类型 Object: Object Function Array const 声明的变量： 如果是值拷贝，则不能修改赋值； 如果是引用拷贝，则可以修改对象的属性内容，但不能 re-assign 另一个对象，因为会修改地址。 对象不是可枚举 not iterable，不能直接直接用for..of 遍历： 1234567for (let key in obj)&#123;&#125;;for (let key of Object.keys(obj))&#123;&#125;// each entry is [key, value]for (let entriy of Object.entries(obj))&#123;&#125;; // key if in this objectif (key in object) return true; 对象拷贝 怎么把值拷贝过去？ 遍历拷贝 const newObj = Object.assign(&#123;&#125;, oldObj); separate operator ... ：const another = &#123; ...circle &#125;; JS 的 GC Garbage Collector 垃圾回收是自动进行的。 String Literal 和 Template Literal 123456const message = &#x27; hi there. &#x27;;const s = new String(&#x27;hello then&#x27;);message.trim();message.trimLeft();message.trimRight();message.split(&#x27; &#x27;); Date 123456789const now = new Date();const date1 = new Date(&#x27;May 11 2022 09:00&#x27;);const date2 = new Date(2022, 4, 11, 9);// month from 0 to 11now.getxx();now.setFullYear(2017);now.toDateString();now.toTimeString();now.toISOString(); 用对象的眼光观察 设想，如果是你来设计某个事物，构成一个对象，会需要什么属性和方法。 Arrays 增加 Adding 12345678910let a = [];// Enda.push(&#x27;a&#x27;, &#x27;b&#x27;); // [&#x27;a&#x27;, &#x27;b&#x27;]// Beginninga.unshift(1, 2); // [1, 2, &#x27;a&#x27;, &#x27;b&#x27;]// Mida.splice(2, 0, 3, 4); // [1, 2, 3, 4, &#x27;a&#x27;, &#x27;b&#x27;]// 2 means start index is 2// 0 means delete 0 element// index &gt;= length，则在末尾添加新元素 查找 Finding Primitive 12345678910111213let a = [1, 2, 3, 4, 1];// find firsta.indexOf(1); // 0a.indexOf(&#x27;a&#x27;); // -1a.indexOf(1, 2); // 4 (from index 2 to find)// find lasta.lastIndexOf(1); // 4// exist or notif(a.indexOf(1) !== -1) &#123;&#125;if(a.includes(1))&#123;&#125; Reference 1234567891011121314151617const courses = [ &#123;id: 1, name: &#x27;a&#x27;&#125;, &#123;id: 2, name: &#x27;b&#x27;&#125;];// find first matched element//const course = courses.find(function(course)&#123;// return course.name === &#x27;a&#x27;;//&#125;)// use arrow functionconst course = courses.find(course =&gt; course.name === &#x27;a&#x27;);// find(predicate or callback function)// findIndex()// 当返回值为 true，返回结果；// 当返回值为 false，继续在数组中向后查找。 删除 Removing 1234567891011121314const numbers = [1, 2, 3, 4];// Endconst last = numbers.pop(); // last === 4, // numbers [1, 2, 3]// Beginningconst first = numbers.shift();// Middlenumbers.splice(1, 2);// from index 1, delete 2 elements// return elements that be removed 清空 Emptying 123456789101112131415let numbers = [1, 2, 3, 4];let another = numbers;// Sol 1 单一引用时numbers = []; // 但是 another 还指向那块内存空间// Sol 2 多个引用时numbers.length = 0;// Sol 3numbers.splice(0, numbers.length);// Sol 4 不推荐while (numbers.length &gt; 0) numbers.pop(); 合并拆分 Combining and Slicing 1234567891011const first = [1, 2, 3];const second = [4, 5, 6];// combine [1, 2, 3, 4, 5, 6]const combined = first.concat(second);// sconst slice = combined.slice(1); // from index 1 to end// combined.slice(1, 2): from index 1 copy 2 elem// combined.slice(): copy all 如果拷贝了引用类型，那么拷贝的是它的引用 12345678const a = [&#123;id : 1&#125;];const b = [2, 3, 4];const combined = a.concat(b);// [&#123;id: 1&#125;, 2, 3, 4]a[0].id = 10;// [&#123;id: 10&#125;, 2, 3, 4]// slice 同理，也是拷贝的引用 Spread Operator ... 拆分数组，把每个元素单独返回。 12345678const first = [1, 2, 3];const second = [4, 5, 6];const combined = [...first, &#x27;a&#x27;, ...second, &#x27;b&#x27;];const copy = [...combined];let [a, b, c] = [...first];// a === 1, b === 2, c === 3 遍历 Iterating 123456789const numbers = [1, 2, 3];// for of / for infor (let number of numbers) console.log(number);// forEachnumbers.forEach((number, index) =&gt; console.log(index, number)); 连接 Joining Arrays 12345678910const numbers = [1, 2, 3]// join const joined = numbers.join(&#x27;,&#x27;); // 1,2,3// numbers.join() === &#x27;1,2,3&#x27; 默认用逗号// change space&#x27; &#x27; to hyphen&#x27;-&#x27; in urlconst message = &quot;This is my first message&quot;;const parts = message.split(&#x27; &#x27;); // word arrayconst combined = parts.join(&#x27;-&#x27;); // a string 排序 Sorting 原地修改，不返回新的数组。 不指定回调函数，会按照元素转换为字符串的 Unicode 顺序 ASC numbers.sort() DESC numbers.reverse() Reference 123456789101112131415161718const courses = [&#123;id: 1, name: &#x27;Node.js&#x27;&#125;,&#123;id: 2, name: &#x27;javascript&#x27;&#125;];// 按升序courses.sort(function(a, b) &#123;// a &lt; b =&gt; -1 负数表示 a 前 b 后// a &gt; b =&gt; 1 正数表示 a 后 b 前// a === b =&gt; 0 0 表示不交换顺序// 消除大小写敏感const nameA = a.name.toUpperCase();const nameB = b.name.toUpperCase();if (nameA &lt; nameB) return -1;if (nameA &gt; nameB) return 1;return 0;&#125;); 简单的排序： 12345// a - b &lt; 0 不交换// a - b &gt; 0 交换// a - b === 0 不动// 从小到大arr.sort((a, b) =&gt; a.value - b.value); 测试 Testing Elements 新特性，旧浏览器可能不兼容。 12345678910// 依次搜索每个元素，如果出现了负数就直接返回 false，不向后继续测试const allPositive = numbers.every(function(value)&#123; return value &gt;= 0;&#125;);// 只要出现了符合条件的一个，就返回const atLeastOnePositive = numbers.some(function(value)&#123; return value &gt;= 0;&#125;); 筛选 Filtering 12345const numbers = [1, 2, -1, -3];const filtered = numbers.filter(n =&gt; n &gt;= 0);// [1, 2]// 返回符合条件的元素组合成的数组// 还可以传index等参数 同样可以筛选符合条件的对象。 映射 Mapping 把每个元素映射为其他的东西。 映射成字符串： 12const items = filtered.map(n =&gt; &#x27;&lt;li&gt;&#x27; + n + &#x27;&lt;\\n&gt;&#x27;);const html = &#x27;&lt;ul&gt;&#x27; + items.join(&#x27;&#x27;) + &#x27;&lt;\\ul&gt;&#x27;; 映射成对象： 123// obj 的 &#123;&#125; 会被默认识别为函数体的&#123;&#125;// 所以如果直接返回对象的话，要加一层 ()const items = filtered.map(n =&gt; (&#123;value: n&#125;)); Chaining methods： 链式调用 123456// 依次对前面生成的数组进行处理const items = numbers .filter(n =&gt; n &gt;= 0) .map(n =&gt; (&#123; value: n &#125;)) .filter(obj =&gt; obj.value &gt; 1) .map(obj =&gt; obj.value); 缩减 Reducing 把整个数组缩减成一个单一的值：数字、字符串、对象…… 12345678910111213const numbers = [1, 2, -3, 4];const sum = numbers.reduce( (accumulator, currentValue) =&gt; accumulator + currentValue);// a = 1, c = 2 =&gt; a = 3// a = 3, c = -3 =&gt; a = 0// a = 0, c = 4 =&gt; a = 4// sum = 4// 默认时 a 是第一个元素，c 是第二个元素// 给 reduce() 传入第二个参数初始化 a，但是会多一次运算 Function Hoisting Function declaration will be moved to the top of the file by JavaScript engine when executing. But function expression will not. 函数声明 12345walk();// funtion declarationfunction walk() &#123; console.log(&#x27;walk&#x27;);&#125; 函数表达式 1234567891011// Uncaught ReferenceError:// Cannot access &#x27;run&#x27; before initialization// run();// named / anonymous function expressionconst run = function() &#123; console.log(&#x27;run&#x27;);&#125;;let move = run; // reference to the same afrun();move(); arguments 每个函数内，有一个内置的对象：arguments，因为有迭代器 Symbol.iterator，所以可以使用 for...of 遍历： 1234567function sum() &#123; let total = 0; for (let value of arguments) total += value; return total;&#125;console.log(sum(1, 2, 3, 4)); Rest Parameter ... Rest Operator 和 Spread Operator 区分： let [a, b, c] = [...numbers] 是把 numbers 数组的每个元素单独拿出来 function fn(a, b, ...args) 是将多余的parameters 放到一个数组 args 里 12345function sum(...args) &#123; return args.reduce((a, b) =&gt; a + b);&#125;console.log(sum(1, 2, 3, 4, 5, 6, 7)); 使用 Rest Operator 的参数叫做 Rest Parameter，必须是参数列表的最后一个参数。 Default Parameter 函数的参数列表中，有默认值的参数，在调用函数时，可以不显式赋值。 最佳实践是把有默认值的参数都放在最后，这样调用传参时不用 undefined 占位跳过（很丑） Getters &amp; Setters 12345678910111213141516const person = &#123; firstName: &#x27;Mosh&#x27;, lastName: &#x27;Hamedani&#x27;, get fullName() &#123; return `$&#123;this.firstName&#125; $&#123;this.lastName&#125;`; &#125;, set fullName(value) &#123; const parts = value.split(&#x27; &#x27;); this.firstName = parts[0]; this.lastName = parts[1]; &#125;&#125;;// setter =&gt; change(mutate) propertiesperson.fullName = &#x27;John Smith&#x27;;// getter =&gt; access propertiesconsole.log(person.fullName); try &amp; catch 1234567try &#123; // some codes, then throw new Error(&#x27;An error.&#x27;)&#125; catch(e) &#123; // deal with the error // or give some feedback to user&#125; Scope (Local vs Global) 12345678const color = &#x27;red&#x27;; // globalfunction start() &#123; const color = &#x27;blue&#x27;; // local if (true) &#123; console.log(color); // blue &#125;&#125; 局部变量会覆盖掉同名的全局变量。 全局变量可以在任意地方访问，所以要避免声明和使用全局变量，因为可能在某个位置就把需要的值改变了。 Let vs Var 在函数内部，作用域范围： var 声明的变量是 function-scoped，在函数内部任意位置都能访问 ES6（ES2015）开始使用 let 和 const 声明变量是 block-scoped，在代码块（for 循环 或者 if 语句）之外都无法访问，但是在内部的代码块中可以访问。 全局作用域： var 声明的全局变量，会添加到 window 对象的属性中，而 window 对象是唯一的，可能会覆盖其本身的同名属性。所以应该避免给 window 对象添加成员。 let 不会添加到全局对象。 在 Global 作用域定义的函数，也会添加到 window对象的成员，也应该避免（使用 module）。 另外，var 声明的变量，可以重复声明。 ‘this’ The this keyword references “the object that is executing the current function”. this in: method -&gt; obj function -&gt; global (window in browser, global in node) 1234567891011const video = &#123; title: &#x27;a&#x27;, tags: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], showTags() &#123; this.tags.forEach((tag)=&gt;&#123; console.log(this.title, tag); &#125;, this); &#125;&#125;;video.showTags(); forEach 的第一个参数是一个回调函数 callbackfn，执行回调函数的是 window 对象，而不是 video 对象，所以这个回调函数不是 method，回调函数中使用的 this 就是 window 增加第二个参数 thisArg 传入一个对象，那么回调函数中 this 指代的就是传入的对象。 但是，并不是所有函数都可以传入 thisArg。 Change ‘this’ 中继变量 self bind 方法 箭头函数，继承 this （不好的办法）在 this 被修改之前，给一个别名 const self = this 123456showTags() &#123; const self = this; this.tags.forEach(function(tag) &#123; console.log(self.title, tag); &#125;);&#125; 函数对象的内置方法：call, apply, bind 123456789function playVideo(a, b) &#123; console.log(this);&#125;playVideo.call(&#123; name:&#x27;apple&#x27; &#125;, 1, 2);playVideo.apply(&#123; name:&#x27;apple&#x27; &#125;, [1, 2]);playVideo.bind(&#123; name:&#x27;apple&#x27; &#125;, [1, 2])();playVideo(); // window call() 把第一个参数绑定 this，单独传入参数，调用； apply() 把第一个参数绑定 this，用数组方式传入参数，调用； bind() 把第一个参数绑定 this，不调用。 （旧办法）bind 匿名函数 12345showTags() &#123; this.tags.forEach(function(tag) &#123; console.log(this.title, tag); &#125;.bind(this));&#125; （ES6 新办法）箭头函数会继承容器函数的 this： 12345showTags() &#123; this.tags.forEach(tag =&gt; &#123; console.log(this.title, tag); &#125;);&#125;","categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doreality.xyz/tags/JavaScript/"}]},{"title":"终端命令提示符 prompt 样式定制","slug":"tools/macOS/oh-my-zsh-prompt","date":"2022-07-15T02:40:15.000Z","updated":"2023-04-07T16:07:20.037Z","comments":true,"path":"posts/47012712.html","link":"","permalink":"https://doreality.xyz/posts/47012712.html","excerpt":"终端的命令提示符样式定制：macOS / Linux","text":"终端的命令提示符样式定制：macOS / Linux 如果使用的是 oh-my-zsh，不同的主题就可以对应不同的命令提示符配置，但是要个性化配置可以参考如下： oh-my-zsh修改主题添加全路径显示 Linux 终端命令提示符总结","categories":[{"name":"Tools","slug":"Tools","permalink":"https://doreality.xyz/categories/Tools/"}],"tags":[{"name":"oh-my-zsh","slug":"oh-my-zsh","permalink":"https://doreality.xyz/tags/oh-my-zsh/"}]},{"title":"macOS 修改主机名等","slug":"tools/macOS/mac-hostname-and-other-names","date":"2022-07-15T02:37:48.000Z","updated":"2022-07-15T03:01:00.058Z","comments":true,"path":"posts/66790ec6.html","link":"","permalink":"https://doreality.xyz/posts/66790ec6.html","excerpt":"修改终端上显示的主机名。","text":"修改终端上显示的主机名。 Mac 修改主机名、计算机名、本地主机名、xcode作者名、终端前缀","categories":[{"name":"Tools","slug":"Tools","permalink":"https://doreality.xyz/categories/Tools/"}],"tags":[{"name":"macOS","slug":"macOS","permalink":"https://doreality.xyz/tags/macOS/"}]},{"title":"在终端中进入 Python 的 venv","slug":"dev/backend/python/go-into-venv-in-shell","date":"2022-06-24T14:38:56.000Z","updated":"2023-04-07T16:26:27.910Z","comments":true,"path":"posts/4f8c09df.html","link":"","permalink":"https://doreality.xyz/posts/4f8c09df.html","excerpt":"怎么从终端进入一个 Python 的虚拟环境 venv？","text":"怎么从终端进入一个 Python 的虚拟环境 venv？ 进入 1$source &quot;the venv root path&quot;/bin/activate","categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://doreality.xyz/tags/Python/"}]},{"title":"mac 如何彻底删除 Python","slug":"dev/backend/python/delete-python-on-mac","date":"2022-06-23T08:29:36.000Z","updated":"2023-04-07T16:12:27.062Z","comments":true,"path":"posts/4594a661.html","link":"","permalink":"https://doreality.xyz/posts/4594a661.html","excerpt":"完全删除 mac 中的不同版本的 Python","text":"完全删除 mac 中的不同版本的 Python Mac 删除/卸载 自己安装的python","categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://doreality.xyz/tags/Python/"}]},{"title":"使用 Homebrew 安装出现 git 报错","slug":"Q&A/brew-installation-error","date":"2022-06-20T03:12:38.000Z","updated":"2023-04-07T16:26:58.611Z","comments":true,"path":"posts/74a7d1c5.html","link":"","permalink":"https://doreality.xyz/posts/74a7d1c5.html","excerpt":"使用 Homebrew 安装的时候出现 git 的报错。","text":"使用 Homebrew 安装的时候出现 git 的报错。 问题如下： 根据提示，添加两条 git config 即可：","categories":[{"name":"Q&A","slug":"Q-A","permalink":"https://doreality.xyz/categories/Q-A/"}],"tags":[{"name":"Homebrew","slug":"Homebrew","permalink":"https://doreality.xyz/tags/Homebrew/"}]},{"title":"使用 Pyenv 管理 Python","slug":"dev/backend/python/manage-py-by-pyenv","date":"2022-06-20T03:10:51.000Z","updated":"2023-04-07T16:37:13.576Z","comments":true,"path":"posts/e30c74da.html","link":"","permalink":"https://doreality.xyz/posts/e30c74da.html","excerpt":"管理电脑上不同版本的 Python： 参考：https://github.com/pyenv/pyenv 环境：macOS + Homebrew + Zsh","text":"管理电脑上不同版本的 Python： 参考：https://github.com/pyenv/pyenv 环境：macOS + Homebrew + Zsh 安装 Pyenv 12$brew update$brew install pyenv 如果 brew 出现了 git 的报错：解决 Homebrew 出现 git 报错 设置 Shell 添加 $PYENV_ROOT 到 $PATH 添加 pyenv 为 shell 命令 安装 pyenv 到 shell function 123$echo &#x27;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&#x27; &gt;&gt; ~/.zshrc$echo &#x27;command -v pyenv &gt;/dev/null || export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#x27; &gt;&gt; ~/.zshrc$echo &#x27;eval &quot;$(pyenv init -)&quot;&#x27; &gt;&gt; ~/.zshrc 设置完毕，重启 shell 安装指定版本的 Python 首先安装依赖： 1$brew install openssl readline sqlite3 xz zlib tcl-tk 安装 Python 例如安装 Python 3.6.10： 1$pyenv install 3.6.10 然后经过漫长的等待，出现下列语句表示安装成功： 1Installed Python-3.6.15 to /Users/doreality/.pyenv/versions/3.6.15 使用 Pyenv 1234$pyenv versions # 查看已安装的版本$pyenv global 3.6.15 # 指定全局模式下的 Python 版本为 3.6.15$pyenv local 3.10.10 # 指定当前目录下的 Python 版本为 3.10.10$pyenv uninstall 3.6.15 # 删除 3.6.15 版本 Pyenv virtualenv 123$pyenv virtualenv 3.6.15 venv3615 # 创建一个虚拟环境$pyenv activate venv3615 # 进入该虚拟环境$pyevn deactivate venv3615 # 退出","categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://doreality.xyz/tags/Python/"}]},{"title":"「LCTHW」函数与指针篇（EX 14-18）","slug":"dev/backend/c/lcthw/lcthw-ex14-18","date":"2022-06-01T14:59:03.000Z","updated":"2023-04-07T16:30:46.814Z","comments":true,"path":"posts/4b675d3.html","link":"","permalink":"https://doreality.xyz/posts/4b675d3.html","excerpt":"Learn C The Hard Way, notes for ex14 to ex18.","text":"Learn C The Hard Way, notes for ex14 to ex18. Exercise 14. Writing and Using Functions 用 for 读一个字符串：不用判断长度，可以判断 \\0 123for (i = 0; arg[i] != &#x27;\\0&#x27;; i++) &#123; char ch = arg[i];&#125; ctype.h funtion meaning isalnum() checks for an alphanumeric character; it is equivalent to (isalpha© || isdigit©). isalpha() checks for an alphabetic character; in the standard “C” locale, it is equivalent to (isupper© || islower©). In some locales, there may be additional characters for which isalpha() is true–letters which are neither uppercase nor lowercase. isascii() checks whether c is a 7-bit unsigned char value that fits into the ASCII character set. isblank() checks for a blank character; that is, a space or a tab. iscntrl() checks for a control character. isdigit() checks for a digit (0 through 9). isgraph() checks for any printable character except space. islower() checks for a lowercase character. isprint() checks for any printable character including space. ispunct() checks for any printable character which is not a space or an alphanumeric character. isspace() checks for white-space characters. In the “C” and “POSIX” locales, these are: space, form-feed (‘\\f’), newline (‘\\n’), carriage return (‘\\r’), horizontal tab(‘\\t’), and vertical tab (‘\\v’). isupper() checks for an uppercase letter. isxdigit() checks for hexadecimal digits, that is, one of 0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F. Forward Declaration 12345678910111213141516// forward declarations: solve chicken-and-egg problems// use it before actually define it.int can_print_it(char ch);void print_letters(char arg[], int len);void print_arguments(int argc, char *argv[])&#123; // call can_print_it // call print_letters&#125;int main(int argc, char *argv[])&#123; print_letters(argc, argv);&#125; 原因： 最终要创建自己的头文件，头文件中包含的都是前置声明 headers: declare define， enum， type，funtions 避免 children-and-egg 问题 如果两个函数互相调用，那么谁先定义呢？ 避免了调用嵌套的困扰，不用按照调用的方式顺序定义 calling order 可以按照一些逻辑顺序进行函数的定义 logical order：例如实际使用的函数次序 main() 放在最后：更习惯的用法 can_print_it() 定义成函数的原因： 可以方便修改里面的内容 可以多个地方调用 不要使用 K&amp;R C 的函数声明方法 Exercise 15. Pointers, Dreaded Pointers ages[i]: i: an index / address since it’s a location inside ages that we want ages: (base) address a location in the computer’s memory where all of these integers start C compiler will replace ages anywhere you type it with the address of the very first integer in ages C 把大块的字节数组（也就是内存），抽象为不同大小的类型 C thinks your whole computer is one massive array of bytes What C does is layer on top of this massive array of bytes the concept of types and sizes of those types Pointers A pointer is simply an address pointing somewhere inside the computer’s memory with a type specifier so that you get the right size of data with it. Pointers are just numbers. Ask the OS for a chunk of memory and use a pointer to work with it. This includes strings and something you haven’t seen yet, structs Ask the OS for a chunk of memory and use a pointer to work with it. This includes strings and something you haven’t seen yet, structs Take the address of a function, so you can use it as a dynamic callback. Scan complex chunks of memory, converting bytes off of a network socket into data structures or parsing files. 其他情况，几乎都可以用 arrays 来解决，用数组的操作方法来使用指针（索引）。 These days, the syntax to access an array versus a pointer are translated into the same machine code and optimized in the same way. 只有在十分确定的情况，再用指针来优化。 Pointers NOT Arrays 12int arr[] = &#123;1, 2, 3, 4, 5&#125;;int *ptr = arr; sizeof() sizeof(ptr) 得到的是指针的大小，32 位机器是 4 Bytes，64 位机器是 8 Bytes； sizeof(arr) 得到的是数组的大小，5 * sizeof(int) 赋值 ptr = arr，是把数组的起始地址给 ptr arr = ptr，error: assignment to expression with array type 增减 ptr++，让指针指向接下来一个该类型的元素 arr++，error: lvalue required as increment operand，数组名 arr 不是左值 数组名也不是常指针（即指针常量，a const pointer is pointed at a static address）type *const ptr，由上述三点可以判断。 1234567891011121314151617181920// a constant integer Aint const A;const int A; // a pointer B, point at an constant integer // 常量指针 / 指向常量的指针// B 可以指向别的常量，B 的值可变// 但是不能修改其地址内的内容，*B 不可变const int *B;int const *B;// a constant pointer C // 常指针/指针常量// C 指向的地址不再变化，C 的值不可变// 但是可以修改其地址内的内容，*C 可变int *const C;// a constant pointer D points at a constant integer// D 和 *D 都不可变const int *const D; 指针数组和数组指针 123456789101112// 指针数组，每个元素 names[i] 是一个指针char *names[] = &#123; &quot;Alan&quot;, &quot;Frank&quot;&#125;;printf(&quot;%s, %s, %s, %s\\n&quot;, names[1], *(names + 1));// 数组指针，是一个指针，指向一维数组的地址// name[i] == names + i，移动 i * N 个内存单元char string[N] = &#123; &quot; &quot; &#125;;char (*names)[N] = &amp;string;printf(&quot;string = %s, names = %s, %s\\n&quot;, string, *names, names[0]); Exercise 16. Structs And Pointers to Them strdup(const char *s)，in string.h The strdup() function returns a pointer to a new string which is a duplicate of the string s. Memory for the new string is obtained with malloc(3), and can be freed with free(3). char *a = strdup(&quot;Hello, world&quot;); char a[20]; strcpy(a, &quot;Hello, world&quot;); free(frank); frank = NULL; 释放之后，把指针置空，否则后面如果还访问这个指针，可能会读到奇怪的内容 free() 把指针指向的内容清空（或者说，告诉 OS 不再使用），但是指针的值没有改，可能还可以正常输出内容 Valgrind 可以提示这个错误 invalid read / invalid free() Memory Leak 使用 Valgrind 检查内存泄漏： valgrind --leak-check=full --show-reachable=yes -v ./ex16 Exercise 17. Heap and Stack Memory Allocation make a prototype to initialize it 1struct Address addr = &#123;.id = i, .set = 0&#125;; nested arrow 1struct Address *addr = &amp;conn-&gt;db-&gt;rows[i]; &amp;conn-&gt;db-&gt;rows[i] that reads “get the i element of rows, which is in db, which is in conn, then get the address of (&amp;) it.” atoi 123int atoi(const char *nptr);long atol(const char *nptr);long long atoll(const char *nptr); The atoi() function converts the initial portion of the string pointed to by nptr to int. The behavior is the same as strtol(nptr, NULL, 10); except that atoi() does not detect errors. 1long int strtol(const char *nptr, char **endptr, int base); fread 12345678910111213141516size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);FILE *fopen(const char *path, const char *mode);int fclose(FILE *stream);int fflush(FILE *stream);int fseek(FILE *stream, long offset, int whence);long ftell(FILE *stream);void rewind(FILE *stream);int fgetpos(FILE *stream, fpos_t *pos);int fsetpos(FILE *stream, const fpos_t *pos); The function fread() reads nmemb items of data, each size bytes long, from the stream pointed to by stream, storing them at the location given by ptr. 成功返回读写的数据项的个数，失败返回0. 回到文件开头：rewind(stream) == (void) fseek(stream, 0L, SEEK_SET) strncpy 12char *strcpy(char *dest, const char *src);char *strncpy(char *dest, const char *src, size_t n); The strncpy() function is similar, except that at most n bytes of src are copied. Warning: If there is no null byte among the first n bytes of src, the string placed in dest will not be null-terminated. So add the null byty '\\0' manually. Heap and Stack C is using the real CPU’s actual machinery to do its work, and that involves a chunk of RAM called the stack and another called the heap. Heap：malloc and free. ask OS to register a piece of memory, return a pointer after using, give it back to OS, so that won’t leak Stack Just like a stack data struction, LIFO Store the local variables, even those in main function. prevent leak 堆和栈的三个主要问题： 如果在函数中，使用 malloc 申请了一块内存，而指针是在栈上定义的，那么函数结束之后，指针会出栈，然后内存就丢失（泄漏） 如果在栈上申请了太大的数据（large structs and array），可能会造成 stack overflow 栈溢出，导致错误。这时应该用 malloc。 如果在函数定义的局部变量，使用指针返回，那么就会得到 segmentation fault 段错误，因为变量在函数结束的时候已经出栈消失，指针指向一个 dead space 程序结束后，操作系统会回收空间，但是有时候不会立刻回收；所以使用错误退出，exit(1)，让操作系统当作错误，直接回收。","categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"}],"tags":[{"name":"C","slug":"C","permalink":"https://doreality.xyz/tags/C/"}]},{"title":"「LCTHW」C 语言基础篇（EX 1-13）","slug":"dev/backend/c/lcthw/lcthw-ex1-13","date":"2022-06-01T14:50:55.000Z","updated":"2023-04-07T16:30:54.773Z","comments":true,"path":"posts/5fed90c.html","link":"","permalink":"https://doreality.xyz/posts/5fed90c.html","excerpt":"Learn C The Hard Way, notes for ex01 to ex13.","text":"Learn C The Hard Way, notes for ex01 to ex13. Exercise 2. Using Makefiles to Build How Make Works? Implied dependencies and ancient lore. 1make ex1 可以通过 ex1 来推测要用来构建的文件是 ex1.c，同名的其他后缀的文件。 是几十年来的经验，和隐含的依赖。 Exercise 3. Formatted Printing 使用变量不进行初始化：可能是0，也可能是随机的数据。 所以一定要初始化：要么是要用的值，要么是错误值（-1 或 NULL）。 printf() 格式输出、对齐、宽度、精度： https://blog.csdn.net/muge323/article/details/123402431 %-8.2f： .2 保留2位精度（包括整数部分） -左对齐 8占8位宽度 Exercise 4. Using a Debugger GBD / LLDB 总结：GDB / LLDB 常用命令 一个参考：Beej’s Quick Guide to GDB 打印所有线程的栈 ：thread apply all bt 123456(gdb) thread apply all btThread 1 (process 917):#0 0x0000000000400704 in crash () at ex3.c:8#1 0x00000000004007d4 in main (argc&#x3D;1, argv&#x3D;0xfffffffffd48) at ex3.c:24(gdb) 运行程序，并在出错的时候直接返回调用栈信息： gdb --batch --ex r --ex bt --ex q --args 12345678910111213141516root@ddafb7ecb5fe:~&#x2F;lc# gdb --batch --ex r --ex bt --ex q --args .&#x2F;ex3I am 100 years old.I am 72 inches tall.a[20] &#x3D; 022.1 ,Program received signal SIGSEGV, Segmentation fault.0x0000000000400704 in crash () at ex3.c:88 printf(&quot;%c&quot;, test[i]);#0 0x0000000000400704 in crash () at ex3.c:8#1 0x00000000004007d4 in main (argc&#x3D;1, argv&#x3D;0xfffffffffd48) at ex3.c:24A debugging session is active. Inferior 1 [process 911] will be killed.Quit anyway? (y or n) [answered Y; input not from terminal] Valgrind Valgrind 安装 安装和使用：Valgrind 的安装介绍 LINT apt-get install splint splint ex3.c AddressSanitizer AddressSanitizer GitHub Wiki GCC 4.8 之后自带。 12$gcc -fsanitize=address -fno-omit-frame-pointer -O1 -g test.c -o test$./test Address Sanitizer 用法 Exercise 7. Variables and Types 12345678910111213141516171819char first_name[] = &quot;Zed&quot;;// covered the last byte &#x27;\\0&#x27;first_name[3] = &#x27;$&#x27;;// the pointer has lost the array&#x27;s beginningprintf(&quot;I have a first name %s.\\n&quot;, first_name + 100);// 10737418240000000000// -7709325833709551616 // unsigned 把负数的补码最高位解释为正数1，而在内存中的二进制形式不变unsigned long universe_of_defects = 4294967296L * 4294967295L;printf(&quot;The entire universe has %lu bugs.\\n&quot;, universe_of_defects);printf(&quot;sizeof(long)=%d.\\n&quot;, sizeof(long));// unsigned = 2147483649// int = -2147483647int a = 0b10000000000000000000000000000001;printf(&quot;a = %d.\\n&quot;, a); char * int doesn’t matter long: linux 64bit sizeof = 8 Exercise 8. If, Else-If, Else NO BOOLEAN: any integer that’s 0 is false or otherwise it’s true. 0 真，非 0 假。 Exercise 9. While-Loop and Boolean Expressions 写 while 循环的时候，一定注意： 循环变量初始化了吗？ 每次循环最后，循环变量的值更新了吗？ 如果有 continue 和 break，一定要搞清楚结果是什么 continue 进入下一步循环的时候，循环变量是否改变？ break 跳出循环的时候，是不是想要的结果边界值？ Exercise 10. Switch Statements Always include a default: branch so that you catch any missing inputs. Don’t allow fall through unless you really want it. It’s also a good idea to add a //fallthrough comment so people know it’s on purpose. Always write the case and the break before you write the code that goes in it. Try to use if-statements instead if you can. 初始化 写 case-break 先写 case，然后紧跟着写 break，然后再写代码逻辑 写 default 不要忘记，为了覆盖所有的情况，即使不会运行到，也要打印一些错误信息，同理 else 也要这么处理 case 只接受字面量常量值 Exercise 11. Arrays and Strings when you make string literals you should typically use the char *another = &quot;Literal&quot; syntax. The source of almost all bugs in C come from forgetting to have enough space, or forgetting to put a '\\0' at the end of a string. In fact, it’s so common and hard to get right that the majority of good C code just doesn’t use C-style strings. 按照 numbers[-1] 这样字面量地引用数组范围外的内存，会根据类型大小向前或者向后索引到那个位置，然后输出里面的 garbage 正常应该越界就报错，但是可能会在一段范围内能运行，但是超出范围就会 Segmentation Fault Exercise 12. Sizes and Arrays 初始化数组：type name[] = &#123;initializer&#125;; “I want an array of type that is initialized to {…}.” sizeof to ask C how big things are in bytes 所以会计算 '\\0' nul_byte 空字节的大小 Linux： Tips： 在 32 位机器上，指针是 4 字节；64 位机器上，是 8 字节 long 在 64 位 Windows 上是 4 字节，在 macOS / Linux 64 位上是 8 字节 其他每个系统都是一样的 int 的 2 字节应该是在 16 位机器上 SHRT_MAX and INT_MAX must be at least 32767=$2^{15} -1$ sizeof(char) &lt;= sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long) &lt;= sizeof(long long) Exercise 13. For-Loops and Arrays of Strings for 循环 for (Initializer; Test; Incremeneter) &#123;&#125;： 初始化 判断条件： 如果为真，执行循环体，然后进入 3； 如果为假，跳出循环； 执行 Incrementer 循环变量修改，然后进入 2. 执行的文件名 ./ex13 是 argv[0] 创建字符串数组 Array of Strings char *str = &quot;blah&quot; + char str[] = &#123;'b','l','a','h'&#125; = char *states[] = &#123;...&#125; 逗号表达式 123456int i = 0, j = 0;for (i = 0, j = 0; i &lt; 5, j &lt; 10; i++, j++)&#123; // 只要 j &lt; 10 即可进入循环体 // Do something &#125; 用逗号分开的表达式的值分别结算，整个表达式的值是最后一个表达式的值。","categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"}],"tags":[{"name":"C","slug":"C","permalink":"https://doreality.xyz/tags/C/"}]},{"title":"C++ 多态：父类指针指向子类对象","slug":"dev/backend/cpp/cpp-base-class-and-derived-object","date":"2022-05-26T10:09:35.000Z","updated":"2023-04-07T16:36:55.672Z","comments":true,"path":"posts/1466be2b.html","link":"","permalink":"https://doreality.xyz/posts/1466be2b.html","excerpt":"C++ 多态；父类（基类）指针指向子类（派生类）对象。","text":"C++ 多态；父类（基类）指针指向子类（派生类）对象。 一个小例子 遇到了一个小例子（CS 106L）： 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;fstream&gt;//No using namespace std;!!!!using std::cout;using std::endl;using std::string;void writeToOstream(std::ostream&amp; myOstream, int num) &#123; myOstream &lt;&lt; &quot;Write number to ostream: &quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123; int myNum = 42; // : public basic_ostream std::ofstream myOfstream(&quot;out.txt&quot;); writeToOstream(cout, myNum); // print to the screen writeToOstream(myOfstream, myNum); // print to file return 0;&#125; 具体的细节还没掌握，暂时粗浅理解为 std::ofstream 是 std::ostream 的一个派生类，并且重写了 &lt;&lt; 操作符。 在函数 writeToOstream() 参数为基类引用 std::ostream&amp; 时，可以让派生类对象 myOfstream 把内容输出到文件 out.txt。原因是，在基类的成员函数实现为 virtual function 的时候，通过基类指针，可以调用派生类中重写后的相应的成员函数。 这个就是 C++ 多态的实现：动态绑定（Dynamic Binding）。 静态绑定 示例来源。 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;struct A &#123; void f() &#123; cout &lt;&lt; &quot;Class A&quot; &lt;&lt; endl; &#125;&#125;;struct B: A &#123; void f() &#123; cout &lt;&lt; &quot;Class B&quot; &lt;&lt; endl; &#125;&#125;;void g(A&amp; arg) &#123; arg.f();&#125;int main() &#123; B x; g(x);&#125; 输出是：Class A。 原因：x 是 B 类的对象，继承了 A 的所有成员和函数，而通过 g(x) 把 x 传给一个基类 A 的引用 arg，通过静态绑定（Static Binding，编译时绑定），只能访问派生类中属于基类的那部分内容，而不能调用派生类的特有的成员（例如重写的函数也不行）。 动态绑定 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;struct A &#123; virtual void f() &#123; cout &lt;&lt; &quot;Class A&quot; &lt;&lt; endl; &#125;&#125;;struct B: A &#123; void f() &#123; cout &lt;&lt; &quot;Class B&quot; &lt;&lt; endl; &#125;&#125;;void g(A&amp; arg) &#123; arg.f();&#125;int main() &#123; B x; g(x);&#125; 代码输出是： Class B 原因：将基类中的函数添加关键字 virtual 变成虚函数，再在派生类中重写（override），那么派生类中重写的函数也是虚函数。通过基类指针/引用，就可以调用派生类对象的虚函数。这提供了一个打破静态绑定规则的机制。 此时是在运行时实现的动态绑定： 如果基类指针指向基类对象，那么调用的依旧是基类的函数； 如果基类指针指向派生类对象，并且调用的是对基类虚函数进行重写的虚函数，那么调用的就是派生类的成员函数。 重写规则 派生类重定义（redefine）基类的虚函数，会覆盖基类的虚函数。 重写的特点： 作用域不同； 函数名、参数列表、返回值相同； 基类函数是 virtual 若派生类重定义了一个基类虚函数，但是重载（overload，函数名相同，但是返回值和参数列表不同），那么该派生类的函数就不是重写，并且也不是虚函数，同时，会隐藏基类的虚函数。 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;struct A &#123; virtual void f() &#123; cout &lt;&lt; &quot;Class A&quot; &lt;&lt; endl; &#125;&#125;;struct B: A &#123; void f(int) &#123; cout &lt;&lt; &quot;Class B&quot; &lt;&lt; endl; &#125;&#125;;struct C: B &#123; void f() &#123; cout &lt;&lt; &quot;Class C&quot; &lt;&lt; endl; &#125;&#125;;int main() &#123; B b; C c; A* pa1 = &amp;b; A* pa2 = &amp;c;// b.f(); pa1-&gt;f(); pa2-&gt;f();&#125; 输出： 12Class AClass C B::f 是重载，C::f 是重写且是虚函数。 虚函数表 C++ 实现虚函数的原理是虚函数表+虚表指针。 当一个类里存在虚函数时， For Class：编译器会为类创建一个虚函数表，虚函数表是一个数组，数组的元素存放的是类中虚函数的地址。 For Object：编译器为每个类的对象添加一个隐藏成员，该隐藏成员保存了指向该虚函数表的指针。该隐藏成员占据该对象的内存布局的最前端。 所以虚函数表只有一份，而有多少个对象，就对应多少个虚函数表指针。 总结：多态 利用虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。 换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，这种现象称为多态（Polymorphism）。 参考 怎么理解C++多态的“父类指针或引用指向子类对象”？ C++父类指针指向子类对象的实现原理 Virtual functions (C++ only)","categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://doreality.xyz/tags/CPP/"},{"name":"OOP","slug":"OOP","permalink":"https://doreality.xyz/tags/OOP/"}]},{"title":"GDB / LLDB 常用命令","slug":"dev/debugger/gdb-and-lldb-usage","date":"2022-05-22T12:57:29.000Z","updated":"2023-04-07T16:09:40.379Z","comments":true,"path":"posts/3b78b4cb.html","link":"","permalink":"https://doreality.xyz/posts/3b78b4cb.html","excerpt":"GDB 和 LLDB 常用命令汇总，随用随查。","text":"GDB 和 LLDB 常用命令汇总，随用随查。 参考： LCTHW - Learn C The Hard Way 格式：完整命令 | 缩写 GDB GDB = GNU Debugger 小技巧 gdb --args Shell 中使用 传入参数 thread apply all bt GDB 中使用 查看所有线程的调用栈情况 gdb --batch --ex r --ex bt --ex q --args Shell 中使用，后面加可执行程序，例如 ./test 运行程序，如果出错（Bomb）会输出栈回溯（Stack Backtrace）信息 简易版 Valgrind 常用命令 run [args] | r Start your program with [args]. break [file:]function | b Set a break point at [file:]function. backtrace | bt Dump a backtrace of the current calling stack. print expr | p Print the value of expr. continue | c Continue running the program. next | n Next line, but step over function calls. step | s Next line, but step into function calls. quit | q Exit GDB. help | h List the types of commands. You can then get help on the class of command as well as the command. cd, pwd, make This is just like running these commands in your shell. shell Quickly start a shell so you can do other things. clear Clear a breakpoint. info break, info watch Show information about breakpoints and watchpoints. attach pid Attach to a running process so you can debug it. detach Detach from the process. list List out the next ten source lines. Add a - to list the previous ten lines. LLDB The LLDB Debugger (LLDB) is the debugger component of the LLVM (Low Level Virtual Machine) project. run [args] | r Start your program with [args]. breakpoint set --name [file:]function | b Set a break point at [file:]function. thread backtrace | bt Dump a backtrace of the current calling stack. print expr | p Print the value of expr. continue | c Continue running the program. next | n Next line, but step over function calls. step | s Next line, but step into function calls. Shorthand is s. quit | q Exit LLDB. help | h List the types of commands. You can then get help on the class of command as well as the command itself. cd, pwd, make just like running these commands in your shell. shell Quickly start a shell so you can do other things. clear Clear a breakpoint. info break, info watch Show information about breakpoints and watchpoints. attach -p pid Attach to a running process so you can debug it. detach Detach from the process. list List out the next ten source lines. Add a - to list the previous ten sources.","categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"}],"tags":[{"name":"GDB","slug":"GDB","permalink":"https://doreality.xyz/tags/GDB/"},{"name":"LLDB","slug":"LLDB","permalink":"https://doreality.xyz/tags/LLDB/"}]},{"title":"Valgrind 安装","slug":"dev/debugger/valgrind-installation","date":"2022-05-22T12:34:37.000Z","updated":"2023-04-07T16:09:29.433Z","comments":true,"path":"posts/8e3c74d.html","link":"","permalink":"https://doreality.xyz/posts/8e3c74d.html","excerpt":"Valgrind：用于内存调试、内存泄漏检测以及性能分析。","text":"Valgrind：用于内存调试、内存泄漏检测以及性能分析。 环境： 12$uname -aLinux ddafb7ecb5fe 5.10.104-linuxkit #1 SMP PREEMPT Thu Mar 17 17:05:54 UTC 2022 aarch64 aarch64 aarch64 GNU/Linux 源码 tar.bz2 安装 官网下载源代码：https://valgrind.org/downloads/ 进入下载路径，解压到当前目录： 1$tar -xjvf valgrind-3.19.0.tar.bz2 进入解压后的目录 valgrind-3.19.0，配置和安装： 12345678910111213$cd valgrind-3.19.0/# a) 设置环境（需要标准的autoconf工具）# apt-get install autoconf$./autogen.sh# b) 配置 Valgrind，常用参数：--prefix=安装路径# 这里/root/Valgrind 是我的Docker的路径，虚拟机或者真机自行选择$./configure --prefix=/root/Valgrind# c) 编译安装$make$make install 验证是否安装成功： 12345$valgrind ls -l==23775== Memcheck, a memory error detector==23775== Copyright (C) 2002-2015, and GNU GPLd, by Julian Seward et al.==23775== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info==23775== Command: ls -l","categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://doreality.xyz/tags/Linux/"},{"name":"Valgrind","slug":"Valgrind","permalink":"https://doreality.xyz/tags/Valgrind/"}]},{"title":"Makefile 使用（一）","slug":"dev/makefile/Using-Makefile-1","date":"2022-05-11T17:26:13.000Z","updated":"2023-04-07T16:07:47.655Z","comments":true,"path":"posts/5dc7c8b1.html","link":"","permalink":"https://doreality.xyz/posts/5dc7c8b1.html","excerpt":"记录一些 Makefile 小 Tips。 简单的规则格式 两个函数 wildcard 和 patsubst 条件：ifdef / ifeq，else 和 endif","text":"记录一些 Makefile 小 Tips。 简单的规则格式 两个函数 wildcard 和 patsubst 条件：ifdef / ifeq，else 和 endif Linux 中，默认情况下，make 命令寻找顺序（当前目录）： GNUmakefile -&gt; makefile -&gt; Makefile -&gt; Make.Linux（自定义的，需要加 -f） 推荐使用 Makefile。 基本的规则 命令前面务必加上一个 TAB： 123456(target): (dependencies) (commands) # 这里是注释myapp: myapp.c gcc -Wall myapp.c -o myapp 两个函数 wildcard：表示通配符 padsubst：Pattern Substring，字符串替换 123456789101112# SRC: 当前目录下所有 .c 文件SRC = $(wildcard *.c)# OBJ: 把 SRC 中所有的 .c 换成 .oOBJ = $(patsubst %.c, %.o, $(SRC)) ALL: hellohello: $(OBJ) gcc $(OBJ) -o hello$(OBJ): $(SRC) gcc -c $(SRC) -o $(OBJ) 条件 ifdef 1234567891011VARIABLE = 1ifdef VARIABLE...else...endif ifeq 123456789101112VARIABLE_1 = 1VARIABLE_2 = 2ifeq ($(VARIABLE), $(VARIABLE_2))...else...endif","categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"}],"tags":[{"name":"Makefile","slug":"Makefile","permalink":"https://doreality.xyz/tags/Makefile/"}]},{"title":"Markdown 绘图：mermaid 和 flow graph","slug":"tools/markdown/mermaid-and-flow-graph-in-md","date":"2022-04-10T03:35:30.000Z","updated":"2023-04-07T16:27:49.296Z","comments":true,"path":"posts/20e330e7.html","link":"","permalink":"https://doreality.xyz/posts/20e330e7.html","excerpt":"Markdown 流程图、框图、甘特图、各种图。","text":"Markdown 流程图、框图、甘特图、各种图。 mermaid: Markdown语法之绘制流程图 flow: MarkDown flow流程图示例 12345678910111213&#96;&#96;&#96;mermaidgraph TD start[开始] -.描述.-&gt; input[输入A,B,C] input --描述--&gt; conditionA&#123;A是否大于B&#125; conditionA -- YES --&gt; conditionC&#123;A是否大于C&#125; conditionA -- NO --&gt; conditionB&#123;B是否大于C&#125; conditionC -- YES --&gt; printA[输出A] conditionC -- NO --&gt; printC[输出C] conditionB -- YES --&gt; printB[输出B] conditionB -- NO --&gt; printC[输出C] printA &#x3D;&#x3D;&gt; stop[结束] printC --&gt; stop printB &#x3D;&#x3D; 描述 &#x3D;&#x3D;&gt; stop 123456789101112131415&#96;&#96;&#96;flowstart&#x3D;&gt;start: 开始input&#x3D;&gt;inputoutput: 输入operation&#x3D;&gt;operation: 操作condition&#x3D;&gt;condition: 操作出错？output&#x3D;&gt;inputoutput: 输出error&#x3D;&gt;operation: 请重新输入end&#x3D;&gt;end: 结束start-&gt;inputinput-&gt;operationoperation-&gt;conditioncondition(no,bottom)-&gt;outputcondition(yes)-&gt;error(top)-&gt;inputoutput-&gt;end","categories":[{"name":"Tools","slug":"Tools","permalink":"https://doreality.xyz/categories/Tools/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://doreality.xyz/tags/Markdown/"}]},{"title":"Cousera 视频快速加载","slug":"tools/how-to-visit-cousera","date":"2022-03-12T09:39:08.000Z","updated":"2023-04-07T15:30:42.558Z","comments":true,"path":"posts/c400d692.html","link":"","permalink":"https://doreality.xyz/posts/c400d692.html","excerpt":"学一些 Coursera 但是视频缓冲好慢。","text":"学一些 Coursera 但是视频缓冲好慢。 配置 DNS 找到 hosts： C:\\Windows\\System32\\drivers\\etc （Windows） /etc/hosts （macOS/Linux，Finder-「前往」-「前往文件夹」-/private/etc） 添加如下内容：(不能直接添加就拷贝一份文件到外面，修改之后覆盖原来的） 123# coursera13.249.162.18 d3njjcbhbojbot.cloudfront.net # 网站18.65.219.131 d3c33hcgiwev3.cloudfront.net # 视频 两个查询 DNS 的网站，可以找到想访问网址对应的各种 DNS 服务器的 IP： https://ping.eu/nslookup/ http://ping.chinaz.com/ 输入的如下网址得到相应的IP： 网站：d3njjcbhbojbot.cloudfront.net 视频：d3c33hcgiwev3.cloudfront.net 可以尝试 ping 一下这些 IP，找到速度比较快的添加到 hosts 中即可。 刷新 DNS，然后重新打开 Coursera即可 在命令行 or 终端里输入下面的命令： 1234# Windows$ipconfig /flushdns# macOS$dscacheutil -flushcache 可以再 ping 一下网站和视频对应的链接，看一看 IP 是否成功。 参考 Coursera视频打不开终极办法 Cousera视频无法播放问题解决","categories":[{"name":"Tools","slug":"Tools","permalink":"https://doreality.xyz/categories/Tools/"}],"tags":[{"name":"DNS","slug":"DNS","permalink":"https://doreality.xyz/tags/DNS/"}]},{"title":"「SNDD」简单网络设备驱动程序","slug":"projects/simpler-eth-driver","date":"2022-01-19T10:42:09.000Z","updated":"2023-04-07T16:44:51.504Z","comments":true,"path":"posts/c73d89f1.html","link":"","permalink":"https://doreality.xyz/posts/c73d89f1.html","excerpt":"本文首发地址：简单网络驱动（基于 Linux-4.15.x 版本内核） 本文设计并实现了一个简单的网络设备驱动程序（基于 Linux-4.15.x 版本内核）—— A Simpler Network Device Driver（下文简称 sndd）。 源码地址（仅供学习交流）：https://gitee.com/doreality/sndd 参考《Linux 设备驱动程序（第3版）》（以下简称“LDD3”）第 17 章“网络驱动程序”的snull模块实现 P.S. 下文所提到的“网络设备驱动程序”、“网络设备驱动”、“网络驱动程序”、“网络驱动”都指的是同一个概念。","text":"本文首发地址：简单网络驱动（基于 Linux-4.15.x 版本内核） 本文设计并实现了一个简单的网络设备驱动程序（基于 Linux-4.15.x 版本内核）—— A Simpler Network Device Driver（下文简称 sndd）。 源码地址（仅供学习交流）：https://gitee.com/doreality/sndd 参考《Linux 设备驱动程序（第3版）》（以下简称“LDD3”）第 17 章“网络驱动程序”的snull模块实现 P.S. 下文所提到的“网络设备驱动程序”、“网络设备驱动”、“网络驱动程序”、“网络驱动”都指的是同一个概念。 前言 几个概念理解 为什么要选择 Linux ？ 在源码公开和支持模块化这样优点的加成下，Linux 系统非常适合作为学习编写设备驱动程序的环境。 什么是设备驱动程序？ 设备驱动程序，是应用程序和除了CPU、内存等硬件设备之外的几乎所有外设打交道的桥梁。应用程序使用OS提供的统一接口——系统调用，就像使用了一把万能钥匙，可以打开并访问各种不同外设，而并不用关心这些设备本身的样子。 例如块设备，应用程序说打开它，然后读写一些数据，那么直接使用open，read，write这些系统调用就好了，并不需要考虑数据是怎么在光盘或者磁盘上使用什么不同的介质存储、被组织排列成什么顺序。 有哪些设备驱动程序？ 正因为有越来越多不同的设备出现，设备驱动也是种类繁杂，一般可以分为三类：字符设备驱动、块设备驱动和网络设备驱动。这样分类有利于模块化编程，但是，当然，对于复杂的设备，也可以把这些都综合为一个模块（以灵活性为代价）。 对于字符设备驱动和块设备驱动来说，Linux 系统都会在/dev目录下创建一个文件节点，把它们都抽象为一个文件，可以打开关闭、可以读写也可以进行配置。 但是网络设备驱动有所不同。 网络设备是要和外界互联的，网络驱动程序要异步地接收来自外界的数据包，然后向内核请求，把这些数据包发送给内核。这和块设备只响应内核的要求、只向固定缓冲区发送数据，是完全不同的。网络驱动没有必要留一个/dev下的节点，因为对它打开关闭也好、读写也罢，并没有实质的意义。网络驱动要做的就是，在收到数据包的时候，发送给内核；在内核要发送数据包的时候，它进行封装（自己的硬件头部）然后发送。 网络驱动在哪里 如果说网络驱动是一把万能钥匙，那也是开大门的钥匙吧，那就是在内核了。这是在应用程序和驱动程序的角度来看。 如果说从网络的分层来看，网络驱动程序就是很底层了。LDD3 中提到，Linux 的网络子系统被设计为和协议完全无关。协议隐藏在驱动程序之后，而物理传输又被隐藏在协议之后。内核和网络驱动之间的交互，可能每次处理的是一个网络数据包。 但是同样值得指出的是，驱动接收的是外界发送的数据包，但是传输时要给上层传递下来的数据包封装一个 MAC 的头部信息。所以驱动会使用硬件协议，但是处理传输的是 IP 数据包。 （图源：百度百科——网络驱动程序接口规范） sndd 设计 sndd 实现一个基于内存的网络驱动模块，模拟了网络接口和远程主机通信的过程。 sndd 中使用的接口不依赖于任何硬件，是纯软件实现的数据包传输和发送。 在二层协议上选择以太网协议，处理传输的是 IP 数据包（对其他非 IP 数据包的修改会破坏原本数据包）。 由于使用以太网协议，在实际测试的时候可以使用 tcpdump 工具进行抓包验证数据包的传输。 网络拓扑 驱动模拟了四个网络接口，接口名：sndd0，sndd1，sndd2 和 sndd3 对应的主机名为 lc0，lc1，lc2 和 lc3 四个接口位于四个不同的子网，网络名分别为 snet0，snet1，snet2 和 snet3 在三个网段中，各自分别有一台主机，主机名：rm0，rm1，rm2 和 rm3 网络结构如下图所示： 驱动要实现的功能如下： 从主机发送到 rm0 的数据包，要从 sn3 接收到 从主机发送到 rm3 的数据包，要从 sn0 接收到 从主机发送到 rm1 的数据包，要从 sn2 接收到 从主机发送到 rm2 的数据包，要从 sn1 接收到 为了实现上述功能，给各接口和主机分配 IP 地址如下： 123456789101112131415# 网络号 &#x2F;etc&#x2F;networkssnet0 192.168.4.0snet1 192.168.5.0snet2 192.168.6.0snet3 192.168.7.0# 主机号 &#x2F;etc&#x2F;hosts192.168.4.1 lc0 192.168.4.2 rm0192.168.5.2 lc1192.168.5.1 rm1192.168.6.1 lc2192.168.6.2 rm2192.168.7.2 lc3192.168.7.1 rm3 同时，在终端里配置网络接口： 1234$ sudo ifconfig sndd0 lc0 netmask 255.255.255.0$ sudo ifconfig sndd1 lc1 netmask 255.255.255.0$ sudo ifconfig sndd2 lc2 netmask 255.255.255.0$ sudo ifconfig sndd3 lc3 netmask 255.255.255.0 根据所设置的 IP 地址，为了实现功能，要在驱动中接收到数据包时，修改 IP 数据包的头部中的源 IP 地址和目的 IP 地址： 把第 3 个 octet 依次修改（4-&gt;5，5-&gt;4，6-&gt;7，7-&gt;6） 把第 4 个 octet 修改（1-&gt;2，2-&gt;1） 模块结构 实现一个简单的模块，至少需要包含如下几个部分： 模块注册和注销 模块初始化 模块的具体操作 对于要实现的简单网络设备驱动， 包含的数据结构： 接口数据结构 struct net_device * 操作数据结构 struct header_ops struct net_device_ops 自定义数据包 struct sndd_packet 接口的私有信息 struct sndd_priv 包含操作： 注册 sndd_init_module() 注销 sndd_cleanup() 初始化 sndd_init() 打开 sndd_open() 关闭 sndd_release() 传输 / 接收 传输 sndd_tx() 接收 sndd_rx() 数据处理 修改 header sndd_header() 单个缓冲区 sndd_get_tx_buffer() sndd_release_buffer() 缓冲池 建立：sndd_setup_pool() 回收：sndd_teardown_pool() 缓冲队列 sndd_enqueue_buf() sndd_dequeue_buf() 中断 sndd_regular_interrupt() 统计 net_device_stats *sndd_stats() I / O 控制 sndd_ioctl() 使用一些简化： 传输和接收采用中断机制，而不是轮询（NAPI） 不设置传输超时判断 硬件地址由软件模拟 不使用 ARP，采用软件模拟 不修改 MTU sndd 实现 模块的注册、注销和初始化 首先是每个模块的注册和注销函数： 12module_init(sndd_init_module);module_exit(sndd_cleanup); 注册，完成的功能就是给每个接口申请内存（在这个步骤里要进行接口的初始化 sndd_init），最关键的就是使用注册函数register_netdev(sndd_devs[i])，把接口注册到内核中。 12345678910111213141516171819202122232425262728293031323334/* * Register the module */int sndd_init_module(void)&#123; int result, i, ret = -ENOMEM; sndd_interrupt = sndd_regular_interrupt; /* Allocate the devices */ sndd_devs[0] = alloc_netdev(sizeof(struct sndd_priv), &quot;sndd%d&quot;, NET_NAME_UNKNOWN, sndd_init); sndd_devs[1] = alloc_netdev(sizeof(struct sndd_priv), &quot;sndd%d&quot;, NET_NAME_UNKNOWN, sndd_init); sndd_devs[2] = alloc_netdev(sizeof(struct sndd_priv), &quot;sndd%d&quot;, NET_NAME_UNKNOWN, sndd_init); sndd_devs[3] = alloc_netdev(sizeof(struct sndd_priv), &quot;sndd%d&quot;, NET_NAME_UNKNOWN, sndd_init); if (sndd_devs[0] == NULL || sndd_devs[1] == NULL) goto out; ret = -ENODEV; for (i = 0; i &lt; 4; i++) if ((result = register_netdev(sndd_devs[i]))) printk(&quot;sndd: error %i registering device \\&quot;%s\\&quot;\\n&quot;, result, sndd_devs[i]-&gt;name); else ret = 0; out: if (ret) sndd_cleanup(); return ret;&#125; 注销，就是注册的倒序，先从内核中注销，然后清除内部的数据结构，最后释放接口。 12345678910111213141516/* * Unregister the module */void sndd_cleanup(void)&#123; int i; for (i = 0; i &lt; 4; i++) &#123; if (sndd_devs[i]) &#123; unregister_netdev(sndd_devs[i]); sndd_teardown_pool(sndd_devs[i]); free_netdev(sndd_devs[i]); &#125; &#125; return;&#125; 初始化： 12345678910111213141516171819202122232425262728293031/* * The init function (sometimes called probe). * It is invoked by register_netdev() */void sndd_init(struct net_device *dev)&#123; struct sndd_priv *priv; /* * Then, assign other fields in dev, using ether_setup() and some * hand assignments */ ether_setup(dev); /* assign some of the fields */ dev-&gt;netdev_ops = &amp;sndd_netdev_ops; dev-&gt;header_ops = &amp;sndd_header_ops; /* keep the default flags, just add NOARP */ dev-&gt;flags |= IFF_NOARP; dev-&gt;features |= NETIF_F_HW_CSUM; /* * Then, initialize the priv field. This encloses the statistics * and a few private fields. */ priv = netdev_priv(dev); memset(priv, 0, sizeof(struct sndd_priv)); spin_lock_init(&amp;priv-&gt;lock); priv-&gt;dev = dev; sndd_rx_ints(dev, 1); /* enable receive interrupts */ sndd_setup_pool(dev);&#125; 数据包的传输 从上层接收到的数据包，要先封装硬件协议（这里是以太网协议）的头部，然后放入发送队列。 每一个数据包都包含在一个 sk_buff 结构中，就是一个 socket 缓冲区。 最后调用 sndd_hw_tx 实现网络驱动的具体操作，就是修改源和目的，实现一个回环功能。 123456789101112131415161718192021222324252627/* * Transmit a packet (called by the kernel) */int sndd_tx(struct sk_buff *skb, struct net_device *dev)&#123; int len; char *data, shortpkt[ETH_ZLEN]; struct sndd_priv *priv = netdev_priv(dev); data = skb-&gt;data; len = skb-&gt;len; if (len &lt; ETH_ZLEN) &#123; memset(shortpkt, 0, ETH_ZLEN); memcpy(shortpkt, skb-&gt;data, skb-&gt;len); len = ETH_ZLEN; data = shortpkt; &#125; netif_trans_update(dev); /* Remember the skb, so we can free it at interrupt time */ priv-&gt;skb = skb; /* actual deliver of data is device-specific, and not shown here */ sndd_hw_tx(data, len, dev); return 0; /* Our simple device can not fail */&#125; 数据包的接收 由于是使用中断驱动，当数据包异步到达的时候，中断程序调用 sndd_rx 将数据包和附加信息发送到上层。 1234567891011121314151617181920212223242526272829303132/* * Receive a packet: retrieve, encapsulate and pass over to upper levels */void sndd_rx(struct net_device *dev, struct sndd_packet *pkt)&#123; struct sk_buff *skb; struct sndd_priv *priv = netdev_priv(dev); /* * The packet has been retrieved from the transmission * medium. Build an skb around it, so upper layers can handle it */ skb = dev_alloc_skb(pkt-&gt;datalen + 2); if (!skb) &#123; if (printk_ratelimit()) printk(KERN_NOTICE &quot;sndd rx: low on mem - packet dropped\\n&quot;); priv-&gt;stats.rx_dropped++; goto out; &#125; skb_reserve(skb, 2); /* align IP on 16B boundary */ memcpy(skb_put(skb, pkt-&gt;datalen), pkt-&gt;data, pkt-&gt;datalen); /* Write metadata, and then pass to the receive level */ skb-&gt;dev = dev; skb-&gt;protocol = eth_type_trans(skb, dev); skb-&gt;ip_summed = CHECKSUM_UNNECESSARY; /* don&#x27;t check it */ priv-&gt;stats.rx_packets++; priv-&gt;stats.rx_bytes += pkt-&gt;datalen; netif_rx(skb); out: return;&#125; 更多具体的实现可见源代码并参考 LDD3 中的 snull 模块。 sndd 测试 利用 Makefile 生产 .ko 加载到内核之后，使用 ping 和 tcpdump 可以测试本驱动。 Makefile 和 LDD3 中所给示例基本是一样的。 1234567891011121314151617181920212223242526272829303132333435# Comment/uncomment the following line to disable/enable debugging#DEBUG = y# Add your debugging flag (or not) to CFLAGSifeq ($(DEBUG),y) DEBFLAGS = -O -g -DSNULL_DEBUG # &quot;-O&quot; is needed to expand inlineselse DEBFLAGS = -O2endifEXTRA_CFLAGS += $(DEBFLAGS)EXTRA_CFLAGS += -I..ifneq ($(KERNELRELEASE),)# call from kernel build systemobj-m := sndd.oelseKERNELDIR ?= /lib/modules/$(shell uname -r)/buildPWD := $(shell pwd)default: $(MAKE) -C $(KERNELDIR) M=$(PWD) modulesendifclean: rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions *.mod modules.order *.symversdepend .depend dep: $(CC) $(EXTRA_CFLAGS) -M *.c &gt; .dependifeq (.depend,$(wildcard .depend))include .dependendif 模块测试 编译并装载模块 12$ make$ sudo insmod sndd.ko 模块加载到内核之后，模拟的网络接口就出现了，使用 ifconfig 命令可以查看： 配置网络 如前所述，配置网络和主机号，同时绑定接口的 IP。 测试 测试效果如下图。 当发出ping -c1 1 rm0命令，发送目的地址为 rm0 的数据包请求时，按顺序发送了如下事件： 在 sndd0 上观察到，从 lc0 &gt; rm0 发起了一次请求； 在 sndd1 上观察到，从 rm1 &gt; lc1 发起了一次请求； 在 sndd1 上观察到，从 lc1 &gt; rm1 发起了一次回应； 在 sndd0 上观察到，从 rm0 &gt; lc0 发起了一次回应。 这个过程就实现了一个扩展的回环网络，从 lc0 到 lc1，然后从 lc1 再到 lc0，实现了一次双向的通信。 同理，使用 ping 访问 rm1，rm2 和 rm3 时，也实现了这样的过程。 小结 模块化编程要注意，卸载模块的时候，一定要把申请的所有内存都释放，否则会影响内核下一次启动； 网络驱动比起字符驱动和块设备驱动，会更抽象一点，实际的使用需要结合具体的网络设备来编写； 配置测试接口的 IP 时，要多测试一下，如果突然不好用了重新使用 ifconfig 配置一下； 在实际网络中使用的时候，必须要有传输超时和并发控制（这里没有给出，但是 LDD3 中都有涉及）； 除了中断的方式处理数据接收和发送，还可以使用轮询（NAPI）的方式，常用于流量非常大的高速接口（如宽带接口）； 网络驱动其实并不关注协议内容，也不关注头部和数据的划分，但是，需要比较了解协议的结构，才能在传输和发送时更好处理。 参考 LDD3 的 snull 示例参考代码（基于新版内核修改）：https://github.com/martinezjavier/ldd3 snull 在新版内核上编译不通过问题：Linux设备驱动程序(LDD)中snull的编译问题","categories":[{"name":"Projects","slug":"Projects","permalink":"https://doreality.xyz/categories/Projects/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://doreality.xyz/tags/Linux/"},{"name":"Device Driver","slug":"Device-Driver","permalink":"https://doreality.xyz/tags/Device-Driver/"}]},{"title":"Jupyter Notebook 基础使用","slug":"dev/backend/python/easy-use-jupyter-notebook","date":"2022-01-05T04:49:40.000Z","updated":"2023-04-07T16:21:33.141Z","comments":true,"path":"posts/4342490b.html","link":"","permalink":"https://doreality.xyz/posts/4342490b.html","excerpt":"Jupyter Notebook 安装与使用。","text":"Jupyter Notebook 安装与使用。 安装 12$ pip3 install ipython$ pip3 install &quot;ipython[notebook]&quot; 启动 1$ ipython notebook","categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://doreality.xyz/tags/Python/"},{"name":"Jupyter Notebook","slug":"Jupyter-Notebook","permalink":"https://doreality.xyz/tags/Jupyter-Notebook/"}]},{"title":"终端运行 .sh 文件报错：zsh operation not permitted","slug":"Q&A/zsh-operation-not-permitted","date":"2022-01-04T16:38:47.000Z","updated":"2023-04-07T16:06:30.406Z","comments":true,"path":"posts/46c2dc33.html","link":"","permalink":"https://doreality.xyz/posts/46c2dc33.html","excerpt":"","text":"M1 芯片运行.sh文件报zsh: operation not permitted","categories":[{"name":"Q&A","slug":"Q-A","permalink":"https://doreality.xyz/categories/Q-A/"}],"tags":[{"name":"macOS","slug":"macOS","permalink":"https://doreality.xyz/tags/macOS/"},{"name":"zsh","slug":"zsh","permalink":"https://doreality.xyz/tags/zsh/"}]},{"title":"使用自定义端口号打开 Flask App","slug":"dev/backend/python/open-flask-app-by-user-defined-port","date":"2022-01-02T16:33:02.000Z","updated":"2023-04-07T16:37:21.387Z","comments":true,"path":"posts/6590c97f.html","link":"","permalink":"https://doreality.xyz/posts/6590c97f.html","excerpt":"Flask 默认启动端口号是 5000，如果被占用，就会报错，启动失败。 这时就需要自定义使用其他的端口号。","text":"Flask 默认启动端口号是 5000，如果被占用，就会报错，启动失败。 这时就需要自定义使用其他的端口号。 打开时指定 1$ env FLASK_APP=app.py flask run -p 5030 在代码中指定 12if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;, port=5030) 但是在这种情况下，执行命令： 1$ env FLASK_APP=app.py flask run 仍是从 5000 端口打开。 此时应该直接执行如下命令： 1$ python3.9 app.py 就是按照代码指定的端口打开了，访问 localhost:5030 即可。","categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"https://doreality.xyz/tags/Flask/"}]},{"title":"Markdown 数学符号和公式输入","slug":"tools/markdown/formula-in-md","date":"2022-01-02T10:01:48.000Z","updated":"2023-04-07T16:42:14.622Z","comments":true,"path":"posts/78e38634.html","link":"","permalink":"https://doreality.xyz/posts/78e38634.html","excerpt":"Markdown 中的数学符号输入：脚标、公式等。","text":"Markdown 中的数学符号输入：脚标、公式等。 非常详尽的参考：markdown中公式编辑教程 行内： $...$ 块：$$...$$ 脚标 上标：O(n2) = O(n&lt;sup&gt;2&lt;/sup&gt;) 下标：H2 = H&lt;sub&gt;2&lt;/sub&gt;","categories":[{"name":"Tools","slug":"Tools","permalink":"https://doreality.xyz/categories/Tools/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://doreality.xyz/tags/Markdown/"}]},{"title":"Docker Linux 中使用 GDB 出现警告","slug":"Q&A/docker-gdb-warning","date":"2021-12-23T13:50:30.000Z","updated":"2023-04-07T16:05:29.774Z","comments":true,"path":"posts/8a332699.html","link":"","permalink":"https://doreality.xyz/posts/8a332699.html","excerpt":"在 Docker 容器中使用 GDB 调试出现警告： warning: Error disabling address space randomization: Operation not permitted","text":"在 Docker 容器中使用 GDB 调试出现警告： warning: Error disabling address space randomization: Operation not permitted 参考解决：DockerContainer下gdb无法正常工作的解决办法 问题截图 解决方案 1$ docker run --privileged -it -v $PWD/codes/lcthw:/home/ ubuntu /bin/bash 注意，是创建一个容器，而不是进入之前的容器 docker exec。 重新创建容器后，进入 GDB 正常：","categories":[{"name":"Q&A","slug":"Q-A","permalink":"https://doreality.xyz/categories/Q-A/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://doreality.xyz/tags/Docker/"}]},{"title":"Docker 基本使用","slug":"dev/docker/docker-easy-use","date":"2021-12-23T11:28:11.000Z","updated":"2023-04-07T16:38:35.165Z","comments":true,"path":"posts/726dca2.html","link":"","permalink":"https://doreality.xyz/posts/726dca2.html","excerpt":"Docker 的简单使用：镜像、容器、Ubuntu。","text":"Docker 的简单使用：镜像、容器、Ubuntu。 问题来自学 C 语言要使用的一个工具 Valgrind，但是它现在还没有支持 M1 的版本。 所以可以在 Docker 虚拟出一个 Linux 环境，跑一下。 （暂时用不到完整的虚拟机） 环境准备 下载安装 Docker Desktop for Mac 就可以了。 简单使用 CLI 方式 使用参考：Memory Leak Testing with Valgrind on macOS using Docker Containers 创建一个文件夹，写一个 Dockerfile 12345FROM ubuntu:16.04 RUN apt-get updateRUN apt-get upgrade -yRUN apt-get install g++ valgrind -y 具体安装什么命令，可以根据需求修改（后面创建好之后也可以使用容器更新镜像）。 在当前目录，打开终端，运行 1$ docker build -t image-name . image-name 是自定义的镜像名称。 创建好之后可以查看镜像 1$ docker images 在 Docker Desktop 中也可以查看。 运行，即使用镜像创建容器 1$ docker run -ti image-name /bin/bash docker run -ti 是基础的交互运行 Docker 镜像的命令； /bin/bash 这个位置是容器要执行的命令，此处是打开命令行。 如果需要挂载目录： 1$ docker run -ti -v host-mount-path:container-mount-path image-name /bin/bash -v 指令用于挂载主机文件到容器中，具体是把主机的 host-mount-path 目录，通过冒号 : 分隔，挂载到容器的 container-mount-path 目录。 例如，要把当前目录挂载到容器的 /home/ 目录，就可以写： 1$ docker run -ti -v $PWD:/home/ image-name /bin/bash Docker Desktop 方式 第一次打开 Docker Desktop，会有一个新手教程。 镜像获取：https://hub.docker.com 搜索镜像： 1$ docker search ubuntu # 搜索镜像 结果如下： 拉取（下载）镜像： 123$ docker pull ubuntu # 下载镜像# 或者指定版本的下载$ docker pull ubuntu:16.04 下载镜像之后在客户端里就可以看到了，打开使用即可。 需要注意的是，创建容器时，挂载本地的目录： 在 Host Path 中填写本地目录，在 Container Path 中填写挂载到的容器中的目录。 从客户端打开命令行之后，输入bash，之后就可以正常使用一些功能，例如记录之前执行的命令、source 命令等。 修改并更新镜像 如果当前镜像的环境有修改，并且需要保存经常使用，可以把当前容器保存为新的镜像。 查看容器的 ID 1$ docker containers ls 会有如下显示： 根据容器创建镜像 1$ docker commit -m=&quot;commit info&quot; -a=&quot;committer name&quot; container-id new-image-name 然后再使用 docker images 就可以查看到新的镜像 new-image-name 了。 命令行进入容器 查看容器的ID 1$ docker ps 打开容器 1$ docker exec -it container-id /bin/bash 容器命名和重命名 创建时命名 1$ docker run -ti --name [容器名称] [镜像名称] /bin/bash 重命名 查看旧名： 1$ docker ps -a 修改容器名： 1$ docker rename [旧容器名] [新容器名] 操作结果如下： 参考 Memory Leak Testing with Valgrind on macOS using Docker Containers docker update_docker 镜像的使用 Docker和宿主机之间共享文件","categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://doreality.xyz/tags/Docker/"}]},{"title":"基于 HMM 的中文分词","slug":"ml/nlp/nlp-hmm","date":"2021-12-21T09:46:15.000Z","updated":"2023-04-07T16:28:04.930Z","comments":true,"path":"posts/6377499.html","link":"","permalink":"https://doreality.xyz/posts/6377499.html","excerpt":"课程：NLP-HMM隐马尔可夫+维特比分词，代码+数据+讲解 源码：GitHub 仓库：nlp-hmm-word-cut","text":"课程：NLP-HMM隐马尔可夫+维特比分词，代码+数据+讲解 源码：GitHub 仓库：nlp-hmm-word-cut 中文分词任务 什么是中文分词 把一句话，切分成词语：（英文天然就分好词了，但中文需要分词） 今天天气真好 = 今天/天气/真好 今天天气真好 = 今天/天气/真/好 「真」和「好」同时出现，是否分开，取决于语料库。 方法 基于规则：基于词典，前向、后向最大匹配，应对新词没法处理 基于统计：HMM、CRF 基于深度学习：BiLSTM+CRF，非常流行，准确率在逐渐提高 为什么要分词 更好理解语义 为了处理更重要的任务 命名实体识别、情感分析、文本分类、语义识别…… （但不是所有任务都需要分词） 应用场景需要 搜索：淘宝、百度…… 语料库 人工标注而来。 每一行是一篇“文章” 每篇文章用空格分开 语料库的准确性，严重影响分词结 理论上，语料库越大越好 标识 每个字都有一个标识（“隐藏状态”），可以根据语料库得到所有标识。 B：词语开始 M：词语中间 E：词语结束 S：单独成词 根据已知状态进行分词，即在 E 和 S 后加入空格。 根据已经分好的词（就是语料库），得到每个字的状态。 根据状态，统计三个矩阵。 根据三个矩阵，可以得到序列，分词结束。 HMM 分词 训练与预测 训练：根据语料库求三个矩阵：初始概率矩阵、转移概率矩阵和发射矩阵。 预测：根据输入的句子，利用上述三个矩阵计算所有路径（每个字有4种可能状态）可能性的概率。再使用维特比算法，从所有可能性得到概率最大的那条路径，在 E 和 S 后加空格即可。 初始、转移、发射矩阵 初始矩阵 统计每一篇文章的第一个字的状态：统计频次，归一化。 M 和 E 为 0. 转移矩阵 当前状态到下一状态的概率：统计频次，归一化。 总共 4 种状态，转移矩阵就是 4 * 4 的矩阵。 行代表当前状态，列代表下一状态。 每一行归一化。有些概率一定是0，例如 B -&gt; B， B -&gt; S 等等。如果出错了可能是代码写错，或者是语料库有问题。 发射矩阵 统计某种状态下，所有字出现的次数（概率） 几种状态就是几行，遍历语料库的所有字，对于每一个字属于某种状态的次数统计。 例如：今作为 B 出现了 1 次。 1&#123; B: &#123; 今 : 1 &#125;&#125; 对每一个状态归一化，分母是该状态出现的总次数。 预测 Start -&gt; 初始矩阵 -&gt; 转移概率 * 发射概率 路径的概率 = 初始概率 * 第一个字的发射概率 * 之后每一个字的（转移概率 * 发射概率） 寻找概率最大的路径。 会有很多（一半）条路径的概率是 0 维特比算法 从众多路径中，快速选出最优路径。 首先找局部最优： 从 Start 到 第一个字的所有路径都要选择。 从 第一个字 转移到 第二个字，每一个状态留一条最优路径。 从 第二个字 转移到 第三个字，每一个状态留一条最优路径。 直到最后一个字，才能找到全局最优。 最后也只保留了状态数（4）条总路径。","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://doreality.xyz/categories/Machine-Learning/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://doreality.xyz/tags/Python/"},{"name":"NLP","slug":"NLP","permalink":"https://doreality.xyz/tags/NLP/"}]},{"title":"macOS 下端口占用问题","slug":"Q&A/mac-port-used-already","date":"2021-12-20T12:16:49.000Z","updated":"2023-04-07T16:06:00.217Z","comments":true,"path":"posts/73881320.html","link":"","permalink":"https://doreality.xyz/posts/73881320.html","excerpt":"使用 Python 做 socket 编程时遇到： OSError: [Errno 48] Address already in use","text":"使用 Python 做 socket 编程时遇到： OSError: [Errno 48] Address already in use 查看占用端口的进程号： 1$ sudo lsof -i:port 杀死进程： 1$ kill PID 有时候不显示，可能是客户端在[CLOSE_WAIT]阶段，一般是等一会儿就好了。 为了避免这种情况，可以“曲线救国”一下，先挂起进程，然后杀死进程。 ctrl + z：挂起进程 jobs -l：可以查看挂起进程 ctrl+ c：终止当前进程","categories":[{"name":"Q&A","slug":"Q-A","permalink":"https://doreality.xyz/categories/Q-A/"}],"tags":[{"name":"macOS","slug":"macOS","permalink":"https://doreality.xyz/tags/macOS/"}]},{"title":"Hexo 报错：Node Sass 版本问题","slug":"Q&A/hexo-node-sass-edition","date":"2021-12-05T09:35:09.000Z","updated":"2023-04-07T16:05:34.705Z","comments":true,"path":"posts/5ed7d52f.html","link":"","permalink":"https://doreality.xyz/posts/5ed7d52f.html","excerpt":"使用 hexo clean 的时候，Sass 报错。","text":"使用 hexo clean 的时候，Sass 报错。 原因可能是重新配置了一些环境里的 node 的版本。 然后 hexo clean 的时候报错： 1Node Sass does not yet support your current environment: OS X Unsupported architecture (arm64) with Node.js 14.x 成功的方法 1$ npm install node-sass@npm:sass 来自 StackOverFlow 的 问题 Node Sass with apple m1, Big Sur and arm64： 失败的方法 直接升级（未解决） 1$ npm install node-sass --dev 重新安装（未解决） 12$ rm -rf node_modules$ npm install","categories":[{"name":"Q&A","slug":"Q-A","permalink":"https://doreality.xyz/categories/Q-A/"}],"tags":[{"name":"macOS","slug":"macOS","permalink":"https://doreality.xyz/tags/macOS/"},{"name":"Node","slug":"Node","permalink":"https://doreality.xyz/tags/Node/"},{"name":"Sass","slug":"Sass","permalink":"https://doreality.xyz/tags/Sass/"}]},{"title":"「JavaScript 网络编程」Express 基本使用","slug":"dev/frontend/js/netpr-express-basic","date":"2021-12-03T07:15:44.000Z","updated":"2023-04-07T16:36:04.505Z","comments":true,"path":"posts/a1b3f005.html","link":"","permalink":"https://doreality.xyz/posts/a1b3f005.html","excerpt":"Node，Express 基本使用方法，介绍 ReSTful API","text":"Node，Express 基本使用方法，介绍 ReSTful API 基本使用 Node Node 是 JavaScript 的运行环境，不同于浏览器，不使用 document 或者 window 对象，但是添加了关于操作系统、文件、网络等内容。 Node 是使用 C++ 封装了 Chrome V8 引擎的客户端，可以执行 JavaScript 程序。 使用 npm 进行包管理，生成 package.json： 123$ npm init# 或者 直接全部默认$ npm init --yes 安装包 123$ npm install package_name# 或者$ npm i package_name 会自动添加到 package.json 的 dependencies 中，并保存在 node_modules 文件夹中。 Semantic Versioning - SemVer 123456&#123; &quot;dependencies&quot;: &#123; &quot;mongoose&quot;: &quot;^4.13.6&quot;, // 4.x, Major.Minor.Patch &quot;underscore&quot;: &quot;~1.8.3&quot; // 1.8.x &#125;&#125; 依赖 1234567891011121314151617181920212223$ npm list$ npm list --depth=0# 查看某个package的依赖$ npm view mongoose$ npm view mongoose dependencies# 查看package的历史版本$ npm view mongoose versions# 查看当前安装的包版本是否过时$ npm outdated# 更新$ npm update # 只更新次版本号和补丁版本$ npm i -g npm-check-updates$ npm-check-updates$ ncu -u # upgrade package.json$ npm i # 开发环境的依赖，不打包到生产环境$ npm i jshint --save-dev 卸载包 123$ npm uninstall mongoose# 或者$ npm un mongoose Express Hello World 创建目录和依赖 12345$ mkdir myapp$ cd myapp$ npm init# entry point 填 app.js，其他全部回车$ npm install express Hello World 在 myapp 目录下创建 app.js，填入内容： 1234567891011const express = require(&#x27;express&#x27;)const app = express()const port = 3000app.get(&#x27;/&#x27;, (req, res) =&gt; &#123; res.send(&#x27;Hello World!&#x27;)&#125;)app.listen(port, () =&gt; &#123; console.log(`Example app listening at http://localhost:$&#123;port&#125;`)&#125;) 运行 1$ node app.js RESTful API http module 使用 node 的 builtin module， http 模块： 12345678910111213const http = require(&#x27;http&#x27;);const server = http.createServer((req, res) =&gt; &#123; if (req.url === &#x27;/&#x27; ) &#123; // ... &#125; if (req.url === &#x27;/api/course&#x27;) &#123; // ... &#125;&#125;);server.listen(3000); RESTful API REST = Representational State Transfer 使用 REST 实现 Http 的 CRUD（Create、Update、Read、Delete）。 例如：http://vidly.com/api/customers 把 customers 看作是一种资源，对于该资源的增删改查都是通过向这个 end point 发送请求完成的。 请求的种类（HTTP METHODS）对应着操作的类型： GET POST PUT DELETE 使用有语义的地址来公开资源，可以使用 HTTP 的规则来对资源操作。 创建目录并安装 express 1234$ mkdir express-demo$ cd express-demo$ npm init --yes$ npm i express 新建 index.js 1234567891011121314151617const express = require(&#x27;express&#x27;);const app = express();// route handler 或者 callback app.get(&#x27;/&#x27;, (req, res) =&gt; &#123; res.send(&#x27;Hello World&#x27;);&#125;);app.get(&#x27;/api/courses&#x27;, (req, res) =&gt; &#123; // 实际要从数据库读出数据并返回 res.send([1, 2, 3]);&#125;);// PORTconst port = process.env.PORT || 3000;app.listen(port, () =&gt; console.log(`Listening on $&#123;port&#125;...`)); 不再使用 if 作为路由，而是通过 app.get() 的方式，这样可以方便归类。 查询某一个数据 12345app.get(&#x27;/api/posts/:year/:month&#x27;, (req, res) =&gt; &#123; res.send(req.params);&#125;);// 访问 /api/posts/2021/12// 返回：&#123;&quot;year&quot;:&quot;2021&quot;,&quot;month&quot;:&quot;12&quot;&#125; query string 12345app.get(&#x27;/api/posts/:year/:month&#x27;, (req, res) =&gt; &#123; res.send(req.query);&#125;);// 访问 /api/posts/2021/12?sortBy=name// 返回：&#123;&quot;sortBy&quot;:&quot;name&quot;&#125; 处理 GET 请求 如果请求一个资源，但是在服务器中没有，应该返回 404 状态码。 cmd + R 刷新，在开发者工具中选择 Network 可看状态码。 123456789101112131415161718const courses = [ &#123; id:1, name: &#x27;course1&#x27; &#125;, &#123; id:2, name: &#x27;course2&#x27; &#125;, &#123; id:3, name: &#x27;course3&#x27; &#125;,];// get all coursesapp.get(&#x27;/api/courses&#x27;, (req, res) =&gt; &#123; // 实际要从数据库读出数据并返回 res.send(courses);&#125;);// get single course app.get(&#x27;/api/courses/:id&#x27;, (req, res) =&gt; &#123; const course = courses.find(c =&gt; c.id === parseInt(req.params.id)); if (!course) return res.status(404).send(&#x27;The course with the given ID was not found.&#x27;); res.send(course);&#125;); 处理 POST 请求 为了向终端发送请求，需要使用 Chrome 的扩展 Postman。 12345678910app.post(&#x27;/api/courses&#x27;, (req, res) =&gt; &#123; // 读取req的消息体，获得新的数据，来创建新的对象 const course = &#123; id: courses.length + 1, name: req.body.name &#125;; courses.push(course); // 惯例，当我们让服务器创建了新的对象或资源，服务器应该在反馈中包含创建的新资源 res.send(course);&#125;); 在 Postman 中发送一个 POST 请求到终端 http://localhost:3000/api/course： 123&#123; &quot;name&quot;: &quot;new course&quot;&#125; 返回： 1234&#123; &quot;id&quot;: 4, &quot;name&quot;: &quot;new course&quot;&#125; 状态码 200 OK。 使用 Joi 进行输入验证 在项目目录中安装 Joi： 1$ npm i joi 在 index.js 中使用： 1234567891011121314151617181920const Joi = require(&#x27;joi&#x27;); // class app.post(&#x27;/api/courses&#x27;, (req, res) =&gt; &#123; const schema = &#123; name: Joi.string().min(3).required() &#125;; const result = Joi.validate(req.body, schema); if (result.error) return res.status(400).send(result.error.details[0].message); // 读取req的消息体，获得新的数据，来创建新的对象 const course = &#123; id: courses.length + 1, name: req.body.name &#125;; courses.push(course); // 惯例，当我们让服务器创建了新的对象或资源，服务器应该在反馈中包含创建的新资源 res.send(course);&#125;); 处理 PUT 请求 进行一些复用： 123456789101112131415161718192021app.put(&#x27;/api/courses/:id&#x27;, (req, res) =&gt; &#123; // Look up the course // if not existing ,return 404 const course = courses.find(c =&gt; c.id === parseInt(req.params.id)); if (!course) return res.status(404).send(&#x27;The course with the given ID was not found.&#x27;); // Validate // If invalid, return 400 - bad request const schema = &#123; name: Joi.string().min(3).required() &#125;; const result = Joi.validate(req.body, schema); if (result.error) return res.status(400).send(result.error.details[0].message); // Update course course.name = req.body.name; // return the updated course res.send(course);&#125;); 处理 DELETE 请求 1234567891011121314app.delete(&#x27;/api/courses/:id&#x27;, (req, res) =&gt; &#123; // Look up the course // Not existing, return 404 const course = courses.find(c =&gt; c.id === parseInt(req.params.id)); if (!course) return res.status(404).send(&#x27;The course with the given ID was not found.&#x27;); // Delete const index = courses.indexOf(course); courses.splice(index, 1); // Return the same course res.send(course);&#125;); 基本路由 https://www.expressjs.com.cn/starter/basic-routing.html 参考资料 关于 package.json ： https://docs.npmjs.com/cli/v8/configuring-npm/package-json","categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doreality.xyz/tags/JavaScript/"},{"name":"Express","slug":"Express","permalink":"https://doreality.xyz/tags/Express/"},{"name":"Node","slug":"Node","permalink":"https://doreality.xyz/tags/Node/"},{"name":"Mongodb","slug":"Mongodb","permalink":"https://doreality.xyz/tags/Mongodb/"}]},{"title":"「JavaScript 网络编程」Vue 入门","slug":"dev/frontend/js/netpr-vue3-basic","date":"2021-12-01T09:02:15.000Z","updated":"2023-04-07T16:10:31.985Z","comments":true,"path":"posts/797f6d09.html","link":"","permalink":"https://doreality.xyz/posts/797f6d09.html","excerpt":"从工具使用入门到建立一个前端应用的 Demo。 「Vue Mastery 课程 —— Intro to Vue 3」 「Vue Mastery 课程 —— Real World Vue 3」","text":"从工具使用入门到建立一个前端应用的 Demo。 「Vue Mastery 课程 —— Intro to Vue 3」 「Vue Mastery 课程 —— Real World Vue 3」 基本使用 CDN 方式使用 Vue 创建 Vue App 1const app = Vue.createApp(&#123;&#125;) &#123;&#125;中，需要传递Options Object（不是可选的optional，而是至少需要一个，即使是空对象） 1234567const app = Vue.createApp(&#123; data() &#123; return&#123; product: &#x27;Socks&#x27; &#125; &#125;&#125;) data()用来返回数据；product是属性，传递给 HTML。 123&lt;div id=&#x27;app&#x27;&gt; &lt;h1&gt;&#123;&#123; product &#125;&#125;&lt;/h1&gt;&lt;/div&gt; &#123;&#123; &#125;&#125;称为mustache syntax，通过它使用 JavaScript 表达式，例如： 12345&lt;p&gt;&#123;&#123; firstName + &#x27; &#x27; + lastName &#125;&#125;&lt;/p&gt;&lt;span&gt;&#123;&#123; clicked ? true : false &#125;&#125;&lt;/span&gt;&lt;div&gt;&#123;&#123; message.method() &#125;&#125;&lt;/div&gt; 引入和挂载 Vue App 12345678910111213141516&lt;head&gt; &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- Body --&gt; &lt;/div&gt; &lt;!-- Import App --&gt; &lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt; &lt;!-- Mount App --&gt; &lt;script&gt; const mountedApp = app.mount(&#x27;#app&#x27;) &lt;/script&gt;&lt;/body&gt; v-bind 动态绑定属性和表达式。当属性值更新了，相应标签的渲染效果也会更新。 12345678const app = Vue.createApp(&#123; data() &#123; return&#123; product: &#x27;Socks&#x27;, image: &#x27;./assets/images/socks_green.jpg&#x27; &#125; &#125;&#125;) 添加image属性。 1&lt;img v-bind:src=&quot;image&quot;&gt; 此处，src为 HTML attribute，image是 JavaScript expression。 通过v-bind，相当于 src=&#123;&#123; image &#125;&#125;。 等价写法： 12345678&lt;img :src=&quot;image&quot;&gt;&lt;!-- 例如 --&gt;&lt;img :alt=&quot;description&quot;&gt;&lt;a :href=&quot;url&quot;&gt;&lt;div :class=&quot;isActive&quot;&gt;&lt;span :style=&quot;isActive&quot;&gt;&lt;span :disabled=&quot;isDisabled&quot;&gt; v-if, v-else, v-show 条件渲染，根据条件判断是否显示标签。 123456789const app = Vue.createApp(&#123; data() &#123; return&#123; product: &#x27;Socks&#x27;, image: &#x27;./assets/images/socks_green.jpg&#x27;, inStock: true &#125; &#125;&#125;) 使用 v-if 和 v-else 12&lt;p v-if=&quot;inStock&quot;&gt;In Stock&lt;/p&gt;&lt;p v-else&gt;Out of Stock&lt;/p&gt; 效果是向 DOM 中添加或者删除元素；可以单独使用 v-if（就是可以不用 v-else)。 使用 v-show 1&lt;p v-show=&quot;inStock&quot;&gt;In Stock&lt;/p&gt; 不会删除元素，会给 &lt;p&gt; 标签添加属性 style=&quot;display: none;。 使用 v-if，v-else-if 和 v-else 123&lt;p v-if=&quot;inventory &gt; 10&quot;&gt;In Stock&lt;/p&gt;&lt;p v-else-if=&quot;inventory &lt;= 10 &amp;&amp; inventory &gt; 0&quot;&gt;Almost sold out!&lt;/p&gt;&lt;p v-else&gt;Out of Stock&lt;/p&gt; v-for 列表渲染，循环。 1234567const app = Vue.createApp(&#123; data() &#123; return&#123; details: [&#x27;50% cotton&#x27;, &#x27;30% wool&#x27;, &#x27;20% polyester&#x27;] &#125; &#125;&#125;) 使用无序列表 &lt;ul&gt; 显示： 123&lt;ul&gt; &lt;li v-for=&quot;detail in details&quot;&gt;&#123;&#123; detail &#125;&#125;&lt;/li&gt;&lt;/ul&gt; key 属性 使用 v-bind 的方式，给每一个 DOM 元素一个 :key，很有用。 12345678910const app = Vue.createApp(&#123; data() &#123; return&#123; variants: [ &#123; id: 2234, color: &#x27;green&#x27; &#125;, &#123; id: 2235, color: &#x27;blue&#x27; &#125;, ] &#125; &#125;&#125;) 遍历或者抓取其中一个元素的时候，可以使用 :key 属性，类似于 id。 1&lt;div v-for=&quot;variant in variants&quot; :key=&quot;variant.id&quot;&gt;&#123;&#123; variant.color &#125;&#125;&lt;/div&gt; v-on 监听事件。 1234567const app = Vue.createApp(&#123; data() &#123; return&#123; cart: 0 &#125; &#125;&#125;) v-on: (== @) + 监听的事件 click + 事件触发时做 cart += 1 12&lt;div class=&quot;cart&quot;&gt;Cart(&#123;&#123; cart &#125;&#125;)&lt;/div&gt;&lt;button class=&quot;button&quot; v-on:click=&quot;cart += 1&quot;&gt;Add to Cart&lt;/button&gt; 当处理逻辑复杂时，可以使用函数封装： 123456789101112const app = Vue.createApp(&#123; data() &#123; return&#123; cart: 0 &#125; &#125;, methods: &#123; addToCart() &#123; this.cart += 1 &#125; &#125;&#125;) 1&lt;button class=&quot;button&quot; v-on:click=&quot;addToCart&quot;&gt;Add to Cart&lt;/button&gt; 等价写法：v-on:click == @click 1&lt;button class=&quot;button&quot; @click=&quot;addToCart&quot;&gt;Add to Cart&lt;/button&gt; hover 的 Vue 版本的事件：@mouseover class 和 style 使用 v-bind 动态渲染。 1&lt;div :style=&quot; &#123; backgroundColor = variant.color &#125;&quot;&gt;&lt;/div&gt; 对于每个 variant，对应设置背景颜色。 Camel-case：&#123; backgroundColor = variant.color &#125; 是一个 JavaScript 对象，在此处是 style object。 Kebab-case：&#123; 'background-color': variant.color &#125; 不使用 inline： 1&lt;div :style=&quot;styles&quot;&gt;&lt;/div&gt; 在 data 对象中创建一个对象，用于指代。 12345678data() &#123; return &#123; styles: &#123; color: &#x27;red&#x27;, fontSize: &#x27;14px&#x27; &#125; &#125;&#125; 等价于：&lt;div style=&quot;color: red; font-size: 14px&quot;&gt;&lt;/div&gt; 对 class 进行渲染： 1&lt;div :class=&quot;&#123; disabledButton: !inStock &#125;&quot;&gt;&lt;/div&gt; 给标签添加多个 class 属性 1234&lt;div class=&quot;color-circle&quot; :class=&quot;&#123; &#x27;active&#x27; : activeClass &#125;&quot;&gt;&lt;/div&gt; 如果 activeClass 是 true，那么最终结果：class=&quot;color-circle active&quot;，此处 active是类名 可以使用三目操作符 1234&lt;div class=&quot;color-circle&quot; :class=&quot; [isActive ? &#x27;active&#x27; : &#x27;&#x27; ]&quot;&gt;&lt;/div&gt; 如果 isActive 是 true，结果同上。 Computed Property 对于复杂逻辑的响应，例如，模板中需要显示好几个 data() 和 method() 的属性通过计算之后的结果，直接写在模板中会很复杂，例如： 1&lt;h1&gt;&#123;&#123; brand + &#x27; &#x27; + product &#125;&#125;&lt;/h1&gt; 其中使用的表达式已经不是声明性的了，变得复杂，可以使用计算属性： 12345678910111213const app = Vue.createApp(&#123; data() &#123; return &#123; brand: &#x27;Vue Mastery&#x27;, product: &#x27;Socks&#x27;, &#125; &#125;, computed: &#123; title() &#123; return this.brand + &#x27; &#x27; + this.product &#125; &#125;&#125;) 这样就可以直接使用 title 这个计算属性： 1&lt;h1&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt; 当 brand 或者 product 更新的时候，title 也会动态更新。 好处是，不修改的时候，使用的是缓存，需要修改的时候才会重新读取。 Components &amp; Props 复用的模板可以封装成组件（Component），使用 Props 属性向组件中传递数据。 12345678910111213app.component(&#x27;example-component&#x27;, &#123; template: /*html*/ `html here`, data() &#123; return &#123; &#125; &#125;, methods: &#123; &#125;, computed: &#123; &#125;&#125;) 在模板前写 /*html*/ 是为了使用 VScode 的插件 es6-string-html，可以按照 HTML 语法高光显示。 然后在主 HTML 中调用： 1234&lt;example-component&gt;&lt;/example-component&gt;&lt;!-- Import Component --&gt;&lt;script src=&quot;./components/example-component.js&quot;&gt;&lt;/script&gt; 一个组件可以多次调用。 如果父模板需要给组件传数据（即组件要接收外来数据），可以给模板增加 Props，使用其中定义的属性： 1234567891011app.component(&#x27;example-component&#x27;, &#123; props: &#123; someprop: &#123; type: Boolean, required: true &#125; &#125;, template : `` ...&#125;) 这样，就给 &lt;example-component&gt; 这个标签，添加了属性名 sompeprop，只需要使用 v-bind 方法绑定即可。 1&lt;example-component :someprop=&quot;propvalue&quot;&gt;&lt;/example-component&gt; 可以插入到主 HTML 中或者另一个组件中，propvalue 是该模板或者组件的一个参数，data 类型或者 computed 类型。 组件事件 当组件中，发生了事件，怎么通知给别的组件或者父模板？ 激活和监听：在组件中，发生了事件，使用 this.$emit('an-event')，在组件属性中监听事件 @an-event=&quot;toSolve&quot; 123456789app.component(&#x27;example-component&#x27;, &#123; template: `&lt;button @click=&quot;event&quot;&gt;&lt;/button&gt;`, methods: &#123; event() &#123; this.$emit(&#x27;an-event&#x27;) &#125; &#125;&#125;) 在使用该组件的地方： 1&lt;example-component @an-event=&quot;toSolve&quot;&gt;&lt;/example-component&gt; 然后，在 js 中： 1234567const app = Vue.createApp(&#123; methods: &#123; toSolve() &#123; // do something to solve the event &#125; &#125;&#125;) Forms 使用 V-model 进行模板和数据的双向绑定。 template 中，对输入框使用 v-model 绑定： 123&lt;input id=&quot;name&quot; v-model=&quot;name&quot;&gt;&lt;textarea id=&quot;review&quot; v-model=&quot;review&quot;&gt;&lt;/textarea&gt;&lt;select id=&quot;rating&quot; v-model.number=&quot;rating&quot;&gt; 在 data() 中声明绑定的变量： 1234567data() &#123; return &#123; name: &#x27;&#x27;, review: &#x27;&#x27;, rating: null &#125;&#125; 在 &lt;form&gt; 使用 submit.prevent 避免在提交表单时刷新浏览器： 123&lt;form class=&quot;review-form&quot; @submit.prevent=&quot;onSubmit&quot;&gt; &lt;input class=&quot;button&quot; type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/form&gt; onSubmit 在 methods 中实现即可。 123456789101112131415161718methods: &#123; onSubmit() &#123; if (this.name === &#x27;&#x27; || this.review === &#x27;&#x27; || this.rating === null) &#123; alert(&#x27;Review is incomplete. Please fill out every field.&#x27;) return &#125; let productReview = &#123; name: this.name, review: this.review, rating: this.rating &#125; this.$emit(&#x27;review-submitted&#x27;, productReview) this.name = &#x27;&#x27; this.review = &#x27;&#x27; this.rating = null &#125;&#125; 在其他模板中引用 &lt;review-form @review-submitted=&quot;addReview&quot;&gt;，在引用的组件中实现 addReview 方法。 Vue-CLI + Element Plus el-input 无法输入 去掉边框 怎么设置全局背景色 uuid 滚动条 绑定回车","categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://doreality.xyz/tags/Vue/"},{"name":"Vuex","slug":"Vuex","permalink":"https://doreality.xyz/tags/Vuex/"},{"name":"Element UI","slug":"Element-UI","permalink":"https://doreality.xyz/tags/Element-UI/"}]},{"title":"「JavaScript 网络编程」搭建环境","slug":"dev/frontend/js/netpr-vue-express-environment","date":"2021-11-29T05:38:55.000Z","updated":"2023-04-07T16:36:12.952Z","comments":true,"path":"posts/8477f2ec.html","link":"","permalink":"https://doreality.xyz/posts/8477f2ec.html","excerpt":"JavaScript 网络程序设计的 Lab 简介和开发环境搭建。 From 2021《网络程序设计》","text":"JavaScript 网络程序设计的 Lab 简介和开发环境搭建。 From 2021《网络程序设计》 Lab 介绍 先学习 Web 网络编程的热门技术，然后选做一个课程设计：基于Web的聊天室系统设计与实现。 技术要点 Vue 组件化响应式编程 Express（node.js） 异步调用 Ajax Session Websocket 开发流程 环境搭建（Lab + Pro） 工具入门（Lab） Demo 实现（Lab） 需求分析与设计（Pro） 代码实现（Pro） 测试（Pro） 开发环境：macOS 12（Apple Silicon） 开始之前的准备： 主机安装了最新版的 Node.js，可以通过命令行使用npm工具 使用 VScode 作为开发环境 安装插件 es6-string-html 使用 Chrome 作为运行调试环境 使用 git 进行版本管理 前端环境 建立 Vue 的开发环境，需要使用如下工具： Vue-CLI Webpack Vuex Element UI Vue Vue 的官方文档给出了几种安装使用方法（CDN、下载自托管、npm下载、Vue-CLI等）。 这里记录两种最常用的使用方法： CDN 通过&lt;script&gt;在 HTML 中引用，是最简单的方式： 1&lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt; 对于生产环境，推荐链接到明确版本号和构建文件。 Vue-CLI CLI（Command Line Interface」）是命令行工具，Vue-CLI 是官方提供的「为单页面应用 (SPA) 快速搭建繁杂的脚手架」。 安装： 123$ npm install -g @vue/cli# OR$ yarn global add @vue/cli 创建一个项目： 123$ vue create my-project# OR$ vue ui 运行一个项目 1$ vue serve Webpack 打包工具。 安装： 1$ npm install -g webpack Vuex Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。 它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 CDN https://unpkg.com/vuex@4 或者指定版本：https://unpkg.com/vuex@4.0.0/dist/vuex.global.js 使用时，在 Vue 后直接引用即可 12345&lt;script src=&quot;/path/to/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/path/to/vuex.js&quot;&gt;&lt;/script&gt;&lt;!-- 例如都使用 unpkg 的版本 --&gt;&lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://unpkg.com/vuex@4&quot;&gt;&lt;/script&gt; npm 在项目的目录下安装： 1$ npm install vuex@next --save Element+ Element Plus 是基于 Vue 3 的桌面端组件库。 安装： npm 1$ npm install element-plus --save unpkg CDN 12345678&lt;head&gt; &lt;!-- 导入样式 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;//unpkg.com/element-plus/dist/index.css&quot; /&gt; &lt;!-- 导入 Vue 3 --&gt; &lt;script src=&quot;//unpkg.com/vue@next&quot;&gt;&lt;/script&gt; &lt;!-- 导入组件库 --&gt; &lt;script src=&quot;//unpkg.com/element-plus&quot;&gt;&lt;/script&gt;&lt;/head&gt; 在 Vue-CLI 中使用： 123$ vue create my-app$ cd my-app$ vue add element-plus 后端环境 Express mongodb mysql Express 通过 npm 安装 在本地任意路径下，新建一个文件夹 myapp (任意名称）： 12$ mkdir myapp$ cd myapp 使用 npm init 命令，创建 package.json，用于配置依赖。 1$ npm init 命令执行后，会提示输入若干参数（应用的名称、版本等信息），根据情况填写即可。 注意其中一个参数 entry point，它的值是当前 App 的入口文件（需要自己手动创建）。 可以使用默认的 index.js，或者根据实际情况使用相应的。 然后在 myapp 目录下，安装 Express： 保存到依赖列表 1$ npm install express --save 临时安装 1$ npm install express --no-save Express 应用程序生成器 生成器工具是 express-generator，可以快速创建一个应用的蓝本。 安装： 1$ npm install -g express-generator 创建应用（目录名为 myapp，路径为当前目录下）： 1$ express ./myapp 之后，会自动创建一个规范的目录结构和相关依赖。 进入 myapp 目录，执行命令启动应用： 12$ cd myapp$ DEBUG=myapp:* npm start 在浏览器中打开 http://localhost:3000/ 就可以查看该应用了。 MongoDB MongoDB 检查x-code 1$ xcode-select --install 安装包管理器 Homebrew 使用 brew 安装 mongodb 12$ brew tap mongodb/brew$ brew install mongodb-community@5.0 安装失败可能是由于某些依赖需要手动安装： c-ares：brew install c-ares libnghttp2：brew intall libnghttp2 ca-certificates： node@14 123$ echo &#x27;export PATH=&quot;/opt/homebrew/opt/node@14/bin:$PATH&quot;&#x27; &gt;&gt; ~/.zshrc$ export LDFLAGS=&quot;-L/opt/homebrew/opt/node@14/lib&quot;$ export CPPFLAGS=&quot;-I/opt/homebrew/opt/node@14/include&quot; mongosh 成功安装： 12==&gt; Summary🍺 /opt/homebrew/Cellar/mongodb-community/5.0.4: 11 files, 181.4MB, built in 2 seconds 运行 注意： 因为某种原因，安装的是默认的x86版本（安装时也提醒了不兼容 macOS 12），在开启服务前使用 Roseta： 1$ softwareupdate --install-rosetta （推荐用法） 作为服务运行：As a macOS Service 123456$ brew services start mongodb-community@5.0==&gt; Successfully started `mongodb-community` (label: homebrew.mxcl.mongodb-commu$ brew services stop mongodb-community@5.0Stopping `mongodb-community`... (might take a while)==&gt; Successfully stopped `mongodb-community` (label: homebrew.mxcl.mongodb-commu 通过 brew services list 可以查看是否开启成功： 123$ brew services listName Status User Plistmongodb-community started doreality /Users/doreality/Library/LaunchAgents/homebrew.mxcl.mongodb-community.plist 作为后台进程运行：As a background process on Intel processors： 1$ mongod --config /usr/local/etc/mongod.conf --fork on Apple M1 processors: 1$ mongod --config /opt/homebrew/etc/mongod.conf --fork MongoDB Compass MongoDB 的 GUI 应用程序。 在下载页面安装需要的版本： 1.29.5 OS X 64bit dmg mongoose 参考资料 http://nodejs.cn https://v3.cn.vuejs.org https://www.vuemastery.com/courses/intro-to-vue-3/intro-to-vue3 https://element-plus.gitee.io/zh-CN/guide/design.html https://www.expressjs.com.cn https://www.mongodb.com https://webpack.docschina.org","categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doreality.xyz/tags/JavaScript/"},{"name":"Express","slug":"Express","permalink":"https://doreality.xyz/tags/Express/"},{"name":"Vue","slug":"Vue","permalink":"https://doreality.xyz/tags/Vue/"}]},{"title":"Android Kotlin 项目构建报错：No native library","slug":"Q&A/android-kotlin-error-no-native","date":"2021-11-08T06:32:07.000Z","updated":"2023-04-07T16:24:55.424Z","comments":true,"path":"posts/8eb87749.html","link":"","permalink":"https://doreality.xyz/posts/8eb87749.html","excerpt":"在高版本 SDK 的 Android Studio 中，构建 Kotlin 的项目的常见错误。","text":"在高版本 SDK 的 Android Studio 中，构建 Kotlin 的项目的常见错误。 错误 1：No native library 这个错误是说： 1Caused by: java.lang.Exception: No native library is found for os.name&#x3D;Mac and os.arch&#x3D;aarch64. path&#x3D;&#x2F;org&#x2F;sqlite&#x2F;native&#x2F;Mac&#x2F;aarch64 总之就是找不到库了。 解决方案 点击查看解决方案： 在build.gradle(Project)中添加 1234567allprojects &#123; configurations.all &#123; resolutionStrategy &#123; force &#39;org.xerial:sqlite-jdbc:3.34.0&#39; &#125; &#125;&#125; 错误 2：使用 intent-filter，无法运行 如果当前的 TargetSDK 版本高的话，有可能以前的项目无法运行。 原因是，高版本（我是TargetSDK用的最新的版本，31），Activity 需要一个新的参数。 具体设置： 在 AndroidManifest.xml 中，对使用了 intent-filter 的 Activity 增加一条属性设置： android:exported=&quot;true&quot;","categories":[{"name":"Q&A","slug":"Q-A","permalink":"https://doreality.xyz/categories/Q-A/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://doreality.xyz/tags/Kotlin/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"https://doreality.xyz/tags/Android-Studio/"}]},{"title":"「讲座」开源技术在机器学习中的应用","slug":"ml/ml-scikit-learn","date":"2021-11-01T06:16:21.000Z","updated":"2023-04-07T16:39:21.854Z","comments":true,"path":"posts/c04c3a43.html","link":"","permalink":"https://doreality.xyz/posts/c04c3a43.html","excerpt":"讲座来自IBM SPSS公司。 简单介绍机器学习的概念、常用的流程和指标 开源Scikit-learn的介绍和使用方法 高维数据可视化的介绍 行业前辈的经验分享","text":"讲座来自IBM SPSS公司。 简单介绍机器学习的概念、常用的流程和指标 开源Scikit-learn的介绍和使用方法 高维数据可视化的介绍 行业前辈的经验分享 What is machine learning? Data Model Predict KNN： K Nearest Neighbor 物以类聚，人以群分。 K-Means 无监督学习，根据均值 分类——决策 Scikit-learn 语言 Python R 软件 MATLAB Octave Forge：开源 Python中的： 数据处理库 numpy scipy pandas 图形化展示 matplotlib scikit-learn cheet sheet Evaluation 常见指标 ​ 举例：雷达兵 混淆矩阵 混淆矩阵衍生出的评价指标 阿里天池：F1score Pics from Wiki：Confusion Matrix / ROC 可信度 ROC/AUC Why Should I Trust You？ LIME 举例：分类结果正确，但是分类的原因和原本设想的不同 不光是指标，还要关注具体分类的原因 Visualize High Dimension Datasets Agenda 高维信息投射到低维空间，肯定会丢掉高维坐标的信息，但是还想保留用来比较的相似信息，很难。 把一个手写字符，分成 8 * 8 个field 通过算法可以高维降低到二维，很好地分类 为了增强可信度，除了 LIME，可以让过程变得透明，可视化 Machine learning needs more transparency 网站：https://distll.pub Experience 对于学生：编程 + 算法 + 行业知识 既懂编程又会算法——降维打击，行业知识：实际收益 数学统计算法、数学分析课程：加强竞争能力 工作时，学习行业的知识，在行业里产生价值，学以致用 工作经验 准时 &gt; 提早：不是提前多久完成，就算好了 除了编程，还要测试（性能测试、压力测试）、翻译、法律风险 许多步骤已经按照日程安排 提早是没有意义的，准时按质提交 项目有时间、资源、人员能力的压力 不能一直追求完美，影响自己的生活 会有各种限制，所以相对最优 项目失败很可能是项目管理 一两个加班 大多数人加班：项目管理出现问题 复盘 如果回到最初，项目管理是否能够更好 平衡 Work Balance 在工作时间，把工作完成 不要把工作带回家，不要让工作称为生活的全部 勇于接纳 努力学好基础知识 创造更美好的未来","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://doreality.xyz/categories/Machine-Learning/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://doreality.xyz/tags/Python/"},{"name":"Scikit-learn","slug":"Scikit-learn","permalink":"https://doreality.xyz/tags/Scikit-learn/"}]},{"title":"Git 分支（三）","slug":"git/git-branch-3","date":"2021-10-30T09:57:23.000Z","updated":"2023-04-07T16:29:39.233Z","comments":true,"path":"posts/476d1e25.html","link":"","permalink":"https://doreality.xyz/posts/476d1e25.html","excerpt":"前面学习了下载远程仓库（clone）、下载最新更新（fetch）并同步（pull）、上传更新并同步（push）这些命令的缺省用法。 那么 o/main 和 main 到底有什么关系？为什么 git clone 会有本地分支和远程分支，为什么可以同步更新？ 还有，使用 GitHub 的时候，那些 push 后面加的参数是什么意思？ 这篇继续学习神奇的网站，最后一点内容。","text":"前面学习了下载远程仓库（clone）、下载最新更新（fetch）并同步（pull）、上传更新并同步（push）这些命令的缺省用法。 那么 o/main 和 main 到底有什么关系？为什么 git clone 会有本地分支和远程分支，为什么可以同步更新？ 还有，使用 GitHub 的时候，那些 push 后面加的参数是什么意思？ 这篇继续学习神奇的网站，最后一点内容。 远程跟踪分支 main 和 o/main 的关联关系是由分支的“remote tracking”属性决定的。main 被设定为跟踪 o/main —— 这意味着为 main 分支指定了推送的目的地以及拉取后合并的目标。 当你克隆时，Git 会为远程仓库中的每个分支在本地仓库中创建一个远程分支（比如 o/main）。然后再创建一个跟踪远程仓库中活动分支的本地分支，默认情况下这个本地分支会被命名为 main。 克隆完成后，你会得到一个本地分支（如果没有这个本地分支的话，你的目录就是“空白”的），但是可以查看远程仓库中所有的分支（如果你好奇心很强的话）。这样做对于本地仓库和远程仓库来说，都是最佳选择。 pull 操作时, 提交记录会被先下载到 o/main 上，之后再合并到本地的 main 分支。 push 操作时, 我们把工作从 main 推到远程仓库中的 main 分支(同时会更新远程分支 o/main) 。 两种方式，指定分支去跟踪远程分支： 方法一：git checkout -b git checkout -b totallyNotMain o/main 创建一个名为 totallyNotMain 的分支，它跟踪远程分支 o/main 方法二： git branch -u git branch -u o/main foo 让 foo 分支跟踪 o/main git branch -u o/main 让当前分支跟踪 o/main 有了远程跟踪分支的概念，就可以解释之前的 push、fetch、pull 的缺省参数了。 Git Push 分支同名 语法：git push &lt;remote&gt; &lt;place&gt; 示例：git push origin main 切到本地仓库中的 main 分支，获取所有的提交 再到远程仓库 origin 中找到 main 分支 将远程仓库中没有的提交记录都添加上去 注意： 通过 &lt;place&gt;，就是提交记录来自 &lt;place&gt;，并且要提交到远程仓库的 &lt;place&gt; 指定 &lt;place&gt;，可以忽略当前的检出分支的属性。 分支不同名 语法：git push &lt;remote&gt; &lt;source&gt;:&lt;destination&gt; 示例： git push origin foo:main 把本地仓库中的 foo 分支所有更新，提交到远程仓库中的 main 分支 git push origin foo^:main 把本地仓库中的 foo 分支的父提交节点所有更新，提交到远程仓库中的 main 分支 git push origin main:newBranch 把本地仓库中的 main 分支的父提交节点所有更新，提交到远程仓库中的新创建的 newBranch 分支 Git Fetch 参数缺省：git fetch，下载所有更新。 分支同名 语法：git fetch &lt;remote&gt; &lt;place&gt; 示例：git fetch origin foo 下载了远程仓库中 foo 分支中的最新提交记录 并更新了 o/foo 分支不同名 语法：git fetch &lt;remote&gt; &lt;source&gt;:&lt;destination&gt; 示例：git fetch origin foo~1:bar 将 foo~1 解析成一个 origin 仓库的位置，然后将那些提交记录下载到了本地的 bar 分支（一个本地分支）上。 注意由于指定了目标分支，foo 和 o/foo 都没有被更新。 注意： 不能在当前检出分支使用。 没有 source 的 source push &lt;source&gt; 部分留空，可以用来删除远程仓库的分支。 示例：git push origin :foo 通过给 push 传空值 source，删除远程仓库中的 foo 分支，远程分支 o/foo 也没了。 fetch &lt;source&gt; 部分留空，可以用来在本地仓库创建分支。 示例：git fetch origin :bar 在本地创建一个 bar 分支 Git Pull git pull origin foo == git fetch origin foo; git merge o/foo 通过 foo 更新 o/foo o/foo合并到 当前检出分支 git pull origin bar~1:bugFix == git fetch origin bar~1:bugFix; git merge bugFix 在本地创建 bugFix的分支 从远程仓库中的 bar~1 分支中下载提交记录，并合并到 bugFix 然后再 merge 到当前检出分支上 git pull 唯一关注的是提交最终合并到哪里（也就是为 git fetch 所提供的 &lt;destination&gt; 参数） 好了，这套教程走了一遍。 第一遍的学习最难，简直就是教程复制机器，还得多用！用！用！ Proactice makes perfect，加油。","categories":[{"name":"Git","slug":"Git","permalink":"https://doreality.xyz/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://doreality.xyz/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"https://doreality.xyz/tags/GitHub/"}]},{"title":"Git 分支（二）","slug":"git/git-branch-2","date":"2021-10-21T16:04:01.000Z","updated":"2023-04-07T16:29:33.542Z","comments":true,"path":"posts/a73bd77.html","link":"","permalink":"https://doreality.xyz/posts/a73bd77.html","excerpt":"根据上一篇提到的教程，学习一下第二部分：远程仓库。 学习的内容一多起来，就发现好难管理，而且容易到处新建，到处分类。快点掌握远程仓库的用法吧！ 大喊一句：当然要CLI！","text":"根据上一篇提到的教程，学习一下第二部分：远程仓库。 学习的内容一多起来，就发现好难管理，而且容易到处新建，到处分类。快点掌握远程仓库的用法吧！ 大喊一句：当然要CLI！ 一、创建远程仓库 1$git clone 在本地创建一个远程仓库的拷贝。 在任意一个要保存这个仓库的目录下 git clone，会出现仓库的文件夹，同时会有两个分支：本地分支 main 和远程分支 o/main。 远程仓库的默认名字是 origin，常用缩写 o 表示。 二、远程分支 远程分支反映了在你最后一次与远程仓库通信时，远程仓库的状态。 远程分支是使用 git clone 后，在本地仓库出现的分支。 命名方式：&lt;remote name&gt;/&lt;branch name&gt;。 如果分支名字为 main，那么远程分支就是 origin/main，常用缩写 o/main 表示。 远程分支的特点： 对远程分支检出（git checkout o/main），则会自动进入 HEAD 分离状态。 这个时候添加提交，远程分支 o/main 并不会移动到新的提交上，因为要和远程仓库中相应的分支同步更新。 注意：本地分支 main 与此无关，在 main 上提交后，分支指针保持正常移动。 三、从远程仓库获取更新 当我们从远程仓库获取数据时，远程分支也会更新，以反映最新的远程仓库。 1$git fetch 把远程仓库 origin 的分支 main 中有，而本地仓库的远程分支 origin/main 中没有的提交下载下来，并且更新远程分支。 通常通过互联网（使用 http:// 或 git:// 协议）与远程仓库通信。 简单说，这条命令做了两件事： 1. 从远程仓库下载本地仓库缺失的提交记录 2. 更新远程分支指针 o/main 这条命令没有做的事情： 1. 没有同步更新本地分支 main 2. 没有同步更新本地仓库和远程仓库 origin 再简单点说：git fetch 仅仅把更新下载到了 o/main 中，没有对 main 做任何操作。 四、合并更新到本地分支 两步走：git fetch + 任意合并分支指令 第一步，获取远程仓库的更新，同步远程分支：git fetch 第二步，把本地分支和远程分支同步到远程分支（检出 main）（任一条即可）： git merge o/main git rebase o/main git cherry-pick o/main 等等 一步到位：git pull 一步下载更新，并同步更新本地分支。 git pull 等价于 git fetch + git merge o/main git pull --rebase 等价于 git fetch + git rebase o/main 五、上传到远程仓库并合并 git push 不带任何参数时的行为与 Git 的一个名为 push.default 的配置有关。 它的默认值取决于你正使用的 Git 的版本，但是在教程中我们使用的是 upstream。 这没什么太大的影响，但是在你的项目中进行推送之前，最好检查一下这个配置。 使用命令：git push 把本地分支main的更新提交到远程仓库 更新远程仓库的分支 同时远程分支o/main也更新到本地分支main的位置 就是说，所有的分支都同步了。 六、偏离的历史提交 无法git push：本地的工作基于旧的提交，Git 会拒绝你直接推送到远程仓库。 方法：让本地的新工作，和远程仓库的更新，合并，再提交。 git fetch -&gt; git rebase o/main -&gt; git push git rebase 让本地更新移到了最新的工作记录下 git fetch -&gt; git merge o/main -&gt; git push git merge 创建新的提交，包含了本地更新和远程仓库最新的工作记录 git pull --rebase -&gt; git push git pull -&gt; git push 总之，就是要把远程仓库的最新情况下载下来，把自己的更新和最新的合并，然后才能再发布到远程仓库。 七、远程服务器拒绝 ! [远程服务器拒绝] main -&gt; main (TF402455: 不允许推送(push)这个分支; 你必须使用pull request来更新这个分支.) 在一个大的项目里，main可能会被锁定。 正确做法： 创建一个新的分支 git push 提交Pull Request 如果忘记创建分支，直接提交，就会卡住，回退解决： 回退：git reset HEAD^ / git reset C1 （C1 是 o/main 所指节点） 创建新分支：git checkout -b feature C2 提交：git push 八、合并特性分支（rebase） 特性分支是指为一个特定的需求/任务/缺陷创建的分支，在其上完成相应开发后，一般会把它合并到集成/发布分支，与其他改动(若有)一起集成并最终发布。 12345$git checkout main # 1. 进入当前分支 main$git rebase feature1 # 2. 将特性分支集成到 main 上$git rebase feature2$git pull --rebase # 3. 将更新 rebase 到远程分支到最新提交记录$git push # 4. 推送到远程仓库 Tips：因为 rebase 是在一条线上不断更新，所以最后一步 rebase 一定是要 rebase 到远程仓库的最新记录。 九、合并特性分支（merge） 在开发社区里，有许多关于 merge 与 rebase 的讨论。以下是关于 rebase 的优缺点： 优点: Rebase 使你的提交树变得很干净, 所有的提交都在一条线上 缺点: Rebase 修改了提交树的历史 一些开发人员喜欢保留提交历史，因此更偏爱 merge。 而其他人可能更喜欢干净的提交树，于是偏爱 rebase。 使用git merge完成合并特性分支： 12345$git checkout main # 1. 进入 main 分支$git pull # 2. 获取远程更新$git merge side1 # 3. 将特性分支合并到 main$git merge side2$git push # 4. 推送并更新远程仓库 Tips：merge 需要父节点，所以一定要注意，在祖先节点里包含远程仓库的最新纪录。","categories":[{"name":"Git","slug":"Git","permalink":"https://doreality.xyz/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://doreality.xyz/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"https://doreality.xyz/tags/GitHub/"}]},{"title":"Git 分支（一）","slug":"git/git-branch-1","date":"2021-10-17T15:49:59.000Z","updated":"2023-04-07T16:29:36.412Z","comments":true,"path":"posts/e01b0c7d.html","link":"","permalink":"https://doreality.xyz/posts/e01b0c7d.html","excerpt":"发现了一个神奇的网站，可以图形化交互式学习 Git。 趁此机会，好好学习了一下关于分支操作的命令～ 重点： 简单的分支操作：创建、跳转、合并 在分支上前进和后退 修改提交树的结构 高级技巧","text":"发现了一个神奇的网站，可以图形化交互式学习 Git。 趁此机会，好好学习了一下关于分支操作的命令～ 重点： 简单的分支操作：创建、跳转、合并 在分支上前进和后退 修改提交树的结构 高级技巧 早分支，早享受。 基础篇 Git Commit Git 仓库中的提交记录保存的是你的目录下所有文件的快照，就像是把整个目录复制。 它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。 Git 还保存了提交的历史记录。把提交记录看作是项目的快照。提交记录非常轻量，可以快速地在这些提交记录之间切换。 使用命令：git commit 表示从父节点的记录更新了东西，变成了新节点。 一般需要附带选项 -m &quot;comment&quot;，对新的提交记录进行简要注释。 高级篇 移动提交记录 技巧杂项 高级操作 git branch git branch -m newname git branch -f somewhere git checkout somebranchname git merge git rebase 更多学习 a simple git branching model OneFlow – a Git branching model and workflow","categories":[{"name":"Git","slug":"Git","permalink":"https://doreality.xyz/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://doreality.xyz/tags/Git/"}]},{"title":"Python 根据源码生成类图","slug":"dev/backend/python/python-code-generate-uml-class-package-graph","date":"2021-10-13T14:58:25.000Z","updated":"2023-04-07T16:37:38.059Z","comments":true,"path":"posts/e471ba7e.html","link":"","permalink":"https://doreality.xyz/posts/e471ba7e.html","excerpt":"","text":"Pyreverse 首先安装graphviz，用于绘图 pyreverse能方便的生成uml类图，pylint里自带了pyreverse这个工具 pip install pylint 使用 pyreverse -ASmy -o esp -p _后缀 目录/ 参考：python代码自动生成类图_python逆向工程：通过代码生成类图 PyCharm 在 PyCharm 中，右键点击想分析的模块文件，或者在编辑器中右键，选择Diagrams-&gt;Show Diagrams，就可以生成当前代码的类图。","categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://doreality.xyz/tags/Python/"},{"name":"PyCharm","slug":"PyCharm","permalink":"https://doreality.xyz/tags/PyCharm/"},{"name":"UML","slug":"UML","permalink":"https://doreality.xyz/tags/UML/"}]},{"title":"Android Studio SDK 配置","slug":"dev/app/Android/Android Studio中SDK配置","date":"2021-10-10T08:54:00.000Z","updated":"2023-04-07T16:36:42.371Z","comments":true,"path":"posts/5cd6b5b7.html","link":"","permalink":"https://doreality.xyz/posts/5cd6b5b7.html","excerpt":"刚开始学习 Android 开发，比较迷惑。不想安装太多SDK，还有想知道各个版本的SDK的区别，就了解了一下。 最后结论就是，M1 的 macOS，看来最低版本的 SDK 只能是 7.0 了，因为从 7.0 才开始有ARM64的支持。","text":"刚开始学习 Android 开发，比较迷惑。不想安装太多SDK，还有想知道各个版本的SDK的区别，就了解了一下。 最后结论就是，M1 的 macOS，看来最低版本的 SDK 只能是 7.0 了，因为从 7.0 才开始有ARM64的支持。 SDK Platform 看官方手册中的关于SDK Platform： 对于每个 SDK Platform 版本，必须至少安装一下三个选项： Android SDK Platform：必须下载 System Image：下载对应自己电脑体系结构的版本即可（至少要有一个） Sources for Android：Platform 的源代码。在调试时可能会显示其中的代码行。 SDK Tools 官方手册中关于SDK Tools： 一些必要的工具，每个版本都向后兼容，所以只需要下载安装一个最新的即可。 配置命令行 aapt aapt 是 SDK Tools 中的一个工具，用于解析应用的资源文件，并翻译成R.java。 找到 SDK 所在的路径 Mac环境下，安装过 Android Studio 并进行上述配置后，SDK的目录如下： 1$ cd /Users/your-username/Library/Android/sdk your-username替换为自己实际的用户名即可。 查看 build-tools 版本 在 SDK 目录下，执行如下： 1234$ ls$ cd build-tools$ ls$ cd 31.0.0 #就是上面在 Android Studio 中配置的 SDK Tools 版本 在此目录下就可以看到aapt工具了。此时，执行pwd，可以打印出当前路径。 回到用户目录，配置Shell 如果是用的 Mac 自带的 bash，打开~/.bash_profile： 12$ cd ~$ vi .bash_profile 如果是使用的 zsh，打开~/.zshrc： 12$ cd ~$ vi .zshrc 之后，在打开的文件中，加入以下内容： 123456789# Android aaptAAPT_HOME&#x3D;&#x2F;Users&#x2F;your-username&#x2F;Library&#x2F;Android&#x2F;sdk&#x2F;build-tools&#x2F;31.0.0export AAPT_HOMEexport PATH&#x3D;$PATH:$AAPT_HOME# 还可以顺便把其他工具也加入环境中ANDROID_HOME&#x3D;&#x2F;Users&#x2F;your-username&#x2F;Library&#x2F;Android&#x2F;sdkexport PATH&#x3D;$PATH:$ANDROID_HOME&#x2F;toolsexport PATH&#x3D;$PATH:$ANDROID_HOME&#x2F;platform-tools 如图所示： Vim 操作： 按i进行插入 按esc退出插入模式 输入:wq再回车，即保存 保存完毕后，重新启动终端，输入aapt v，显示版本号即可。","categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"}],"tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"https://doreality.xyz/tags/Android-Studio/"}]},{"title":"「C++ Primer」Chapter 01","slug":"dev/backend/cpp/cpp_primer/cpp-primer-ch01","date":"2021-09-23T04:18:53.000Z","updated":"2023-04-07T16:38:15.643Z","comments":true,"path":"posts/fa96995b.html","link":"","permalink":"https://doreality.xyz/posts/fa96995b.html","excerpt":"《C++ Primer》（第 5 版）的练习代码在这里♡.","text":"《C++ Primer》（第 5 版）的练习代码在这里♡. 第 1 章 开始 环境 macOS big sur（Apple M1，16GB 内存） 已安装 Xcode，Apple Clang Version 12.0.0 编译运行 用命令行编译： 1$ clang++ -std=c++1y -Wall prog1.cc -o prog1 -o选项是设置可执行程序的别名，这里是把源程序prog1.cc生成的可执行文件命名为prog1，如不设置默认是a.out。 -Wall选项是显示所有的warning，可以帮助更加规范编程。 执行： 1$ ./prog1 获得返回值： 1$ echo $? 返回值是 0，表示正常退出；其他值都表示程序异常结束，常见的是-1。 输入输出 标准输入输出 来自iostream库的基础类型：输入流istream和输出流ostream。 标准库定义了 4 个 IO 对象： cin：标准输入，istream类型的对象； cout：标准输出，ostream类型的对象； cerr：标准错误，ostream类型的对象； clog：输出运行时一般信息，ostream类型的对象。 头文件 头文件（header）使用时： #include和头文件的名字必须写在同一行； 通常情况，#include出现在函数之外； 一般，把一个程序所有的#include放在源文件的开始。 写入和读取 &lt;&lt;：输出运算符 接收两个对象，左侧对象必须是一个ostream对象，右侧对象是要打印的值。 计算结果是左侧对象。 endl：操纵符（manipulator） 结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。 缓冲刷新操作可以保证，目前为止程序所产生的所有输出都真正写入输出流中，而不是停留在内存中等待写入流。 ::：作用域运算符 指出命名空间，例如std::cout，使用名为std的命名空间中的名字cout。 &gt;&gt;：输入运算符 与输出运算符类似，左侧对象为istream对象，右侧对象保存左侧读入的数据。 计算结果是左侧对象。 注释 单行注释 1// 单行注释 多行注释 123/* * 界定符注释 */ 要注意的是，界定符注释不能嵌套，因为有就近原则，外层的/*会和内层的*/匹配，导致意外的错误。 控制流 while 语法如下： 123while (condition) &#123; statement&#125; 执行顺序： 判断循环条件，为真，则进入2；为假，跳出循环。 执行循环体，结束后进入1。 for 语法如下： 1234// 依次是：循环变量初始化；循环条件；表达式。for (int it = 0; it &lt; 10; it++) &#123; statement&#125; 执行顺序： 执行初始化语句（没有初始化就跳过这一步）； 判断循环条件，为真，进入 3；为假，跳出循环。 执行循环体内的语句，进入4； 执行表达式，进入2。 可见，初始化语句只在开始进入循环的时候执行一次，且唯一一次。 文件结束符 Windows 系统：Ctrl+Z ，然后按 Enter UNIX 系统（包括 Mac OS X）：Ctrl + D 编译错误 语法错误（syntax error） 类型错误（type error） 声明错误（declaration error） 好的习惯：edit - compile - debug 按照报告的顺序逐个修正错误 在每修正一个错误后就立即重新编译代码 最多是修正了一小部分明显的错误后就重新编译 缩进和格式 保持一致性 牢记：其他可能的程序格式总是存在的 一旦选择了一种风格，就要坚持使用 文件重定向 1$ addItems &lt;infile &gt;outfile","categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://doreality.xyz/tags/CPP/"}]},{"title":"基于 iTerm 2 + oh-my-zsh 的终端配置","slug":"tools/macOS/基于 iTerm 2 + oh-my-zsh 的终端配置","date":"2021-09-13T18:33:56.000Z","updated":"2022-07-15T02:54:52.792Z","comments":true,"path":"posts/e72c762f.html","link":"","permalink":"https://doreality.xyz/posts/e72c762f.html","excerpt":"终端的主题 + 配色方案。","text":"终端的主题 + 配色方案。 在如下位置修改主题： 12$ cd ~$ vi .zshrc 修改配色 首先，从官网上下载 iTerm 2 配色方案。 菜单栏 - iTerm2 - Profiles - Colors - 右下角 Color Presets，导入下载的预设文件。 参考 iTerm 2 配色方案 oh-my-zsh 主题","categories":[{"name":"Tools","slug":"Tools","permalink":"https://doreality.xyz/categories/Tools/"}],"tags":[{"name":"oh-my-zsh","slug":"oh-my-zsh","permalink":"https://doreality.xyz/tags/oh-my-zsh/"},{"name":"zsh","slug":"zsh","permalink":"https://doreality.xyz/tags/zsh/"}]},{"title":"macOS 安装 md5sum 命令","slug":"tools/macOS/macOS安装md5sum命令","date":"2021-09-13T16:30:42.000Z","updated":"2022-05-11T18:02:26.007Z","comments":true,"path":"posts/803b8154.html","link":"","permalink":"https://doreality.xyz/posts/803b8154.html","excerpt":"用 brew 安装 md5sum 起因是《Learn C The Hard Way》的练习 4 里，要使用 Valgrind 工具。安装该工具的时候，作者写着要用源代码方式安装，并且用到了 md5sum 进行匹配，由于之前用过 brew ，所以优先用这个方法安装。","text":"用 brew 安装 md5sum 起因是《Learn C The Hard Way》的练习 4 里，要使用 Valgrind 工具。安装该工具的时候，作者写着要用源代码方式安装，并且用到了 md5sum 进行匹配，由于之前用过 brew ，所以优先用这个方法安装。 在百度搜到的方法命令，一行： 1$ brew install md5sha1sum 然而我的运行结果： 照着这条错误提示：Not a valid ref: refs/remotes/origin/master，找到的方法是卸载 brew，重新安装。 运行卸载命令： 1$ /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/uninstall.sh)&quot; 提示信息如下： 1curl: (35) LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to raw.githubusercontent.com:443 尝试修改代理方法（失败）： 1$ git config --global --unset http.proxy 根据这篇文章，使用国内源： 1$ /bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot; 运行截图如下（会卸载老版本，然后安装新的）： 再次搜索md5sha1sum，搜索出来啦，安装成功～ 用源码安装 去官方网站获取源码，地址如下： http://microbrew.org/tools/md5sha1sum/md5sha1sum-0.9.5.tar.gz 之后，在下载目录进行如下操作： 12345$ tar xvfz md5sha1sum-0.9.5.tar.gz$ cd md5sha1sum-0.9.5$ ./configure$ make$ make install 参考 Macos 安装md5sum、sha1sum、md5deep、sha1deep","categories":[{"name":"Tools","slug":"Tools","permalink":"https://doreality.xyz/categories/Tools/"}],"tags":[{"name":"macOS","slug":"macOS","permalink":"https://doreality.xyz/tags/macOS/"},{"name":"Homebrew","slug":"Homebrew","permalink":"https://doreality.xyz/tags/Homebrew/"}]},{"title":"Git 日常积累（一）","slug":"git/git-summary-1","date":"2021-04-02T13:27:28.000Z","updated":"2023-04-02T11:57:42.900Z","comments":true,"path":"posts/d00de0a5.html","link":"","permalink":"https://doreality.xyz/posts/d00de0a5.html","excerpt":"刚开始使用 Git 和 GitHub，慢慢记录一些自己学到的常用的命令，当作备忘录吧。 本期重点： 从远程仓库下载 上传到仓库 使用 .gitignore 管理目录","text":"刚开始使用 Git 和 GitHub，慢慢记录一些自己学到的常用的命令，当作备忘录吧。 本期重点： 从远程仓库下载 上传到仓库 使用 .gitignore 管理目录 要和 GitHub 有交流，需要配置好 SSH（可以参考同一主机下使用多个的GitHub账号搭建Hexo博客中「生成new账号的SSH」一节）。 从远程仓库下载 12345678$ git clone [仓库链接]# https 方式$ git clone https://xxxxxx.git# ssh 方式 @的后面是你的ssh配置的host# 如果在建立 GitHub 的 ssh 的时候没有额外设置，默认是 github.com$ git clone git@yourHostName:username/reponame.git 上传到仓库 如果是本地文件上传，需要先在 GitHub 上新建一个仓库，之后再操作： 123456$ git init # 新建git仓库$ git add .$ git commit -m &quot;first commit&quot;$ git branch -M main # main 或者 master 看仓库具体分支是什么名字$ git remote add origin git@yourHostName:username/reponame.git$ git push -u origin main 如果是之前已经clone或者其他方式存在的： 123$ git remote add origin git@github.com:username/reponame.git$ git branch -M main$ git push -u origin main 使用 .gitignore 管理目录 使用 .gitignore 可以把不想上传的文件屏蔽掉。 只需要在文件目录下建立一个名为.gitignore的文件即可，内容格式如下： 12345678910111213# comment# 屏蔽掉当前目录下后缀为 .a 的所有文件*.a # 屏蔽当前目录下所有文件和目录* # 屏蔽 dir 目录&#x2F;dir&#x2F; # 屏蔽每一个目录下的相同文件*&#x2F;.DS_Store 除了屏蔽功能，还有可以增加的功能： 123# 增加 dir 目录以及其下所有子目录和文件!&#x2F;dir&#x2F; !&#x2F;dir&#x2F;**&#x2F; 需要注意的一点是，如果进行过git push后再新增或者修改.gitignore，如果不起作用的话，可以先清空缓存： 1234$ git rm -r --cached .# 然后就可以生效了$ git add .","categories":[{"name":"Git","slug":"Git","permalink":"https://doreality.xyz/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://doreality.xyz/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"https://doreality.xyz/tags/GitHub/"}]},{"title":"如何设置 Hexo 博客的永久链接","slug":"tools/hexo/hexo-permanent-link","date":"2021-03-29T13:37:10.000Z","updated":"2023-04-07T16:02:55.240Z","comments":true,"path":"posts/c762735f.html","link":"","permalink":"https://doreality.xyz/posts/c762735f.html","excerpt":"Hexo 支持的永久链接的格式会把中文转换成一长串编码，修改标题或者引用链接都会很麻烦。","text":"Hexo 支持的永久链接的格式会把中文转换成一长串编码，修改标题或者引用链接都会很麻烦。 有提供支持编码的插件，安装再修改配置文件即可。 安装插件 在博客的根目录下，安装插件： 1$ npm install hexo-abbrlink --save 修改配置 安装成功之后，打开_config.yml修改如下： 123456# permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;# permalink_defaults:permalink: posts&#x2F;:abbrlink.htmlabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex 重新生成 配置好之后： 12$ hexo clean$ hexo g 此时，每一篇博客的.md文件的首部都加入abbrlink条目，说明成功生成了这篇文章的永久链接，之后再修改标题都不会影响了。 发布之后，就会看到每篇博客的标题变成了：https://your_domain_name/posts/abbrlink.html 其中，your_domain_name是你的网站域名，abbrlink是这篇文章的永久链接编码。 这样，永久链接就搞定了。 参考 Hexo折腾系列——永久链接优化","categories":[{"name":"Tools","slug":"Tools","permalink":"https://doreality.xyz/categories/Tools/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://doreality.xyz/tags/Hexo/"}]},{"title":"oh-my-zsh 更新之后主题不能用","slug":"Q&A/oh-my-zsh-updated-cannot-use-themes","date":"2021-03-29T07:50:24.000Z","updated":"2023-04-07T16:06:27.110Z","comments":true,"path":"posts/93ed9593.html","link":"","permalink":"https://doreality.xyz/posts/93ed9593.html","excerpt":"前几天打开 iTerm 2 之后，提示我更新，之后就没再用。 今天打开发现之前设置好的主题不能用了。","text":"前几天打开 iTerm 2 之后，提示我更新，之后就没再用。 今天打开发现之前设置好的主题不能用了。 解决问题 打开 iTerm 2 的时候，有一句提示： ~/.oh-my-zsh/themes/agnoster.zsh-theme: 91 parce error near &quot;&lt;&lt;&lt;&quot; 不太懂为什么是语法错误，反正是主题文件出问题了，于是跑到主题的官方页面上用原本的主题文件的内容替换了一下，就好了。 两个简单的 vim 命令 中间用vi定位的时候学到两条命令： :set number：可以标注行号 删除内容（不过不是真的删除，而是剪切，会把删除内容保存到缓冲区）： dd：删除一行 ddp：当前行和下一行交换 ddP：当前行和上一行交换 dG：全部剪切 粘贴的时候就直接在网页里复制，然后在窗口里右键 paste（不用进入编辑模式就可以）。 之后:wq，重启 iTerm 2，搞定。 参考 新手教程：下载安装 iTerm 2 和 oh-my-zsh，并设置主题以及配置相关依赖 agnoster 主题的主页 一个简单的 vi 复制粘贴的教程","categories":[{"name":"Q&A","slug":"Q-A","permalink":"https://doreality.xyz/categories/Q-A/"}],"tags":[{"name":"oh-my-zsh","slug":"oh-my-zsh","permalink":"https://doreality.xyz/tags/oh-my-zsh/"},{"name":"Vim","slug":"Vim","permalink":"https://doreality.xyz/tags/Vim/"}]},{"title":"同一主机下使用多个 GitHub 账号搭建 Hexo 博客","slug":"tools/hexo/one-host-multi-accounts-hexo","date":"2021-03-08T12:37:54.000Z","updated":"2023-04-07T16:03:06.932Z","comments":true,"path":"posts/9fda10db.html","link":"","permalink":"https://doreality.xyz/posts/9fda10db.html","excerpt":"在一台电脑，一个 GitHub 账号的情况下，来搭建 Hexo 博客，可参考 这篇博客。 可是……我又有了一个新的 GitHub 账号，还是这台电脑，要在新账号上搭建一个新的博客（也就是说，要在一台电脑上同时操作两个GitHub账号），就要解决不同的SSH下的远程连接的问题。","text":"在一台电脑，一个 GitHub 账号的情况下，来搭建 Hexo 博客，可参考 这篇博客。 可是……我又有了一个新的 GitHub 账号，还是这台电脑，要在新账号上搭建一个新的博客（也就是说，要在一台电脑上同时操作两个GitHub账号），就要解决不同的SSH下的远程连接的问题。 在这里，默认已经学会了一台电脑一个账号的情况下，搭建 Hexo 博客的方法。 假设： 旧 GitHub 账号，简称 old，邮箱：old@example.com 新 GitHub 账号，简称 new，邮箱：new@example.com 在 old 已经搭建了 Hexo 的情况下： git 已经进行过如下设置： 12$ git config --global user.name &quot;old&quot;$ git config --global user.email &quot;old@example.com&quot; 在用户目录的 .ssh 路径下默认配置了 old 账号的 SSH（敲了三个回车），其中私钥的文件名是 id_rsa，公钥文件名是 id_rsa.pub。 Windows的用户目录：C:\\Users\\username\\.ssh\\ macOS和Linux的用户目录：/users/username/.ssh/（也就是~/.ssh/） 我需要做两件事： 部署 new 账号的 SSH； 利用 new 的 SSH，将新博客部署到 new 账号的 new.github.io 仓库。 建立 new 账号的 Hexo 博客 此处为大致步骤，详细请见 这篇博客。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 此处&lt;folder&gt;假设为new_blog，下面会用到。 生成 new 账号的 SSH SSH 用于本地主机和远程服务器交流，对账户和密码进行加密，直接在本机上生成即可。 本部分的操作在用户目录的.ssh目录下，使用git bash运行命令行。 创建 SSH key 1$ ssh-keygen -t rsa -C &quot;new@example.com&quot; -f &quot;id_rsa_new&quot; 第一个引号中，填写 GitHub 的账号地址； 第二个引号中，自定义填写，不能默认，否则会覆盖之前已经存在的id_rsa和id_rsa.pub。 之后，敲两次回车，默认即可。 添加私钥 由于使用 SSH 时，默认使用id_rsa的私钥，所以要把新建的私钥添加到系统中： 12$ ssh-agent bash$ ssh-add ~/.ssh/rsa_name 此时提示Identity added:……即完成。 设置 SSH config 依旧在.ssh路径下，新建config文件： 1$ touch config 打开config文件（用文本编辑器），输入以下内容： 1234Host newgithub # 名称，自定义，会影响后续指令，用于连接 GitHub 仓库HostName github.com # 主机名，用于 GitHub 连接的 SSH，HostName 必须是“github.com&quot;User newgit # 用户名，自己决定IdentityFile C:\\Users\\Administrater\\.ssh\\id_rsa_new # 刚才新建的 rsa 私钥路径，具体看文件夹中路径 注意，对于默认生成的 SSH，Host条目的默认值是github.com，所以不要使用，会冲突。 此外，如果是用于别的服务器连接，HostName 可以是其他的域名，例如：gitgee.com 等。 部署 SSH 到 GitHub 用文本编辑器打开id_rsa_new.pub，复制公钥内容。 打开 「new GitHub 账号」 - 「右上角头像」 - 「Settings」 - 「SSH and GPG Keys」 页面； 然后，新建一个 SSH 条目，Title 自定义，Key 处粘贴公钥。 远程测试 1$ ssh -T git@newgithub # @后面是3.中Host的名字 显示You've successfully authenticated, but GitHub does not provide shell access.说明设置成功。 至此，new 的 SSH 的部署完成。 部署到 new GitHub 接下来，就要把新的 hexo 博客部署到相应的 new GitHub账号了。 修改 deploy 设置 如下设置new_blog目录下的_config.yml即可： 1234deploy: type: git repository: git@newgithub:new&#x2F;new.github.io.git branch: master 注意：@的后面是设置 SSH 时的 Host，并且不要忘记最末尾的.git。 添加 hexo 的 git 部署工具 在new_blog目录中，右键打开git bash，添加hexo-git-deployer工具，用于部署： 1$ npm install hexo-deployer-git –-save 部署 现在，就可以部署了： 12$ hexo g$ hexo d 此时，应该会成功部署到new账号的仓库中，但是上传的用户却是old用户。 原因是之前把old用户设置成了global全局权限，而 Hexo 博客在部署时，默认使用的是全局用户，所以操作时出现了问题。 如果不修改global权限，可以打开new_blog/.deploy_git/.git目录，在config文件中添加下面的内容即可： 123[user] name &#x3D; new email &#x3D; new@example.com 之后再对博客更新，就是new用户了。 到这里，在一台电脑上，就可以用不同的 GitHub 账号分别操作不同的 Hexo 博客了。 附：多 GitHub 账号的文件操作 如果不是搭建博客，而是多个账号分别进行项目管理的话，大致思路是一样的。 首先，也要对新账号建立 SSH 的部署，见正文第二部分。 之后，只要设置好相应的git config的用户信息，就可以正常操作了。 建立 git 仓库 打开项目的目录，新建 git 仓库。 1$ git init 设置 git config 给仓库设置用户和邮箱，在提交时会用到。 12$ git config user.name &quot;username&quot;$ git config user.email &quot;useremail&quot; 将本地仓库和远程仓库连接 如果要从远程仓库中下载原有的项目： 12$ git init$ git clone git@newgithub:new/newproject.git @后面也要使用设置 SSH 时的 Host。 如果要新建项目，利用前文建立好的 SSH，和远程仓库连接： 1$ git remote add origin git@newgithub:yourName/yourRepo.git 其中，yourName是 GitHub 的用户名，yourRepo 是相连的仓库（需提前建立）。 可以测试一下是否连接成功： 1$ git remote -v 之后正常操作，例如： 1234$ git status # 查看文件状态$ git add . # 添加所有文件$ git commit -m &#x27;a new commit&#x27; # 记录$ git push origin master # 上传，master是主分支，按情况修改 参考 git连接github总结 Windows下Git多账号配置，同一电脑多个ssh-key的管理 不想使用全局用户？教你为Hexo博客单独配置指定的git用户 如何生成多个ssh并将hexo博客布置到github 一台电脑使用两个git账号","categories":[{"name":"Tools","slug":"Tools","permalink":"https://doreality.xyz/categories/Tools/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://doreality.xyz/tags/GitHub/"},{"name":"Hexo","slug":"Hexo","permalink":"https://doreality.xyz/tags/Hexo/"},{"name":"SSH","slug":"SSH","permalink":"https://doreality.xyz/tags/SSH/"}]},{"title":"第N次：从零搭建 Hexo 博客并部署到 GitHub","slug":"tools/hexo/build-hexo-blog-from-zero","date":"2021-03-08T12:15:41.000Z","updated":"2023-04-07T16:03:14.468Z","comments":true,"path":"posts/4331facb.html","link":"","permalink":"https://doreality.xyz/posts/4331facb.html","excerpt":"第 N 次搭建博客的熟练工表示，搭起来真的很快，但是坚持写下去，好不容易。","text":"第 N 次搭建博客的熟练工表示，搭起来真的很快，但是坚持写下去，好不容易。 为什么选择用 GitHub 来搭载博客？ 至少我可以不用先花钱买个域名，再学习怎么搭个服务器，怎么写个网页，这一系列繁琐的事情都能迅速解决，我能很快投入到纯粹的写作中来。 既然到了这里，那么最基础的要求，就是拥有一个 GitHub 账号和一台能联网的电脑，最好是会一点命令行操作。接下来要怎么办，本文都可以试着帮你解决。 环境准备 下载安装如下工具： Git 客户端（适合你的操作系统的） 最新版的 Node.js 本篇博客的使用的环境如下： Windows 10 64bit Node.js v14.16.0 Git version 2.30.0.windows.1 搭建博客 搭建本地博客 关于 Hexo 的一切都可以看官方文档。 先打开一个路径，右键 git bash，在这里开始搭建博客。 首先，安装 Hexo： 1$ npm install hexo-cli -g 其次，建立博客目录（这里是 blog，可以自己随便命名）： 123$ hexo init blog$ cd blog$ npm install 顺利执行完毕，博客需要的基本内容就准备好了。 想要本地预览一下，可以输入命令： 1$ hexo server 根据提示，到 localhost:4000 就能看到使用原始主题 landscape 的博客。（关于博客的主题更换，可以看本文最后“附”部分）。 这样，本地博客就准备就绪了。 连接 GitHub 本地连接 GitHub 可以用两种方式。 SSH 方式 可以绑定一台主机和一个远程服务器，每次不需要手动输入账号和密码，方便快捷，但是每更换一台电脑就需要重新设置 SSH。 HTTPS 方式 更加便捷，没有绑定，但是每次需要手动输入账号密码，有一点麻烦。 这里使用的是 SSH 的方式，所以要把主机和 GitHub 账号进行一次“绑定”。 在用户目录，找到 .ssh 文件夹，打开之后 git bash，邮箱是 GitHub 账号的注册邮箱： 1$ ssh-keygen -t rsa -C &quot;youremail&quot; 之后敲击三次回车，会在该目录下生成私钥文件 id_rsa 和公钥文件 id_rsa.pub。 打开 id_rsa.pub 文件，复制公钥的内容，然后打开 GitHub 主页，右上角头像里找到 Settings，进入 SSH and GPG keys 页面，点击 New SSH key，新建一个 SSH，title 自己随便填，再把剪贴板粘贴在 key 部分，保存即可。 可以输入以下命令，测试一下是否顺利连接： 1$ ssh -T git@github.com 出现提示 Are you sure you want to continue connecting (yes/no)?，输入 yes。 之后看到 Hi &quot;username&quot;! You've successfully authenticated, but GitHub does not provide shell access. 说明已经顺利连接。 &quot;username&quot; 部分是你的 GitHub 的用户名。 建立仓库 新建一个名为 username.github.io 的 public 仓库，等到部署之后，就可以通过 http://username.github.io 网址来访问你的博客了。 同上，username 部分是用户名，每一个 GitHub 账号可以创建唯一一个这样的仓库，用于展示静态网页。 部署博客 进入本地博客的目录，打开git bash： 首先，设置 git 的账号，和 GitHub 账号保持一致： 12$ git config --global user.name &quot;username&quot; # 可以随便写$ git config --global user.email &quot;useremail&quot; # GitHub 账号的邮箱 为了把博客部署到 GitHub，需要安装插件： 1$ npm install hexo-deployer-git --save 然后，就可以部署了： 1$ hexo deploy # 或者 hexo d 到此，就完成了。 使用个性域名（可选） 首先要购买一个域名，我购买域名的网站是 GoDaddy，因为之前有用过，就懒得换了。 也有其他可选的网站，在阿里云、腾讯云、华为云上都可以购买，而且很多辅助的项目可以勾选，网站邮箱和安全保护之类的，总之都很方便，也都差不多价格。 主要问题就是如何把已经购买好的域名和username.github.io这个网址绑定起来。 配置域名的 DNS 首先，通过在命令里，使用命令 ping username.github.io，得到博客主页的 IP 地址。 然后，到域名的管理页面，找到 DNS 配置。把域名的 DNS 解析配置为两个： A记录：主机名是@，值为刚才ping到的 IP 地址。 CNAME：主机名是www，值为username.github.io 添加 CNAME 文件 在博客的本地文件目录下，找到source文件夹，添加文件CNAME（无后缀名），在里面写上刚刚购买的域名地址（加上https://前缀），保存即可。 上传发布 123$ hexo clean$ hexo g$ hexo d 在博客所在仓库的Settings页面，找到最下方的Custom domain栏，可以看到，已经是自己的域名了。 附 ：如何写作和配置主题 写一篇博客 新建，在 blog 目录下： 1$ hexo new &quot;title&quot; 会在 source/_posts/ 中，看到一个以该标题 title 命名的 Markdown 文件，这就是可以编辑的文档。 写作 用喜欢的文本编辑器打开这个文件（我比较喜欢Typora，目前在用 Obsidian），会发现里面已经有一些信息了，例如：title，date，还（可能）有tags等属性，自己也可以添加属性，不过具体要看选择的主题支不支持。 自己可以填写一些这些信息： 1234567tags:- atag- btagcategories:- a_cat- b_cat--- 在---下面开始写正文。 另外，如果在首页不想显示文章的全部，那么就在分隔的位置写一行&lt;!-- more --&gt;就可以了（根据具体使用的主题而言）。 引用图片 和直接用 Markdown 的语法引用超链接不同，插入图片需要提前进行配置。 Hexo 官网给了两种解决方案；这里选了浏览和整理时更清晰的一种——为每篇文档新建一个资源文件夹。 先进行插入图片的设置： 打开博客根目录下的_config.yml，找到相关条目，修改并添加： 1234post_asset_folder: truemarked: prependRoot: true postAsset: true 设置好之后，再新建文档，会同时建立一个和文档同名的文件夹，用来放这篇文档需要的图片文件。（如果是之前的文章，没有创建资源文件夹，自己手动新建一个即可。） 图片的引用格式 相对引用，可以使用 Markdown 的 ![](image.jpg)，直接写图片的名字即可。 Hexo 3 版本下，使用新的资源引用方法： 1&#123;% asset_img example.jpg This is an example image %&#125; 配置主题 在 GitHub 上搜索 hexo theme，就能搜到很多主题，找一个自己喜欢的，按照给的教程下载配置即可。 主要是修改博客根目录下的 _config.yml 中的 theme 的值。 参考 Hexo 官网 使用hexo+github搭建免费个人博客详细教程 Hexo+Github 绑定域名 GitHub+Hexo 搭建个人网站详细教程","categories":[{"name":"Tools","slug":"Tools","permalink":"https://doreality.xyz/categories/Tools/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://doreality.xyz/tags/GitHub/"},{"name":"Hexo","slug":"Hexo","permalink":"https://doreality.xyz/tags/Hexo/"}]}],"categories":[{"name":"Tools","slug":"Tools","permalink":"https://doreality.xyz/categories/Tools/"},{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"},{"name":"Q&A","slug":"Q-A","permalink":"https://doreality.xyz/categories/Q-A/"},{"name":"Projects","slug":"Projects","permalink":"https://doreality.xyz/categories/Projects/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://doreality.xyz/categories/Machine-Learning/"},{"name":"Git","slug":"Git","permalink":"https://doreality.xyz/categories/Git/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://doreality.xyz/tags/GitHub/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://doreality.xyz/tags/JavaScript/"},{"name":"oh-my-zsh","slug":"oh-my-zsh","permalink":"https://doreality.xyz/tags/oh-my-zsh/"},{"name":"macOS","slug":"macOS","permalink":"https://doreality.xyz/tags/macOS/"},{"name":"Python","slug":"Python","permalink":"https://doreality.xyz/tags/Python/"},{"name":"Homebrew","slug":"Homebrew","permalink":"https://doreality.xyz/tags/Homebrew/"},{"name":"C","slug":"C","permalink":"https://doreality.xyz/tags/C/"},{"name":"CPP","slug":"CPP","permalink":"https://doreality.xyz/tags/CPP/"},{"name":"OOP","slug":"OOP","permalink":"https://doreality.xyz/tags/OOP/"},{"name":"GDB","slug":"GDB","permalink":"https://doreality.xyz/tags/GDB/"},{"name":"LLDB","slug":"LLDB","permalink":"https://doreality.xyz/tags/LLDB/"},{"name":"Linux","slug":"Linux","permalink":"https://doreality.xyz/tags/Linux/"},{"name":"Valgrind","slug":"Valgrind","permalink":"https://doreality.xyz/tags/Valgrind/"},{"name":"Makefile","slug":"Makefile","permalink":"https://doreality.xyz/tags/Makefile/"},{"name":"Markdown","slug":"Markdown","permalink":"https://doreality.xyz/tags/Markdown/"},{"name":"DNS","slug":"DNS","permalink":"https://doreality.xyz/tags/DNS/"},{"name":"Device Driver","slug":"Device-Driver","permalink":"https://doreality.xyz/tags/Device-Driver/"},{"name":"Jupyter Notebook","slug":"Jupyter-Notebook","permalink":"https://doreality.xyz/tags/Jupyter-Notebook/"},{"name":"zsh","slug":"zsh","permalink":"https://doreality.xyz/tags/zsh/"},{"name":"Flask","slug":"Flask","permalink":"https://doreality.xyz/tags/Flask/"},{"name":"Docker","slug":"Docker","permalink":"https://doreality.xyz/tags/Docker/"},{"name":"NLP","slug":"NLP","permalink":"https://doreality.xyz/tags/NLP/"},{"name":"Node","slug":"Node","permalink":"https://doreality.xyz/tags/Node/"},{"name":"Sass","slug":"Sass","permalink":"https://doreality.xyz/tags/Sass/"},{"name":"Express","slug":"Express","permalink":"https://doreality.xyz/tags/Express/"},{"name":"Mongodb","slug":"Mongodb","permalink":"https://doreality.xyz/tags/Mongodb/"},{"name":"Vue","slug":"Vue","permalink":"https://doreality.xyz/tags/Vue/"},{"name":"Vuex","slug":"Vuex","permalink":"https://doreality.xyz/tags/Vuex/"},{"name":"Element UI","slug":"Element-UI","permalink":"https://doreality.xyz/tags/Element-UI/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://doreality.xyz/tags/Kotlin/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"https://doreality.xyz/tags/Android-Studio/"},{"name":"Scikit-learn","slug":"Scikit-learn","permalink":"https://doreality.xyz/tags/Scikit-learn/"},{"name":"Git","slug":"Git","permalink":"https://doreality.xyz/tags/Git/"},{"name":"PyCharm","slug":"PyCharm","permalink":"https://doreality.xyz/tags/PyCharm/"},{"name":"UML","slug":"UML","permalink":"https://doreality.xyz/tags/UML/"},{"name":"Hexo","slug":"Hexo","permalink":"https://doreality.xyz/tags/Hexo/"},{"name":"Vim","slug":"Vim","permalink":"https://doreality.xyz/tags/Vim/"},{"name":"SSH","slug":"SSH","permalink":"https://doreality.xyz/tags/SSH/"}]}