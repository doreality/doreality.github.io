{"meta":{"title":"DoReality","subtitle":"","description":"","author":"doreality","url":"https://doreality.xyz","root":"/"},"pages":[{"title":"","date":"2023-04-07T15:27:58.531Z","updated":"2023-04-07T15:27:58.521Z","comments":true,"path":"categories/index.html","permalink":"https://doreality.xyz/categories/index.html","excerpt":"","text":""},{"title":"","date":"2023-04-07T15:27:38.818Z","updated":"2023-04-07T15:27:38.807Z","comments":false,"path":"tags/index.html","permalink":"https://doreality.xyz/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-03-09T10:12:58.000Z","updated":"2024-02-29T04:07:34.574Z","comments":true,"path":"about/index.html","permalink":"https://doreality.xyz/about/index.html","excerpt":"","text":"Work hard in silence, let your success be your noise. Done is better than perfect. DoReality’s Blog DoReality’s GitHub DoReality’s Gitee"}],"posts":[{"title":"JavaScript OOP篇","slug":"dev/frontend/js/mosh-js-oop","date":"2024-03-03T12:56:43.000Z","updated":"2024-03-03T13:13:38.326Z","comments":true,"path":"posts/6aa27be8.html","link":"","permalink":"https://doreality.xyz/posts/6aa27be8.html","excerpt":"","text":"本系列 2 篇，此为 2，前见 1。 本篇暂时存放在 Notion 个人学习代码","categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doreality.xyz/tags/JavaScript/"}]},{"title":"HTML&CSS 实战篇","slug":"dev/frontend/html&css/mosh-html-css-3","date":"2024-03-03T12:43:44.000Z","updated":"2024-03-03T13:15:30.946Z","comments":true,"path":"posts/34e7d423.html","link":"","permalink":"https://doreality.xyz/posts/34e7d423.html","excerpt":"本系列共 3 篇，此为 3，前见 1，前见 2。 课程请访问：Code With Mosh 个人学习代码 最终效果：Moshify","text":"本系列共 3 篇，此为 3，前见 1，前见 2。 课程请访问：Code With Mosh 个人学习代码 最终效果：Moshify Introduction 使用HTML+CSS，构造一个虚拟的云服务商 Moshify https://www.moshified.com/ Prerequisites Semantic HTML Basic CSS properties Selectors &amp; pseudo-selectors CSS box model Absolute &amp; relative positioning Flex &amp; Grid layout Media queries Responsive images Transformations Transitions How to Take This Course Tools you need Setting up the project Coding lessons 学习方式： 先看最终结果 -&gt; 自己做 -&gt; 再看视频是怎么做的 先看最终结果 -&gt; 跟随视频一步一步做 Tools You Need Browser Chrome, Chrome Dev Tools Firefox Code Editor VS Code Extensions HTML CSS Support CSS Peek Prettier -&gt; format on save Highlight Matching Tag Todo Highlight Live Server Git https://git-scm.com Setting Up the Project moshify index.html （!，然后添加CSS的link） css normalize.css (google search: normalize css) styles.css (all styles for this project) Git Commit: Initial commit. 之后每次实现一个功能，进行提交，要写详细的说明。 在 Moshify 文件夹里有 fonts，icons，images 和设计文件 psd，安装字体和PS。 Essential Photoshop Skills 缩放工具： Z 放大 Z+alt 缩小 空格 按住空格，可以拖拽画布 【颜色】吸管工具 I 取色（alt+单击：切换工具；右键单击，查看所有工具；shit+i，遍历工具） 【字体】字体工具 T（pt单位是point，用于印刷；网页设计使用px像素） 首选项-单位与标尺，把字体单位设置为【像素】 离字体近处选择，否则点击空白会创建新的文本框 【距离】I 中的标尺工具 测量长宽、内外边距的像素值 Identifying the Components components contain other components and elements 观察页面，考虑和识别有哪些组件。 navigation bar: menu(inline list) banner / hero component: button input field with a button inline list &gt; badge card: elements: internal, (title, price, billing cycle), make no sense out of the component list with green ticks button 3 cols grid icon-round link component grid component 2 cols -&gt; mobile 1 col media object / component: an image on the left side, a heading, some texts quote component + image =&gt; card component =&gt; testimonial callout component: encourage people to take action footer: list without bullet, inline list 为了创建界面，首先创建所有的独立组件 当所有组件在mobile和standard都显示正确后， 组合成页面 组件库，就可以创建其他页面了 Color Palette 配色方案 首先要定义三种颜色： Primary 主要色 Secondary 次要色 Accent 强调色 观察设计稿，中性蓝色作为Primary，浅蓝色作为Secondary，橙色作为Accent 使用CSS变量定义配色，就可以多处复用了。 字体颜色： 标题：深紫色 正文文本（body text）：浅紫色 其中，设计稿中有一处正文出现了不同的颜色，有可能是设计师出错了。 为了保持一致性，合并这种颜色，使用正文的浅紫色。 1234567:root &#123; --color-primary: #2584ff; --color-secondary: #00d9ff; --color-accent: #ff3400; --color-headings: #1b0760; --color-body: #918ca4;&#125; 到此，可以向git仓库提交一次。点击changes，可以对比文件的修改。 在每次完成一个任务后，都可以提交一次，添加详细的说明。这样在查看历史记录时，可以清晰地看出修改的目的和内容。 Commit: Define the color palette. Typography All about fonts and sizes. 先看mobile设计稿：Mobile first 然后在为宽屏调整样式 使用的字体都是Inter，只有在引言部分人名的字体不一致，为了保持一致性，不使用这种字体。（多导入一种字体，就会增加页面的下载成本） 设计稿中使用的字重（Regular, bold, semibold, light, medium）样式过多（有可能是故意设计的，也有可能是设计师无意造成的），为了一致性和减少下载的负担，选择 regular 和 bold 在Google fonts中找到inter，复制： 123456&lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.googleapis.com&quot; /&gt;&lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.gstatic.com&quot; crossorigin /&gt;&lt;link href=&quot;https://fonts.googleapis.com/css2?family=Inter:wght@400;700&amp;display=swap&quot; rel=&quot;stylesheet&quot;/&gt; 在 body 选择器添加 font-family 样式，可以继承到子元素。 快速创建标题：h$&#123;Heading $&#125;*3，可以创建： 123&lt;h1&gt;Heading 1&lt;/h1&gt;&lt;h2&gt;Heading 2&lt;/h2&gt;&lt;h3&gt;Heading 3&lt;/h3&gt; 在提交代码之前，要review一下，再提交。 Define the styles of the fonts. 接下来创建组件。 Links 设计 media query 的时候，两种选择，要么合并写在前面的 media query 中，要么单独写一个。 前者的缺点是，让样式设置和逻辑分区远离了，修改起来麻烦。 12345@media screen and (min-width: 1024px) &#123; .link-arrow &#123; font-size: 1.5rem; &#125;&#125; 单独写一个的好处是，可以对不同的组件设置不同的 breakpoint 方便修改 即使对于不同组件多写一行 media query，也不影响样式表的大小，不属于repeat 当组件写好后，把组件相关的 html 放在 components/ 文件夹，作为模板，以防后面忘记。 components/links.html 1&lt;a href=&quot;#&quot; class=&quot;link-arrow&quot;&gt;Learn More&lt;/a&gt; Badges 有两种大小的 badge（徽章、标记），并且每一种大小也有不同的颜色。 使用OOCSS，分离结构和外观。 .badge 负责结构部分，描述圆角、内边距、字体 1white-space: nowrap; 对于空间有限的元素来说，不换行特别重要。 .badge--primary .badge--secondary .badge--small Lists 先找到列表有哪些： 水平（或者说inline）的 badge 列表 带有绿色对勾的垂直列表 导航栏菜单的水平列表 页尾的目录列表 再看有什么共性，作为基础的样式类 .list 都没有默认的bullet point样式：list-style: none; 字体颜色是 heading 的颜色 然后设置水平列表 .list--inline .list__item（这里使用了BEM命名规则） 水平列表字体是 bold，但是我们不想把它应用到所有的列表 留到后面做整个部分的组件时再设置。 Icons https://svgsprit.es/ sprite.svg 是一个XML文件，每个 symbol 标签是一个 icon，id用于引用，path标签定义一条曲线。 123&lt;symbol xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 64 64&quot; id=&quot;computer&quot;&gt;&lt;path d=&quot;m13.293 14.293-3 3a1 1 0 0 0 0 1.414l3 3 1.414-1.414-2.293-2.293 2.293-2.293z&quot;&gt;&lt;/path&gt; 在html中引用的时候，注意路径： 1&lt;use xlink:href=&quot;images/sprite.svg#snap&quot;&gt;&lt;/use&gt; 设置样式：.icon--primary 因为现在不需要别的颜色，就先不设置了。 不要解决不存在的问题，我们要跟随当前的设计，也不是为了给别人做一个组件库。 给 icon 设置背景 .icon-container，单个短横线是为了分隔不同的单词，这是一个新的类，而不是 BEM 的 modifier。 使用像素设置大小，是想要图标在不同设备上都有相同的大小。 背景可以用 inline-flex 弹性布局 Buttons 考虑 &lt;button&gt; 和 &lt;a&gt; anchor Always test your code as you go, don’t assume that your code is always going to work. hover 效果的颜色怎么存储： color palette 污染 直接存放，会导致有的颜色定义在配色中，有的存放在各个地方 可以使用css预处理器，例如SASS，SCSS background: lighten(primary, 10%) 当代码编译后，会变成实际的颜色。 暂时先硬编码（假设是后续不会大幅度变更网站的设计） 设置 block 按钮的时候，button 元素默认设置了 box-sizing: border-box 12345*,*::after,*::before &#123; box-sizing: border-box;&#125; Inputs 本项目里的input，带有一个button，并且input域有阴影。 先实现一个基础的input，再组合成输入域。 阴影也不是每个input都需要的，再后面页面部分的具体实现中再添加，先只设置一个border。 placeholder 使用伪元素设置 ::placeholder Input Groups 虽然是输入框，但是是 div 包含的 input 和 button .input-group 设置为弹性布局 .input-group .input 设置 flex-grow: 1 可以让输入框占满所有可用的空间。 Cards 观察 Card 设计： 圆角边框 有一个header，可以变换背景色 有一个白色的主体 有阴影 临时设置一个容器 &lt;div style=&quot;width:50%; padding: 4rem;&quot;&gt;&lt;/div&gt; 方便用来观察效果。 Plans 根据设计稿进行分区实现和调节。 考察眼力的环节，注意边距的大小。 Popular Badge mosh实现的版本，把popular标签当作 header 伪类元素，在用相对定位的时候，标签上面的一点会被plan容器遮盖掉。 所以把popular标签直接当做plan的伪元素，放在header的前面，再用相对布局就可以完全显示出来，也不影响边距等设定。 123456789101112.plan--popular &#123; position: relative;&#125;.plan--popular::before &#123; content: url(../images/popular.svg); width: 40px; display: inline-block; position: absolute; top: -5.5px; right: 5%;&#125; 在 .plan--popular 设置为相对定位之后，无论标签在 .plan--popular .card__header::before 还是 .plan--popular::before 都是可以的 但是 .plan--popular .card__header 不能设置为相对定位，因为前面为了圆角边框设置过 overflow: hidden 对于 position: absolute 的祖先元素： The element is positioned relative to its closest positioned ancestor (if any) or to the initial containing block. 绝对定位的参考是离它最近的有 position 设置的祖先元素（都没设置的话，就是初始块，应该就是 &lt;body&gt;）。 所以 popular 标签可以放在.plan--popular::before （child） 也可以放在 .plan--popular .card__header::before （grandchild），只要那个设置 position 的祖先元素是 .plan--popular，就可以显示多出的像素了。 Media Objects 先把基础的 media media-image media-body media-title 文字描述 三个部分的布局做好。 黑色背景等设计整个部分的时候，通过继承来得到。 字色和字号到时再一起调整。 logo部分，颜色不能被css修改：svg中预设了fill属性，删掉就好了。 Quotes 只需要包含：文本、作者、组织机构，不需要包含图片，因为使用quotes的时候不一定有图片，因为可能引用某个文章、或者什么。 quotes 做好之后和一个图片组合 然后放在一个card里，形成一个testimonial component，推荐组件。 对于html标签中表达引用的： &lt;q&gt;&lt;/q&gt; inline &lt;blockquote&gt;&lt;/blockquote&gt; block 对于引用出处的部分，可以使用 media 组件，但是设置样式的时候，可以独立一个类 .quote__author 而不用嵌套 .quote .media__header： 好处是，如果以后要删除 media 组件，需要重构这部分css 横线的位置上移：使用相对位置 1234.quote__line &#123; position: relative; bottom: 10px;&#125; 123.quote .media__image &#123; margin-top: 0;&#125; media组件中的image，是设置了上外边距10px，而这里要把图像恢复到原来的位置。避免继续使用 .quote .media__image 这种会把两个组件嵌套的设置。 ？但是在plan组件设置的时候，也嵌套定义了card的特殊样式。嵌套或者不嵌套的边界在哪儿？ Grids 在mobile情况下，都只显示一列 123456789101112131415.grid &#123; display: grid;&#125;@media screen and (min-width: 768px) &#123; .grid--1x2 &#123; grid-template-columns: repeat(2, 1fr); &#125;&#125;@media screen and (min-width: 1024px) &#123; .grid--1x3 &#123; grid-template-columns: repeat(3, 1fr); &#125;&#125; Testimonials 到此，已经有了Testimonial推荐组件所需的构造块了。 创建一下结构： 123456&lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;grid grid--1x2&quot;&gt; &lt;img src=&quot;images/testimonial.jpg&quot; alt=&quot;A happy, smiling customer&quot; /&gt; &lt;div style=&quot;height: 100px; background: gold&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 先测试一下是否可行，之后再替换quote，避免一开始就太复杂。 Callouts 按钮在grid里拉伸了，是因为 .grid 的 justify-items 和 align-items 默认都是拉伸的 stretch 对网格元素修改，使用 justify-self 和 align-self 属性。 调节按钮的内边距，不在布局的位置修改，而是新建一个skin方便复用。 让内容拉伸，填满空白；让按钮只占据它需要的宽度 auto： 12345@media screen and (min-width: 768px) &#123; .callout .grid--1x2 &#123; grid-template-columns: 1fr auto; &#125;&#125; Collapsibles mobile 的页尾导航是可折叠格式 同个网站生成的 SVG sprite 跟mosh用的不一样，拿参考素材里的就对了。 对于这个折叠组件，初始状态是只有header，且chevron指向右侧（原始图像是指向下方，要逆时针旋转90度）。 展开时，使用 collapsible--expanded 类设置样式 隐藏内容使用 display:none，但是 display 不能作为过渡的属性，替代的方法： 12345678910.collapsible__content &#123; max-height: 0; overflow: hidden; opacity: 0; transition: all 0.3s;&#125;.collapsible--expanded .collapsible__content &#123; max-height: 100vh; opacity: 1;&#125; max-height 可以根据内容来决定实际的 height，而不是直接限定死。 添加 opacity 作为过渡，可以体现更好的动画效果 到这里，只构造可折叠块的结构，而不关心它的skin。一方面网页里可能不会有其他部分跟footer相同的collapsible，其次这应该属于整个底部导航模块的内容。 collapsible 只在 JS 中使用到，没有定义样式。 Blocks 整个页面分为几个块 blocks / 分区 sections，有黑色背景，白色背景，有斜切的，也有水平的。 除了全局变量，可以设置 scope of custom properties，本身可以用，后代的元素也可使用： 123456789.block &#123; --padding-vertical: 6rem; padding: var(--padding-vertical) 2rem;&#125;.block--skewed-right &#123; padding-bottom: calc(var(--padding-vertical) + 4rem); clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 80%);&#125; 实现向右下斜切，并且使用 calc() 函数计算新的下边距。 根据设计稿，确定内容的最大宽度为 1140px，如果屏幕再宽，也保持不变： 1234.container &#123; max-width: 1140px; margin: 0 auto;&#125; 对于黑色背景，可以嵌套内部的元素；白色/无背景，可以直接添加到 block 一级的类。 margin: 0 auto; 表示上下边距为0，左右边距自适应，可以保持1140px居中 Navigation Bars 导航栏有三个元素，logo，图标（toggler button），无序列表。 在standard模式下，图标可以隐藏。 12345678910.nav &#123; background: #000; display: flex; justify-content: space-between; flex-wrap: wrap;&#125;.nav__list &#123; width: 100%;&#125; 让 ul 占据 100% parent元素的宽度，就可以用 flex-wrap 换行。 space-between 让两头的元素靠边 设置 toggler 在导航展开和未展开的样式，可以用双类选择器，可以保证只选中这一种组合的时候，产生效果： 123.nav.collapsible--expanded .nav__toggler &#123; opacity: 1;&#125; 好了，可以组装了！ Hero 我发现 container 在 mobile 上应该有一个 max-width 570px 的设置 设置样式的时候，先放通用样式的类名，再针对具体的模块设置类名，进行样式的覆盖。 例如对于 block__header 一般是mobile和standard都是居中的，但是hero组件的standard是居左的。 1&lt;section class=&quot;block block--dark block--skewed-left hero&quot;&gt; Optimizing Images 对于hero部分的图像，最大宽度只能显示 1140/2 = 570px，而原图有1500+px宽度，900KB 大小 在standard上也只会显示不超过500px宽度 而对于DPR &gt; 1的高分屏，使用的物理像素是逻辑像素的n倍，也就是Retina display，我们能提供的也只是 1140（2x）的图像。 使用ps进行缩放： 1140px宽：700+KB 570px宽：200+KB 然后进一步优化，可以转换为webp格式 2x: 100+ KB 1x: 40+ KB firefox的开发者工具（cmd+opt+i）可以选择不同DPR的屏幕效果来观察 Domain Block 修改 btn 中的icon大小，可以通过设置一个btn中的icon类，来调整，以便有很多button需要icon时，可以复用。 123456.btn .icon &#123; width: 2rem; height: 2rem; margin-right: 1rem; vertical-align: middle;&#125; 给 input 加阴影： 使用工具类 box-shadow，例如 Tailwind 就是这样，有大量工具类 utility class，但是工具类越多，会让HTML负担更多跟样式相关的内容，远离了初衷 使用特定的选择器 .block-domain .input-group Plans Block Q：pad 和 mobile 显示card的时候，popular标签会悬空在外面， 原因是 max-width 限制之后，用如下代码给 card 元素添加了外边距，而plan元素的实际大小仍是原来的大小。plan是popular标签的相对位置的参考元素，所以导致popular标签没有在card的固定位置。 1234.block-plans .card &#123; max-width: 500px; margin: 0 auto;&#125; 而把该属性改到 plan 元如下： 1234.block-plans .plan &#123; max-width: 500px; margin: 0 auto;&#125; card和plan 的宽度都被限制为300多像素，而无法达到500像素。需要一个 width: 100% 保证500px能达到，且同时响应式。 12345.block-plans .plan &#123; width: 100%; max-width: 500px; margin: 0 auto;&#125; 还有一个问题，不同plan的card body里有不同的内容，列表项个数也不同，怎么能控制让它们显示的高度时候是相同的呢？ 查看元素，发现 plan 组件的高度都是相同的，只是内部的card高度不同，所以给 .card增加了 height: 100% 成功让卡片相同了。 并且由于网格布局，其中一个card高度增加，其他也会一起增加。达到了card高度相同的目的。 接下来，修改内部的button让它保持在底部，可以使用flex布局。 添加了两个弹性布局，先是让card__body部分占满card/plan的下半部，使用 flex-grow:1；然后对于列表和按钮，使用 justify-content: space-between 保持在两端的边距相同。 Features Block 适合做一个 feature 的语义元素是 &lt;article&gt; 在grid布局或者flex布局，默认元素的顺序 order 从0开始，如果修改一个元素顺序，就会重新排序 12345@media screen and (min-width: 768px) &#123; .feature:nth-of-type(even) .feature__content &#123; order: 2; &#125;&#125; 通过修改偶数feature中的content的order可以实现在宽屏时，grid布局顺序颠倒 Showcase Block ipad 的图超出了container的界限，在移动设备上，可以缩放，响应式；而在宽屏时，固定大小，如果超出屏幕就溢出，显示600+像素，我们选择700px为基准的1x像素。 .block--dark block__heading 的是否有必要修改成 .block--dark h1 这种的？其实在 block__heading 中定义了一些样式，所以用上之后不仅仅只是把黑色背景下的标题变白色。我感觉有点没必要删掉。 1234567891011121314@media screen and (min-width: 768px) &#123; .block-showcase .grid &#123; grid-template-columns: 50% 50%; &#125; .block-showcase__image &#123; justify-self: end; &#125; .block-showcase__image &gt; img &#123; width: auto; max-width: 700px; &#125;&#125; 注意修改的是 &lt;picture&gt; 还是 &lt;img&gt;，width 只能设置到 &lt;img&gt; 上 对于 media object 列表，可以借助 &lt;ul&gt; 进行语义标签。 对于文字选中时效果，可以设置为更显眼的样式： 1234::selection &#123; background: var(--color-primary); color: #fff;&#125; Testimonials Block Footer Grid 布局 Putting it All Together 导航栏放在 &lt;header&gt;中 在单独构建每一个组件的最后，都要在不同分辨率的设备上进行测试。 在开发者工具中，有 320px 的小型移动设备，也要测试宽屏的设备。 Troubleshooting Layout Issues 排版到domain块的时候，搜索按钮在小屏幕上出现了排版问题。 把问题分解得越小越好，越容易找到问题。 创建一个测试的页面 playground.html 通过删除不同的块，来缩小问题出现的范围。 最后按钮的排版错误，是因为 input 组件使用了 flex-grow:1 但是却没有设置宽度，宽度就变成了chrome默认的宽度，导致超出了 input-group 的范围。 设置 width: 0 来让 flex 布局自动修改宽度，就可以了。 按钮的宽度在不同的屏幕上也可以设置 vw 单位来修改。 Animations 使用一个 JS 库：AOS Search Engine Optimization &lt;head&gt; 标签里的内容，帮助搜索引擎优化 &lt;title&gt; 展示在页面的tab里和搜索引擎的标题 meta:desc -&gt; &lt;meta name=&quot;description&quot; content=&quot;&quot; 在搜索引擎中展示在标题下面 The Open Graph protocol https://ogp.me/ 在分享页面的时候，会看到一个网页的预览图 &lt;meta property=&quot;og:&quot; content=&quot;&quot;&gt; HTML and CSS Validation footer 忘记用语义标签，然后把 footer 中的header修改掉就可以了。 Building for Production 发布到生产环境之前，需要使用 build tool Combine CSS and JS files：可以减少客户端向服务器的HTTP请求 Minify JS/CSS files：会删除所有的注释、换行、空格和不必要的字符，从而减少assets的体积，发送给用户更小的文件 Optimize images：除了用PS和在线converter中优化图片体积，使用打包工具可以在命令行中完成 Build Tools: Webpack：最常用的，但是需要很多设置 Rollup Parcel https://parceljs.org/ 零配置 使用 Parcel 来打包我们的网站： 首先，初始化 package： 1npm init -y 然后会在目录中出现一个文件 package.json 然后将 Parcel 作为第三方库安装进来： 1npm i -D parcel-bundler@1.12.4 -D 参数的含义是 development environment dependency，只在开发环境使用，而不会推送到生产环境，即不会发送给客户端 安装好之后会自动配置在 package.json 中，只要有了该配置文件，每次都可以重新下载依赖，所以打包发布的时候不用包含 node_modules/ 目录，这其中包含的都是第三方库，因为我们只安装了parcel，所以现在其中的库都是parcel和parcel依赖的库。 @1.12.4 会报错 Invalid Version: undefined 更新到 @1.12.5 就可以正常启动了 使用项目内的parcel node_modules/.bin/parcel index.html 使用全局的parcel，先安装 npm i -g parcel-bundler，然后项目内 parcel index.html parcel 的开发服务器也支持 live reloading，热更新，当项目文件修改时，就会重新打包并展示。 当 parcel 构建项目的时候，会创建两个目录 .cache/ dist/ 在 .gitignore 中进行设置： 123node_modules&#x2F;dist&#x2F;.cache&#x2F; 使用 parcel 打包： 1parcel build index.html 报错：/Users/doreality/codes/projects/Moshify/index.html: tree.render is not a function https://stackoverflow.com/questions/67087634/parcel-js-tree-render-is-not-a-function 使用命令：parcel build index.html --no-minify 可以成功build，但是好像index也没有压缩 通过在根目录下添加 .htmlnanorc.js，成功构建了，index也压缩了。 123module.exports = &#123; &quot;minifySvg&quot;: false&#125; 构建后生成的文件在 dist/ 中，对于每个文件都有若干个版本，每个版本标注了唯一的标识符。是为了避免caching，避免客户端缓存，而在后续网页修改时无法看到更新的结果。 无论是开发环境还是生产环境的文件，都保存在 dist/ 中。 删除目录后再执行一次 parcel build index.html 就只会生成一个版本的压缩文件了。 Deployment https://app.netlify.com 注册不太顺利，GitHub账户要身份验证，先不管了 https://vercel.com 试试这个 成功了 https://doreality-moshified.vercel.app/ 修改代码推送上去之后，也会自动构建发布。 而且自动更新到了 GitHub 仓库中 GitHub pages 可以显示静态的 Measuring the Site’s Performance https://pagespeed.web.dev/ 83 87 100 92 -&gt; 88 95 100 100 首先看 Accessibility 无障碍： aria: accessible reach internet application aria-label 可以让屏幕阅读器读出来。 https://accessibilityinsights.io/ 对于 Performance 性能部分，几乎是不能拿到满分，除非不考虑网站的可维护性。 SEO 部分，修改了logo的链接有描述性的文字 Lighthouse 扩展 chrome开发者工具，可以在本地测试性能。但是本地运行的是没有优化过的CSS和JS。 本系列共 3 篇，此为 3，前见 1，前见 2。","categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://doreality.xyz/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://doreality.xyz/tags/CSS/"}]},{"title":"HTML&CSS 进阶篇","slug":"dev/frontend/html&css/mosh-html-css-2","date":"2024-02-29T03:49:14.000Z","updated":"2024-03-03T13:15:06.617Z","comments":true,"path":"posts/f6dad03c.html","link":"","permalink":"https://doreality.xyz/posts/f6dad03c.html","excerpt":"本系列共 3 篇，此为 2，前见 1，后见 3。 课程请访问：Code With Mosh 个人学习代码","text":"本系列共 3 篇，此为 2，前见 1，后见 3。 课程请访问：Code With Mosh 个人学习代码 Layout 布局 Box Model Box Margin box, Border box, Padding box, Content box 1234p &#123; margin: 10px 20px 10px 20px; /*t r b l*/ padding: 10px 20px; /*vertical horizontal*/&#125; Margin Collapsing 外边距压缩 相邻的元素 margin 会重叠，两个元素的 border 之间的距离以最大的 margin 决定。 用 margin 设置元素之间的距离 用 padding 设置元素内部 content 到 border 的距离 Sizing Elements Block element 默认情况下， width 和 height 设置给 content box 任何 padding 和 border 都会增加 box 的实际大小。 margin 不影响盒子大小，只是和其他元素保持距离。 使用全局选择器设置 box-sizing: border-box（其他情况一般不用，对性能影响大）： 12345*,*::before,*::after &#123; box-sizing: border-box;&#125; Inline element 本身没有 width 和 height 属性 12display: block; /* 有宽高，并且独占一行 */display: inline-block; /* 有宽高，但是不换行 */ Overflowing 元素的大小固定，而内容太多，就会发生溢出。 默认是显示溢出 visible，但可以设置隐藏 hidden 和可滚动 scroll。 12345overflow: auto; /*visible, hidden, scroll*/overflow-x:; /*水平和垂直滚动条*/overflow_y:;overflow: hidden auto;/*隐藏水平的滚动条*/ Measurement Units absolute units px using in printing: pt in cm mm relative units %: relative to the size of the container vw vh: relative to the viewport width of the viewport height of the viewport em rem: relative to font size 如果没有设置 font-size，使用 &lt;html&gt; 这个根元素的默认字体大小16px rem：the fontsize of the root element，不用检查继承的字体大小 123html &#123;font-size: 62.5%; /* 62.5% * 16 = 10px */&#125; 块级元素在未设置高度时，默认高度是 0px，宽度是 100% of the parent。 使用 rem 相对大小，可以在字体变大变小时，container 随之改变，更加响应式。 Positioning position: relative 修改属性 top right bottom left，相对元素 normal position 定位 normal position 仍保留 1234.box-one &#123; position: relative; left: 2rem;&#125; box-one 从原来的位置右移 2rem 的距离。 使用负值可以向相反方向移动。 position: absolute 相对父容器定位，则父容器一定要修改 position: relative 从正常的布局流中移除，normal position 不保留，其他元素正常排版，本元素独立排版 123&lt;div class=&quot;boxes&quot;&gt; &lt;div class=&quot;box-one&quot;&gt;&lt;/div&gt;&lt;/div&gt; 12345678.boxes &#123; position: relative;&#125;.box-one &#123; position: absolute; left: 2rem;&#125; 相对于 boxes 容器的左上角，向右移动了 2rem position: fixed 相对于 view port 定位 normal position 不保留 1234567.box &#123; position: fixed; top: 0; /*类似于导航栏，固定在vp顶部*/ left: 2rem; right: 2rem; width: auto; /*使用定位来调整大小*/&#125; Floating Elements 添加浮动：float: left / right 停用浮动：clear: left / right / both Parent Collapsing 父容器看不到浮动的子容器，会忽略它然后排版，所以子容器不包含在父容器内。 解决： NOT SemanticHTML （污染 HTML 代码，没有语义的元素）在父容器底部，清除浮动：&lt;div class=&quot;clear&quot;&gt; 添加一个class clearfix 给浮动元素的父容器，使用伪元素样式 ::after： 12345.clearfix::after &#123; content: &quot;&quot;; display: block; /* 默认是 inline */ clear: both;&#125; 父容器 overflow:hidden 治标不治本的方法。 避免使用浮动布局，不好维护，不好处理清除浮动。 FlexBox Flexible Box Layout：in ONE Direction 1234.container &#123; display: flex; flex-direction: row / column (-reverse);&#125; axes main：主轴，取决于 flex-direction 是 row 还是 column cross：正交轴，和direction垂直的那个 对齐 （flex container 使用） justify-content: along the main axis flex-start, flex-end, center, space-around, space-between, space-evenly align-items: along the cross axis 如果元素有多行： flex-wrap: wrap：换行，不压缩元素，默认是 nowrap align-content:center：多行整体在cross axis对齐 （flex items 本身使用） align-self：元素在 cross axis 上对齐移动，覆盖父容器的 align-items 属性 大小 （flex items 本身使用） flex-basis：伸缩的方向取决于 flex-direction 是 row 还是 column，修改 width 或 height flex-grow：默认是 1，是 0 则不增长；根据所有元素的值的和，平均划分剩余可用的空白部分，再按权重分配给每个元素。 flex-shrink：默认是 1，是 0 则不收缩。 flex:1 2 15rem; 1 15rem; 1 2; 1; grow 先于 shrink Grid Layout Layout elementss in both row and column. 123456789.container &#123; display: grid; /* 3 x 2*/ grid-template-rows: 100px 100px 100px; grid-template-columns: 100px 100px; grid-template: repeat(3, 100px) / repeat(2, 100px); grid-template: 100px auto 100px / 30fr 70fr; /* fraction of the remain part*/&#125; grid-template-colomns: 1fr 1fr 两部分的实际宽度取决于本身内容的宽度 grid-template-colomns: 50% 50% 两部分的宽度分别是网格容器的50% Aligning justify-items: horizontal for individual item stretch(default), center, start, end align-items: vertical for individual item justify-content: horizontal for grid align-content: vertical for grid Gap row-gap: 10px column-gap gap Placing items grid-row grid-column grid-area 1234567891011.box-one &#123; grid-column: 1 / 3; /* startcol / endcol */ /* grid-column: 1 / span 2; */ /* grid-row: 2; 放第二行，其他的从左上到右下依次排列*/ /* grid-area: 1 / 1 / 1 / 3; startrow/ startcol/ endrow/ endcol */&#125; Placing by name 123456789.container &#123; grid-template-areas: &quot;header header&quot; &quot;sidebar main&quot; &quot;. footer&quot;;&#125;.box-one &#123; grid-area: header;&#125; Hiding Elements display: none; 完全隐藏 visibility: hidden; 隐藏内容，保留 normal flow 的位置 Media Queries 根据不同设备（Mobile / Tablet / Laptop / Desktop）的性质，展示不同的样式。 Responsive Web Site： Desktop-first approach Mobile-first（主流）：先把简单的界面做得好，再在屏幕更大的设备上，给多余的空间添加新的内容 media query breakpoints: （旋转或者屏幕长宽改变，页面上的元素排列也改变，以方便阅读） portrait mode 竖屏 landscape mode 横屏 具体的 breakpoint 取决于网页本身的设计，不要盲目地跟从参考数值。 1234567891011121314151617181920212223/* 选择第 2 个 box 类的元素 */.box:nth-of-type(2) &#123; background: dodgerblue;&#125;/* 对于屏幕的要求，如果满足则按照新的样式 */@media screen and (min-width: 600px) &#123; /* rewrite rules */ .container &#123; flex-direction: row; &#125;&#125;/* 对于打印机 */@media print &#123; body &#123; font-size: 12pt; &#125; .box &#123; padding: 1cm; &#125;&#125; Typography 排版 网页中 90% 都是文字～所以文本和字体都很重要。 Styling Fonts font-family：（英文）字体一般分为三类： Serif 衬线字体：字母的起始和结束处有竖线，表示比较正式，书籍报纸杂志等用。 Georgia Times New Roman Sans-serif 无衬线字体 Avenir Arial Futura Helvetica Roboto Monospace（Mono = one）等宽字体，用于代码 Consolas Courier Ubuntu Font stack：兼容不同用户电脑上的更多字体. VSCode 提示（cmd+i）的是 Web Safe Font，绝大多数电脑都可以显示。 在 Font Stack 末尾添加 sans-serif：通用名称，是让电脑自己决定 为了统一网页的字体，可以利用 CSS 的继承特性，把 font-family 设置在 body 的样式中。 font-weight：字体的粗细，100 - 900 normal = 400 bold = 700 font-style：设置斜体 font-size：设置字号大小 关键字 绝对单位 / 相对单位 color： 如果 16 进制颜色的前 3 位数字和后 3 位数字一样，就可以只用 3 位数字表示 正文字体最好不要用纯黑 #000， 可以用深灰色 #333 Embedding Fonts 字体网站： fontsquirrel.com fonts.com myfonts.com 付费字体一般效果更好：大小和清晰度都支持很好。 字体的格式： TTF OTF EOT 对于 Web Font，使用的字体格式（压缩比更高）： WOFF WOFF 2.0 生成 Web Font：https://www.fontsquirrel.com/tools/webfont-generator 使用 @font-face 规则导入字体到 css 中，放在 css 文件的最开始，因为要先导入字体才能使用显示： 123456789101112131415@font-face &#123; font-family: &quot;opensans&quot;; src: url(&quot;fonts/open-sans/opensans-regular-webfont.woff2&quot;) format(&quot;woff2&quot;), url(&quot;fonts/open-sans/opensans-regular-webfont.woff&quot;) format(&quot;woff&quot;); font-weight: normal; font-style: normal;&#125;@font-face &#123; font-family: &quot;opensans&quot;; src: url(&quot;fonts/open-sans/opensans-bold-webfont.woff2&quot;) format(&quot;woff2&quot;), url(&quot;fonts/open-sans/opensans-bold-webfont.woff&quot;) format(&quot;woff&quot;); font-weight: bold; font-style: normal;&#125; 生成的 woff 字体有自带的样式 路径和字重和字体样式都可以设置，字体名称也可以相同（然后通过设置不同字重，显示不同的字体） Flash of Unstyled Text (FOUT) 在浏览器下载字体时，会先用一种替代字体显示。 在自定义字体的 @font-face 中设置浏览器的行为 font-display： auto：不推荐，不同浏览器可能有不同行为 swap：不推荐，下载好后替换，可能下载时间太长，导致用户浏览时排版突变，体验很不好 fallback：推荐，给一个很短的时间窗口用于下载自定义字体，如果该时间内没下载完，就一直使用替换字体 block：不推荐，先隐藏使用字体的文本，直到下载完；如果下载不到字体，文本就永远不显示了。 flash of invisible text (FOIT) optional：最好的体验，先用替换字体显示，但也同时下载字体，下载好之后加载的页面会用该字体，只是在第一次加载时显示的和之后的可能不同。 或者在转换字体时，缩小字符集（subsetting） 使用 开发者工具中的 Network 可以模拟不同的网络和网速，slow connection -&gt; Network Throttling Font Services Google Web Fonts Adobe Fonts fonts.com fontdeck.com 粘贴到样式表的 &lt;link&gt; 标签之前： 123&lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.googleapis.com&quot;&gt;&lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.gstatic.com&quot; crossorigin&gt;&lt;link href=&quot;https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;700&amp;family=Roboto:wght@700&amp;display=swap&quot; rel=&quot;stylesheet&quot;&gt; preconnect 使进程加速 ? 后是 Query String Parameters，可以根据需要修改；display=swap 对应的是 font-display。 System Font Stack 优点 better experience boost performance no flash of unstyled text (FOUT) native look 缺点 but: default fonts vary on different OS systems Web Safe Font 20年，很简单很朴素所以没有那么好看；而系统的默认字体会更漂亮一些，但是使用系统字体栈会让字体在不同系统上显示得不一样，分别提供最好的用户体验（吧） 1font-family: system-ui, -apple-system, BlinkMacSystemFont, &#x27;Segoe UI&#x27;, Roboto, Oxygen, Ubuntu, Cantarell, &#x27;Open Sans&#x27;, &#x27;Helvetica Neue&#x27;, sans-serif; Sizing Fonts 首要原则：不要用 px 作为单位，因为不同设备的分辨率不一样。 使用 Relative Units： % vh，vw em，rem（最好） &lt;html&gt; 的默认字体大小是 16 px，方便计算时设置为 62.5%（或者 100% 都可以），其余的字体使用 rem 设置相对大小： 123html &#123; font-size: 62.5%;&#125; 针对不同的设备（Tablet，Desktop）只需修改根元素字体大小就可以适配了： 12345@media screen and (min-width: 400px) &#123; html &#123; font-size: 130%; &#125;&#125; 字体大小设计网站：https://typescale.com/ 为标题统一字体，但分别设置大小： 1234567891011121314h1,h2,h3,h4,h5,h6 &#123; font-family: Georgia, &quot;Times New Roman&quot;, Times, serif;&#125;h1 &#123; font-size: 4.209rem;&#125;h2 &#123; font-size: 3.157rem;&#125; Vertical Spacing margin line-height “Law of Proximity”：接近性原则 Objects that are closer are perceived to be related. 内容相关的文字应该相邻。 标题的上下边距要不同，和下方的文字更紧密。 123h1 &#123; margin: 3rem 0 1rem;&#125; 常用的行高是 1.5 rem，但也根据具体的设计，可以设置为别的（1.4，1.6等） 使用倍数：1.5 不带单位，是当前元素的字体大小的倍数，在修改字体大小时，就不用再修改行高了。 修改字体大小时，要注意修改行高，否则排版就会乱。 Horizontal Spacing letter-spacing word-spacing 使用 px 单位，在 Inspect 中调节字符间距和词间距，取决于不同字体呈现的效果。 width: 50ch Ideal Line Length: 50 - 70 characters per line ch 的宽度是字符 0 的宽度，有些字符宽度是小于 0 的，例如 i、1，50 个 0 就差不多是 60 至 70 个字符了。 Formatting Text text-align left (best) center (best) right (no) justify (no) 两端对齐，会导致每一行字符间距不统一 text-indent 1rem p + p 可以让第一个段落后面相邻的段落缩进 text-decoration underline line-through text-transform capitalize uppercase lowercase white-space nowrap 截断文本 1234567p &#123; width: 50ch; /* width of &#x27;0&#x27; character */ white-space: nowrap; overflow: hidden; text-overflow: ellipsis; /* end with ... */ line-clamp: 3; /* CSS3 设置截断的行号，使用时再查文档 */&#125; column-* 12345p &#123; column-count: 2; /* 栏数 */ column-gap: 1rem; /* 栏间距 */ column-rule: 3px dotted #999; /* 分隔线 */&#125; direction ltr rtl Images 图像 Image Types and Formats 2 types in computer: Raster images 位图: made in pixels photos Vector images 矢量图: 矢量组成，例如直线和曲线 simple graphics icons logos Raster comes from cameras / scanners / software Formats: JPG, PNG, GIF, etc 大图像 = 更多的像素 = More pixels = larger file size 小图像 = 放大会模糊 blurry，因为本身的像素信息少 Colors Transparency 透明度 Animation 动画 JPEG 16M GIF 256 🟡 🟡 PNG 16M 🟡 🟡 WebP 16M 🟡 🟡 RGB（8, 8, 8）= $16M = 2^24 = (2^8)^3$ WebP 是一种新型格式（但是 IE 不支持），Size 很小 最常用的是JPEG 需要透明或者动画时，使用PNG和GIF Vector 软件创作（Adobe illustrator） Format: SVG Scalable Vector Graphics 任何尺寸都清晰 sharp Content Images 1&lt;img src=&quot;images/meal.jpg&quot; alt=&quot;A bowl of salmon and curry&quot; /&gt; alt 属性： 一是为了screen reader，对视障用户或者使用屏幕阅读器的一种无障碍； 二是当用户的网络连接速度慢时，有些图像下载慢、甚至无法下载，就可以通过合理的文字描述让用户理解。 如果有时图像仅仅用于装饰，最佳实践要设置 alt=&quot;&quot; 空字符串，防止屏幕阅读器读出来的是文件的名称。 当位图被放大超过它本身的像素大小时，由于像素数据的信息缺失，图像就不能显示足够的细节，会很模糊。 但是也不能通过数学矢量绘制这些图像。 Background Images 经常使用背景图来对标签进行装饰，例如 &lt;body&gt; / &lt;section&gt; / &lt;header&gt; 等。 选择图像：background-image:url(); / background: url(); 设置重复：background-repeat 默认两个方向都重复：repeat no-repeat repeat-x / repeat-y 设置位置：background-position: 水平方向 垂直方向; background-position: 100px 100px; 向右，向下 background-position: 100% 100px; 移动到最右侧 设置大小：background-size: 宽 高; background-size: 100% 100px; 拉伸到100%宽度，高100px background-size: 100% 100%; 要保证该元素高度不为0（块级元素没有内容的时候高度为0） background-size: cover; 会覆盖整个元素，并根据元素大小拉伸填充。 附加属性：background-attachment background-attachment: fixed; 会根据viewport确定背景图大小，并且不跟随滚动条移动。 CSS Sprites CSS雪碧/CSS精灵：一种 CSS优化技巧，减少CSS对图片的HTTP请求。 https://cssspritestool.com/ search: css sprite generator 如果需要批量生成很多sprites，最好使用命令行工具。 12&lt;span class=&quot;bg-dishes&quot;&gt;&lt;/span&gt;&lt;span class=&quot;bg-landing&quot;&gt;&lt;/span&gt; 12345678910111213.bg-dishes &#123; background: url(&quot;../images/css-sprite-combined.png&quot;) 0px -0px; width: 100px; height: 100px; display: inline-block;&#125;.bg-landing &#123; background: url(&quot;../images/css-sprite-combined.png&quot;) -100px -0px; width: 100px; height: 100px; display: inline-block;&#125; 将多张图片合并到一张图上，然后使用css规则进行裁剪。 好处：客户端只用发送一次请求就可以获得多张图片了。 但是不要滥用雪碧，不要把所有图像都放在一张图。 导致的问题： 大的图片合并到雪碧图，会导致文件太大 雪碧图没有扩展性；如果需要替换，就要生成新的雪碧图。 最好只在小图上使用：logos / icons Data URLs 正式说法是 Data URI 另一种减少 HTTP 请求的CSS优化技巧 可以直接将图像资源嵌入到HTML或CSS中。 https://cssportal.com/image-to-data/ search: data url generator 问题： 嵌入代码的大小 &gt; 原本资源文件的大小 增加维护的难度 在移动设备上，Data URL比原始的图像更慢 Clipping https://bennettfeely.com/clippy/ search: css clip generator 1&lt;img src=&quot;images/meal.jpg&quot; alt=&quot;&quot; class=&quot;meal&quot; /&gt; 1234567891011.meal &#123; clip-path: polygon( 0% 20%, 60% 20%, 60% 0%, 100% 50%, 60% 100%, 60% 80%, 0% 80% );&#125; 直接选择合适的样式，然后使用 clip-path 属性即可。 Filters 滤镜！ grayscale 灰度 blur 模糊 contrast 对比度 brightness 亮度 saturate 饱和度 还可以使用 Pseudo-class selector： 123.meal:hover &#123; filter: grayscale(70%) blur(3px);&#125; 查阅mdn文档学各种使用。 IE 和 Opera Mini 浏览器不支持 CSS filter（只能使用 PS 等工具生成不同滤镜的图像） Supporting High-density Screens 高分屏 / 高分辨率屏幕 / 高密度屏幕 屏幕的scale factor 物理分辨率（Physical resolution） iPhone4：960 x 640 逻辑分辨率（Logical resolution）—— CSS计算的方式 iPhone4：480 x 320 设备像素比率（Device Pixel Ratio，DPR）= Physical / Logical iPhone4: 2 高分屏（High Density Screen）：DPR &gt; 1 的屏幕 物理像素比逻辑像素多 根据DPR的倍数，命名图像文件的名称： DPR = 1: meal.jpg 400 x 400 （在CSS中使用的逻辑像素） DPR = 2: meal@2x.jpg 800 x 800 DPR = 3: meal@3x.jpg 1200 x 1200 （在DPR=3的屏幕中替换的图像） 记住：从 3x -&gt; 2x -&gt; 1x 的顺序，使用 Photoshop 缩小保存。如果反着来，PS会在放大图像的时候创造像素，导致图像模糊。 使用 srcset 属性： 12345678910&lt;img src=&quot;images/meal.jpg&quot; alt=&quot;A bowl of salmon and curry&quot; class=&quot;meal&quot; srcset=&quot; images/meal.jpg 1x, images/meal@2x.jpg 2x, images/meal@3x.jpg 3x &quot;/&gt; Resolution Switching 分辨率转换：如果使用 vw 这样的单位，在不同分辨率的屏幕上（即使DPR相同），浏览器会进行缩放，会消耗不同的资源。 一般会提供 small, medium, large 三种大小的图像，让浏览器自己选择 不写DPR，也不关心物理分辨率，只是提供图像实际的像素大小： 12345678910&lt;img src=&quot;images/meal.jpg&quot; alt=&quot;A bowl of salmon and curry&quot; class=&quot;meal&quot; srcset=&quot; images/meal.jpg 400w, images/meal@2x.jpg 800w, images/meal@3x.jpg 1200w &quot;/&gt; 为不同的设备（手机、平板、电脑）设置不同的vw宽度： 12345678910111213141516&lt;img src=&quot;images/meal.jpg&quot; alt=&quot;A bowl of salmon and curry&quot; class=&quot;meal&quot; srcset=&quot; images/meal.jpg 400w, images/meal@2x.jpg 800w, images/meal@3x.jpg 1200w &quot; , sizes=&quot; (max-width: 500px) 100vw, (max-width: 700px) 50vw, 33vw &quot;/&gt; https://responsivebreakpoints.com/ 上传一张图片，可以设置不同分辨率、图像大小、分为几种大小 Using Modern Image Formats WebP 格式 PS（WebPShop plug-in） Sketch Online tools（ https://cloudconvert.com/ https://cloudconvert.com/jpg-to-webp ） CMD tools 1&lt;img src=&quot;images/meal.webp&quot; alt=&quot;&quot; /&gt; 压缩幅度很大，但画质保留很好。 但是为了解决 IE 不兼容的问题，使用 &lt;picture&gt; 标签： 12345&lt;picture&gt; &lt;source type=&quot;image/webp&quot; srcset=&quot;images/meal.webp&quot; /&gt; &lt;source type=&quot;image/jpeg&quot; srcset=&quot;images/meal.jpg&quot; /&gt; &lt;img src=&quot;images/meal.jpg&quot; alt=&quot;A bowl of salmon and curry&quot; /&gt;&lt;/picture&gt; 不支持 &lt;pitcture&gt; 的浏览器，会显示 &lt;img&gt; 标签 Art Direction 艺术指导/美术指导 有的图像在电脑屏幕上看着合适，但是到手机屏幕上，就会提供一个 zoom-in 或者裁剪的大小。 使用 media 属性： 12345&lt;picture&gt; &lt;source media=&quot;(max-width: 500px)&quot; srcset=&quot;images/meal-cropped.jpg&quot; /&gt; &lt;source media=&quot;(min-width: 501px)&quot; srcset=&quot;images/meal.jpg&quot; /&gt; &lt;img src=&quot;images/meal.jpg&quot; alt=&quot;A bowl of salmon and curry&quot; /&gt;&lt;/picture&gt; Scalable Vector Graphics 常用于图标/logo，也可以用作背景： https://www.svgbackgrounds.com/ Font Icons Font Awesome Ionicons Material Design Icons 对 fontawesome 进行设置的时候： 12345.navbar .navicon &#123; width: 2rem; margin-right: 1rem; text-align: center;&#125; 可以设置一些占位宽度，和对齐方式。 也可以使用 font-size 和 color 进行设置样式（与对应的文本一起设置即可）。 Forms 表单 Creating a Basic Form 123456789101112&lt;form&gt; &lt;div&gt; &lt;label for=&quot;name&quot;&gt;Name&lt;/label&gt; &lt;input id=&quot;name&quot; type=&quot;text&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt; &lt;input id=&quot;email&quot; type=&quot;email&quot; /&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot;&gt;Register&lt;/button&gt; &lt;button type=&quot;reset&quot;&gt;Clear&lt;/button&gt;&lt;/form&gt; 每个表单有一个或多个的 input field。 每个可以将 &lt;input&gt; id 属性和一个 &lt;label&gt; 的 for 属性绑定，则点击 label 可以激活对应的输入域。 type=&quot;email&quot; 可以做简单的验证 type=&quot;reset&quot; 可以清空已输入的内容 Styling Forms &lt;label&gt; 换行 123label &#123; display: block;&#125; 表单元素间距 接近性原则。 123.form-group &#123; margin-bottom: 1rem;&#125; &lt;div class=&quot;form-group&quot;&gt; 是常用的把成对的 &lt;label&gt; 和 &lt;input&gt; 打包起来的类名 &lt;input&gt; 样式 1234567891011121314input[type=&quot;text&quot;],input[type=&quot;email&quot;] &#123; border: 1px solid #ccc; border-radius: 5px; padding: 0.5rem 0.8rem; transition: border-color 0.15s, box-shadow 0.15s;&#125;input[type=&quot;text&quot;]:focus,input[type=&quot;email&quot;]:focus &#123; border-color: #7db0fb; outline: 0; box-shadow: 0 0 0 4px rgba(24, 117, 255, 0.25);&#125; padding：试出自己觉得好看的内边距即可。 outline: 0; 消除浏览器的默认样式，用在伪类选择器或者是元素选择器，效果都一样 transition 样式平滑过渡 &lt;button&gt; 样式 123456789101112button &#123; background: #0d6efd; color: #fff; border: 0; padding: 0.5rem 0.8rem; border-radius: 5px; outline: 0;&#125;button:active &#123; background: #0b469e;&#125; 按钮颜色：一般点击时 :active 背景色变深，深色背景要用浅色字体。 CSS Frameworks 常用的 CSS 框架： Bootstrap Foundation Semantic UI UI Kit Materialize Milligram：tiny for speed and productivity 使用 CDN(Content Delivery Network 内容分发网络，在Internet上存储各种html/css/js等资源方便使用) 引用，放在我们自己的样式表下方： 12345678910111213&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/normalize.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/styles.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/milligram/1.4.1/milligram.css&quot; /&gt; &lt;!-- &lt;link href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; integrity=&quot;sha384-KK94CHFLLe+nY2dmCWGMq91rCGa5gtU4mk92HdvYe+M/SXH301p5ILy+dN9+nJOZ&quot; crossorigin=&quot;anonymous&quot; /&gt; --&gt;&lt;/head&gt; Bootstrap 学习曲线，需要记忆和学习： class=&quot;mb-3&quot; class=&quot;form-label&quot; class=&quot;form-control&quot; class=&quot;btn btn-primary&quot; Milligram 只要引入，就直接会有样式，不用额外设置，方便上手。 Text Fields 常见 Input Type &lt;input&gt; - MDN Doc number field 1&lt;input type=&quot;number&quot; /&gt; 只能接收数字，也不会输入字母 在手机、平板上可以直接显示数字键盘 password field 1&lt;input type=&quot;password&quot; /&gt; 输入的文字会····· date field 1&lt;input type=&quot;date&quot; /&gt; email field 1&lt;input type=&quot;email&quot; /&gt; 如果输入的不是合法的 email 格式，再提交表单时浏览器会验证并给出报错。 textarea 1&lt;textarea cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; cols 和 rows 设置最大列数和行数 123textarea &#123; resize: none;&#125; 固定大小，不可调整 常用 Input Attributes value=&quot;xxx&quot; 预填充 placeholder=&quot;Email&quot; 占位符，输入文本时就会消失 readonly 不能修改 disabled 不能选中，不会提交给服务器 maxlength=&quot;5&quot; 用于验证 autofocus 网页加载好可以直接输入 对于 &lt;textare&gt; 没有 placeholder，可以直接输入在标签里： 1&lt;textarea&gt;Comment...&lt;/textarea&gt; Data Lists Suggestion List 123456&lt;input type=&quot;text&quot; list=&quot;countries&quot; /&gt;&lt;datalist id=&quot;countries&quot;&gt; &lt;option&gt;United States&lt;/option&gt; &lt;option&gt;China&lt;/option&gt; &lt;option&gt;Japan&lt;/option&gt;&lt;/datalist&gt; 用户可以选择列表里的项，也可以自己输入文本。 如果要不允许自定义输入，需要使用 dropdown list &lt;option&gt; 的属性： value：unique identifier，但是会显示给用户 data-value：自定义的 attribute，不会显示 &lt;input&gt; 的属性： autocomplete=&quot;off&quot;：不让浏览器显示用户之前在这类输入框输入过的内容 &lt;datalist&gt; 和 &lt;option&gt; 会使用浏览器的默认样式，自定义样式需要搭配 JS 实现。 设置样式可以参考MDN文档（搭配JS）。 Drop-down Lists 123456789101112&lt;select multiple&gt; &lt;optgroup label=&quot;Front-end Courses&quot;&gt; &lt;option value=&quot;1&quot;&gt;HTML&lt;/option&gt; &lt;option value=&quot;2&quot; selected&gt;CSS&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;JavaScript&lt;/option&gt; &lt;/optgroup&gt; &lt;optgroup label=&quot;Back-end Courses&quot;&gt; &lt;option value=&quot;4&quot;&gt;Node.js&lt;/option&gt; &lt;option value=&quot;5&quot;&gt;ASP.NET&lt;/option&gt; &lt;option value=&quot;6&quot;&gt;Django&lt;/option&gt; &lt;/optgroup&gt;&lt;/select&gt; multiple boolean attribute，可以多选 selected boolean attribute，selected by default Check Boxes 12345678&lt;div&gt; &lt;input type=&quot;checkbox&quot; id=&quot;front-end&quot; /&gt; &lt;label class=&quot;label-inline&quot; for=&quot;front-end&quot;&gt;Front-end&lt;/label&gt;&lt;/div&gt;&lt;div&gt; &lt;input type=&quot;checkbox&quot; id=&quot;back-end&quot; checked disabled /&gt; &lt;label class=&quot;label-inline&quot; for=&quot;back-end&quot;&gt;Back-end&lt;/label&gt;&lt;/div&gt; class=&quot;label-inline&quot;：Milligram 的样式类，默认的 label 样式是 block 级元素 &lt;input&gt; 和绑定的 &lt;label&gt; 常用 &lt;div&gt; 包裹起来 checked boolean attribute Radio Buttons name attribute 对于单选框来说，可以用来分组，保证一组中只有一个选中。 同样，用 &lt;div&gt; 包裹一个label-input对，可以垂直布局不同的radio： 12345678910&lt;form&gt; &lt;div&gt; &lt;input type=&quot;radio&quot; name=&quot;membership&quot; id=&quot;silver&quot; checked disabled /&gt; &lt;label for=&quot;silver&quot; class=&quot;label-inline&quot;&gt;Silver&lt;/label&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;radio&quot; name=&quot;membership&quot; id=&quot;gold&quot; /&gt; &lt;label for=&quot;gold&quot; class=&quot;label-inline&quot;&gt;Gold&lt;/label&gt; &lt;/div&gt;&lt;/form&gt; Sliders 1&lt;input type=&quot;range&quot; min=&quot;0&quot; max=&quot;100&quot; value=&quot;90&quot; /&gt; 如果需要显示实时数值，需要使用 JS 事件监听。 File Inputs 1&lt;input type=&quot;file&quot; multiple accept=&quot;image/*&quot; /&gt; multiple boolean attribute，选择多个文件 accept=&quot;image/*, video/*, audio/*&quot; 可以选择的文件类型， accpet=&quot;.jpg&quot; 只能选择 jpg 文件 accpet=&quot;.jpg, .png&quot; 能选择 jpg 和 png 文件 Grouping Related Fields 给相关的域分组： 1234567891011121314&lt;form&gt; &lt;fieldset&gt; &lt;legend&gt;Billing Address&lt;/legend&gt; &lt;input type=&quot;text&quot; /&gt; &lt;input type=&quot;text&quot; /&gt; &lt;input type=&quot;text&quot; /&gt; &lt;/fieldset&gt; &lt;section&gt; &lt;h2&gt;Payment&lt;/h2&gt; &lt;input type=&quot;text&quot; /&gt; &lt;input type=&quot;text&quot; /&gt; &lt;input type=&quot;text&quot; /&gt; &lt;/section&gt;&lt;/form&gt; &lt;fieldset&gt; + &lt;legend&gt; &lt;section&gt; + &lt;h2&gt; Hidden Fields name 属性：发送表单给服务器时，为了识别修改的是哪个表单；但是不要携带敏感信息，源码里可以看到。 1&lt;input type=&quot;hidden&quot; name=&quot;course-id&quot; value=&quot;1234&quot; /&gt; Data Validation 数据验证：必须保证提交的表单信息是有效的，否则可能导致 data corruption / under security attacks 常用的验证属性： required minlength maxlength min max 123456789&lt;input type=&quot;number&quot; required minlength=&quot;3&quot; maxlength=&quot;10&quot; min=&quot;0&quot; max=&quot;10&quot; /&gt;&lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; Always use maxlength，避免几千字符的输入攻击 对于数据域，永远使用 min 和 max，尤其避免负数攻击 Submitting the Form Submit Button 的两种方式：&lt;button&gt; 和 &lt;input&gt;： 12&lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; 提交的时候，效果是一样的，连 Milligram 的样式也一样 不同： &lt;input&gt; 是自闭合标签，只能在 value 中使用文字 &lt;button&gt; 是开闭标签，可以在中间添加 icon 或者任何东西 FontAwesome： 1&lt;i class=&quot;fas fa-alert&quot;&gt;&lt;/i&gt; fas = FontAwesome Solid 为了发送表格，记住 &lt;form&gt; 的两个属性： action=&quot;&quot; Where we are going to send the data url 是什么样的，取决于 Server-side Technologies Node / Express Python =&gt; Django C# =&gt; ASP.NET PHP =&gt; Laravel Ruby =&gt; Ruby on Rails 免费的网站 formspree，可以简单建立一个接收表单数据的后端 method=&quot;&quot; How we are sending the data POST（常用）：把 name 域的值和对应的表单输入的内容，放在 http request 报文的 Form Data 中 GET：提交的内容以 query string name=mosh 的格式加入到 url 中，这种方式方便用户把链接 bookmark，随时访问 为了发送表单，每一个 &lt;input&gt; 都需要有 name 属性。 12345&lt;form action=&quot;https://formspree.io/...&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Name&quot; name=&quot;name&quot; /&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Email&quot; name=&quot;email&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt; Transformations (2D/3D), Transitions and Animations 变换、过渡和动画 Transformations 使用css属性 transform 旋转：rotate() 缩放：scale() 歪斜：skew() 平移：translate(), translateX(), translateY() 123456.box:hover &#123; transform: rotate(15deg); /* 顺时针旋转15度 */ transform: scale(1.5); /* 放大为1.5倍*/ transform: skew(15deg); /* 向左倾斜15度 */ transform: translate(10px, 20px); /* 平移向右10px，向下20px */&#125; 为什么不使用 relative / absolute position？ 变换更简单，使用定位position还要设置 top/bottom/right/left，很麻烦也很难 使用transformation可以使用硬件加速（hardware acceleration）在动画中更有效率 可以组合这些变换： 123456789.box-two &#123; background: tomato; transform: translate(50px) rotate(45deg);&#125;.box-three &#123; background: dodgerblue; transform: rotate(45deg) translate(50px);&#125; 变换函数的顺序不同，得到的效果也不同。根据先后顺序。 3D Transformations translateZ()：在垂直于屏幕的方向上 perspective()：使用透视函数，定义一个virtual space虚拟空间 123.box-one:hover &#123; transform: perspective(200px) translateZ(-50px);&#125; 屏幕到我们眼睛的距离是200px，translateZ会实现把box推远50px的效果。 123.box-one:hover &#123; transform: perspective(200px) rotateY(50deg);&#125; rotate() 是绕着z轴旋转，在2D平面内旋转，也可以绕x轴或y轴 默认的旋转的中心是元素的中心，可以设置： transform-origin: 0 0; 为元素的左上角 transform-origin: 0 50%; 为元素的左边中点 同时变换多个元素： 1234&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;box box-one&quot;&gt;Lorem ipsum dolor sit amet.&lt;/div&gt; &lt;div class=&quot;box box-two&quot;&gt;Lorem ipsum dolor sit amet.&lt;/div&gt;&lt;/div&gt; 12345678910111213.container &#123; perspective: 200px;&#125;.container:hover .box-one &#123; transform: rotateY(45deg); transform-origin: 0 50%;&#125;.container:hover .box-two &#123; transform: rotateX(45deg); transform-origin: 0 0;&#125; 给 .container 设置 perspective 属性，是保证容器内的元素具有同一个透视系统；给容器设置了之后，就不用在 transform 属性里单独设置 perspective() 透视函数了。 Transitions 过渡，在原始元素添加样式 transition，可以设置过渡的属性、时间、速度变化、延时 1234567.box-one &#123; background: gold; transition: transform 1s ease-in 1s;&#125;.box-one:hover &#123; transform: rotate(45deg);&#125; linear 匀速，默认 ease-in 先慢后快 ease-out 先快后慢 ease-in-out cubic-bezier: cubic-bezier(.35,.9,.42,1.06) https://cubic-bezier.com/ 可以设置多个属性的过渡，中间用 , 分隔即可： 12345678.box-one &#123; background: gold; transition: transform 1s, background 0.5s;&#125;.box-one:hover &#123; transform: rotate(45deg); background: dodgerblue;&#125; Animations 变换和过渡的组合，只能完成一个步骤，多种变换的组合就需要使用动画了。 动画通过定义关键帧来实现： 123456789101112131415161718@keyframes pop &#123; 0% &#123; transform: scale(1); &#125; 25% &#123; transform: scale(1.3); &#125; 50% &#123; transform: rotate(45deg); background: tomato; &#125; 75% &#123; transform: rotate(0); &#125;&#125; pop 是自定义的动画名称 关键帧的个数是自定义的，用百分数表示 之后给应用该变换的元素添加属性： 1234567891011.box-one &#123; background: gold; animation-name: pop; animation-duration: 4s; animation-delay: 1s; animation-iteration-count: infinite; animation-timing-function: ease-out; animation-direction: alternate; /* ani 可以弹出提示用于补全 */ animation: pop 4s ease-out 1s;&#125; Reusable Animations 很多动画效果可以复用，通过封装为一个 class 属性即可。 https://animate.style/ 通过CDN引入： 123456&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css&quot; /&gt;&lt;/head&gt; 然后根据网站上的效果，设置元素的 class 就有效果了。 123&lt;div class=&quot;box box-one animate__animated animate__bounce&quot;&gt; Lorem ipsum dolor sit amet.&lt;/div&gt; Writing Clean, Maintainable CSS CSS Best Practices Follow a naming convention 坚持一种命名规范 Kebab case: using hyphen-, .nav-bar Camel case: .navBar Pascal case: .NavBar Snake case: .nav_bar Create logical sections in your stylesheet 在样式表中建立逻辑结构 小项目，可能只有一个CSS文件，使用注释进行逻辑分区 123456789101112/* Basic styles */* &#123; box-sizing: border-box;&#125;html &#123;&#125;/* Typography */h1, h2, h3 &#123;&#125;/* Form *//* Navigation Bar */ 大项目，会将不同逻辑的CSS，为若干个CSS文件，然后合并在一起，使用 CSS 预处理器 preprocessor（sass，less）Webpack, Rollup or Parcel Avoid over-specific selectors (0, 0, 0) 避免过于特定性的选择器。让选择器特定性简洁，创建可控的选择器，2-3层嵌套至多 123456789div.nav &gt; ul.items &gt; li &#123;&#125; /* (0, 2, 3) 尽量避免子类选择器&gt;，有类选择器就别带元素选择器 */.nav-items &#123;&#125; /* (0, 1, 0) */.item &#123;&#125;.nav .item&#123;&#125;/* 对比上面的选择器，这种可能会导致 .item 样式溢出到导航栏，只能使用原属性 undo 或者叠加 !important 取消，不好。 */ Avoid !important 如果使用了 !important，说明哪个选择器是写错了，要避免过于特定的选择器 Sort CSS properties 给 CSS 属性排序：VS code，选中排序的样式，cmd+shift+p，输入 sort Take advantage of style inheritance 例如字体family，可以用母元素继承 Extract repetitive patterns 提取重复性的样式 Object-oriented CSS Avoid repetitive values 避免重复值（Keep it DRY, Don’t repeat yourself）使用CSS变量 Variables :root 伪类选择器，匹配了 html 元素，在其中设置自定义的属性或者变量。 两个 -，接着是变量名称，例如 primary-color，然后设置属性的值。 这些自定义变量会被 DOM 中所有元素继承。 1234567891011121314151617:root &#123; --primary-color: #ffdd36; --border-size: 2px; --border-radius: 10px;&#125;.one &#123; background: var(--primary-color); height: 50px; width: 50px; border: var(--border-size) solid black; border-radius: var(--border-radius);&#125;.two &#123; background: var(--primary-color);&#125; Object-oriented CSS First, Separate container and content 容器和内容分离： 12&lt;header class=&quot;hero&quot;&gt;&lt;button class=&quot;btn&quot;&gt;Sign Up&lt;/button&gt;&lt;/header&gt;&lt;aside class=&quot;side-bar&quot;&gt;&lt;button class=&quot;btn&quot;&gt;Contact&lt;/button&gt;&lt;/aside&gt; 12345678.hero .btn &#123; background: gold; border: 0; border-radius: 30px; padding: 1rem 2rem; font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Open Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif;&#125; 对于选择器 .hero .btn，.hero 是容器，.btn 是内容 如果想对 .side-bar .btn 应用相同的样式，应该怎么做？复制一份，多写一次 所以，最好是分离，直接用 .btn 作为选择器，这就可以复用这个样式了 Second, Separate structure and skin 结构和外观分离： 123456&lt;header class=&quot;hero&quot;&gt; &lt;button class=&quot;btn btn-primary&quot;&gt;Sign Up&lt;/button&gt;&lt;/header&gt;&lt;aside class=&quot;side-bar&quot;&gt; &lt;button class=&quot;btn btn-secondary&quot;&gt;Contact&lt;/button&gt;&lt;/aside&gt; 12345678910111213141516171819/* define structure */.btn &#123; border: 0; border-radius: 30px; padding: 1rem 2rem; font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Open Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif;&#125;/* define skin */.btn-primary &#123; background: gold;&#125;.btn-secondary &#123; background: dodgerblue;&#125; 使用抽象的命名 btn-primary，而不是 btn-gold，避免以后修改为别的颜色时，还要修改类名 BEM 一种常见的CSS类名的命名规范 Block - Element - Modifier 块 - 元素 - 修饰符 12345678&lt;div class=&quot;card card--popular&quot;&gt; &lt;header class=&quot;card__header&quot;&gt; &lt;span class=&quot;card__price&quot;&gt;&lt;/span&gt; &lt;/header&gt; &lt;div class=&quot;card__body&quot;&gt; &lt;button class=&quot;btn&quot;&gt;&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; card 和 btn 都是一个块 card__header，card__price，card__body 都是元素，用 块__元素 的格式 card--popular 是修饰符，不同的 card 不同的样式，可以这么修饰 本系列共 3 篇，此为 2，前见 1，后见 3。","categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://doreality.xyz/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://doreality.xyz/tags/CSS/"}]},{"title":"如何使用 Hexo 草稿","slug":"memos/hexo/hexo-draft","date":"2023-12-04T15:28:43.000Z","updated":"2023-12-04T15:28:44.044Z","comments":true,"path":"posts/2696c415.html","link":"","permalink":"https://doreality.xyz/posts/2696c415.html","excerpt":"当出现新的点子，或者一篇文章还没写完，不想发布，Hexo 可以使用草稿。","text":"当出现新的点子，或者一篇文章还没写完，不想发布，Hexo 可以使用草稿。 创建草稿 在博客目录下： 1$hexo new draft &lt;title&gt; 会存放在 source/_drafts 目录中，创建草稿时，文章没有日期时间信息。 查看草稿 在本地预览时，可以查看： 1$hexo s --draft 发布草稿 将草稿移到 _posts 目录，可以发布。 1$hexo publish &lt;file&gt;","categories":[{"name":"Memos","slug":"Memos","permalink":"https://doreality.xyz/categories/Memos/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://doreality.xyz/tags/Hexo/"}]},{"title":"不小心丢掉了环境变量PATH（~/.zshrc）该怎么办","slug":"Q&A/what-to-do-when-PATH-is-overriden","date":"2023-10-26T09:56:33.000Z","updated":"2023-12-04T15:20:51.276Z","comments":true,"path":"posts/1d2fe0ab.html","link":"","permalink":"https://doreality.xyz/posts/1d2fe0ab.html","excerpt":"写在前面：重要文件一定要备份！备份！备份！","text":"写在前面：重要文件一定要备份！备份！备份！ 问题：~/.zshrc 被清空 具体原因：配置环境变量时，输入命令 export PATH=&quot;$PATH:&quot; 时，把 $ 符号漏掉了，顺手 source ~/.zshrc ，还把同时开的其他终端tab关掉了。 好，吧。所有的 oh-my-zsh 丢掉了，PATH 消失，一些命令 alias 配置也没了。 其实能补救的很少，但是也有很多情况能再挣扎一下。 几个命令 查看使用的shell是 bash 还是 zsh： 1$ echo $0 查看 PATH 内容： 1$ echo $PATH 查看历史（内容和~/.zsh_history一致）： 1$ history 几个补救方案 如果刚 export 还没有 source，那么关掉这个shell，就会还原。 如果 export 且 source 了，但是同时开了其他的shell窗口或者标签页，或者 VS Code/IDE 等环境的终端环境，在它们中用 echo $PATH 查看你之前的 PATH，进行保存备份，重新修改到 ~/.zshrc 另外，~/.zprofile 中也保存了一些环境，我的 homebrew 和 Java 还有系统各种 bin 都在里面，只能说是不幸中的万幸，在 .zshrc 消失后，这些还在 PATH 里。 所以我丢掉的是用 oh-my-zsh 进行的主题配置，Pyenv / Conda 的环境，还有一些我可能暂时想不起来也用不到的配置…… 总结 重要的配置文件，修改的时候要再三小心！！！ 永远给自己留后路！！！ 附 .zshrc 目前的配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990# Path to your oh-my-zsh configuration.export ZSH=$HOME/.oh-my-zsh# Set name of the theme to load.# Look in ~/.oh-my-zsh/themes/# Optionally, if you set this to &quot;random&quot;, it&#x27;ll load a random theme each# time that oh-my-zsh is loaded.export ZSH_THEME=&quot;arrow&quot;# Set list of themes to pick from when loading at random# Setting this variable when ZSH_THEME=random will cause zsh to load# a theme from this variable instead of looking in $ZSH/themes/# If set to an empty array, this variable will have no effect.# ZSH_THEME_RANDOM_CANDIDATES=( &quot;robbyrussell&quot; &quot;agnoster&quot; )# Uncomment the following line to use case-sensitive completion.# CASE_SENSITIVE=&quot;true&quot;# Uncomment the following line to use hyphen-insensitive completion.# Case-sensitive completion must be off. _ and - will be interchangeable.# HYPHEN_INSENSITIVE=&quot;true&quot;# Uncomment one of the following lines to change the auto-update behavior# zstyle &#x27;:omz:update&#x27; mode disabled # disable automatic updates# zstyle &#x27;:omz:update&#x27; mode auto # update automatically without asking# zstyle &#x27;:omz:update&#x27; mode reminder # just remind me to update when it&#x27;s time# Uncomment the following line to change how often to auto-update (in days).# zstyle &#x27;:omz:update&#x27; frequency 13# Uncomment the following line if pasting URLs and other text is messed up.# DISABLE_MAGIC_FUNCTIONS=&quot;true&quot;# Uncomment the following line to disable colors in ls.# DISABLE_LS_COLORS=&quot;true&quot;# Uncomment the following line to disable auto-setting terminal title.# DISABLE_AUTO_TITLE=&quot;true&quot;# Uncomment the following line to enable command auto-correction.# ENABLE_CORRECTION=&quot;true&quot;# Uncomment the following line to display red dots whilst waiting for completion.# You can also set it to another string to have that shown instead of the default red dots.# e.g. COMPLETION_WAITING_DOTS=&quot;%F&#123;yellow&#125;waiting...%f&quot;# Caution: this setting can cause issues with multiline prompts in zsh &lt; 5.7.1 (see #5765)# COMPLETION_WAITING_DOTS=&quot;true&quot;# Uncomment the following line if you want to disable marking untracked files# under VCS as dirty. This makes repository status check for large repositories# much, much faster.# DISABLE_UNTRACKED_FILES_DIRTY=&quot;true&quot;# Uncomment the following line if you want to change the command execution time# stamp shown in the history command output.# You can set one of the optional three formats:# &quot;mm/dd/yyyy&quot;|&quot;dd.mm.yyyy&quot;|&quot;yyyy-mm-dd&quot;# or set a custom format using the strftime function format specifications,# see &#x27;man strftime&#x27; for details.# HIST_STAMPS=&quot;mm/dd/yyyy&quot;# Would you like to use another custom folder than $ZSH/custom?# ZSH_CUSTOM=/path/to/new-custom-folder# Which plugins would you like to load?# Standard plugins can be found in $ZSH/plugins/# Custom plugins may be added to $ZSH_CUSTOM/plugins/# Example format: plugins=(rails git textmate ruby lighthouse)# Add wisely, as too many plugins slow down shell startup.plugins=(git zsh-autosuggestions zsh-syntax-highlighting)source $ZSH/oh-my-zsh.sh# PATHPATH=/opt/local/bin:/opt/local/sbin:/Library/Frameworks/Python.framework/Versions/3.6/bin:/Library/Java/JavaVirtualMachines/jdk-17.jdk/Contents/Home/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/Library/Frameworks/Python.framework/Versions/3.9/bin:/opt/homebrew/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/Apple/usr/binexport MAVEN_HOME=/Users/codes/apache-maven-3.9.2export PATH=$PATH:$MAVEN_HOME/bin# 设置 Conda 环境变量export PATH=&quot;$HOME/anaconda3/bin:$PATH&quot;# 设置 pyenv 环境变量export PYENV_ROOT=&quot;$HOME/.pyenv&quot;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;eval &quot;$(pyenv init --path)&quot;export PATH=&quot;$PYENV_ROOT/shims:$PATH&quot;# ---- alias ----# use &#x27;code&#x27; to open VS Codealias code=&quot;/Applications/Visual\\ Studio\\ Code.app/Contents/Resources/app/bin/code&quot; conda activate 使用 conda activate 可能会提示你命令不能用，根据提示执行下面命令就行： 1$ conda init zsh","categories":[{"name":"Q&A","slug":"Q-A","permalink":"https://doreality.xyz/categories/Q-A/"}],"tags":[{"name":"Environment","slug":"Environment","permalink":"https://doreality.xyz/tags/Environment/"},{"name":"zsh","slug":"zsh","permalink":"https://doreality.xyz/tags/zsh/"}]},{"title":"同时使用 Anaconda 和 Pyenv","slug":"memos/python/use-conda-and-pyenv-meanwhile","date":"2023-04-25T12:56:37.000Z","updated":"2023-12-04T15:19:14.333Z","comments":true,"path":"posts/d202f7b7.html","link":"","permalink":"https://doreality.xyz/posts/d202f7b7.html","excerpt":"折腾：怎么同时用 Conda 和 Pyenv，最好不冲突。 之前已经在用 pyenv 了，新安装了 Anaconda。结果打开 conda 使用的还是 pyenv，混乱了——我在 PyCharm 配置了新环境，发现使用的是 conda 但是解释器还是用的 pyenv。","text":"折腾：怎么同时用 Conda 和 Pyenv，最好不冲突。 之前已经在用 pyenv 了，新安装了 Anaconda。结果打开 conda 使用的还是 pyenv，混乱了——我在 PyCharm 配置了新环境，发现使用的是 conda 但是解释器还是用的 pyenv。 为了保证激活 conda 时，环境是 conda 的而不是 pyenv 的，需要在 .zshrc 里，把 conda 相关的环境变量放在 pyenv 的前面。 打开终端 1$ vi .zshrc 加到最后（shift + g 直接到尾行，dd 删除当前行并拷贝到剪贴板，p 在下一行粘贴） 12345678# 设置 Conda 环境变量export PATH=&quot;/opt/anaconda3/bin:$PATH&quot;# 设置 pyenv 环境变量export PYENV_ROOT=&quot;$HOME/.pyenv&quot;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;eval &quot;$(pyenv init --path)&quot;export PATH=&quot;$PYENV_ROOT/shims:$PATH&quot; 保存退出，刷新一下。不行就关掉终端 1$ source .zshrc 验证 123(base) $ which python(bash) $ conda deactivate$ which python 第一个显示的是 conda，第二个显示的是 pyenv，就 OK","categories":[{"name":"Memos","slug":"Memos","permalink":"https://doreality.xyz/categories/Memos/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://doreality.xyz/tags/Python/"},{"name":"Environment","slug":"Environment","permalink":"https://doreality.xyz/tags/Environment/"},{"name":"Pyenv","slug":"Pyenv","permalink":"https://doreality.xyz/tags/Pyenv/"},{"name":"Conda","slug":"Conda","permalink":"https://doreality.xyz/tags/Conda/"}]},{"title":"Git 日常积累（二）","slug":"git/git-summary-2","date":"2023-04-19T04:41:34.357Z","updated":"2023-04-19T06:24:39.628Z","comments":true,"path":"posts/12a5f396.html","link":"","permalink":"https://doreality.xyz/posts/12a5f396.html","excerpt":"渐渐意识到版本控制和项目管理的必要性，记一下远程仓库和本地仓库，常见（我每次都要遇到的）报错，笨人真的从来记不住。","text":"渐渐意识到版本控制和项目管理的必要性，记一下远程仓库和本地仓库，常见（我每次都要遇到的）报错，笨人真的从来记不住。 背景 这样的一个流程：本地 blabla 写一堆东西，突然想上传到 GitHub，然后跑去建了个仓库，叫做 remote-ddd（空的，什么也没有），本地目录 ddd 也 git init 了，然后怎么能轻松 push 上去呢？ 准备好本地仓库 首先，按照 Git 日常积累（一） 中的过程，先创建仓库： 1$ git init # 新建git仓库 会提示你： 1Initialized empty Git repository in /Users/doreality/codes/ddd/.git/s 注意，这个时候要添加 .gitignore，要在git add 之前就有，否则就做不到“ignore”了，还要删除清缓存重新来（见 Git 日常积累（一） ）。所以： 12$ touch .gitignore$ vi .gitignore 可以进行第一次提交： 12$ git add .$ git status 可以看到： 123456789On branch mainNo commits yetChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: .gitignore new file: README.md 然后进行提交： 1$ git commit -m &quot;first commit&quot; 成功会提示： 1234[main (root-commit) cdfdad7] first commit 2 files changed, 2 insertions(+) create mode 100644 .gitignore create mode 100644 README.md 我创建了一个 .DS_Store，在 .gitignore 中填写了 **/.DS_Store 来屏蔽。显然，这样是屏蔽成功了，如果提交时多了在屏蔽列表的文件，就需要清缓存，然后重新 git add . 即可。 配置远程仓库连接 然后，设置去看一下远程仓库的分支名，一般新建的就是 main，修改自己本地的分支名，保持一致，使用 git branch -M 命令： 1$ git branch -M main 这样就可以配置远程仓库 remote-ddd 了： 1$ git remote add origin git@dorgh:doreality/remote-ddd.git 我的 SSH Host 为 dorgh（默认是 github.com），根据 SSH 配置的 Host 值填写即可，配置 GitHub SSH 可参考 同一主机下使用多个 GitHub 账号搭建 Hexo 博客 之后，就可以提交给远程仓库： 1$ git push -u origin &quot;main&quot; 有可能出错，记一下我遇到的错误。 git push 报错 错误一：Connection closed by remote host kex_exchange_identification: Connection closed by remote host 123456kex_exchange_identification: Connection closed by remote hostConnection closed by 198.18.0.13 port 22fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 这样一般是开了代理或者网络问题。换个网，关闭代理，或者反复多试几次，一般就可以解决。 错误二：error: failed to push 12345678To dorgh:doreality/remote-ddd.git ! [rejected] main -&gt; main (fetch first)error: failed to push some refs to &#x27;dorgh:doreality/remote-ddd.git&#x27;hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., &#x27;git pull ...&#x27;) before pushing again.hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details. 这是因为远程仓库不是空的，并且有跟本地仓库不一致的内容。 如果需要的是远程仓库的版本，需要先 pull 下来，合并再 push。 如果就是要本地仓库强制合并，使用 git push --force： 12345678910$ git push -u origin &quot;main&quot; --force git:mainEnumerating objects: 7, done.Counting objects: 100% (7/7), done.Delta compression using up to 8 threadsCompressing objects: 100% (2/2), done.Writing objects: 100% (4/4), 321 bytes | 321.00 KiB/s, done.Total 4 (delta 0), reused 0 (delta 0), pack-reused 0To dorgh:doreality/remote-ddd.git b82113f..813af5b main -&gt; mainbranch &#x27;main&#x27; set up to track &#x27;origin/main&#x27;. 其他 git pull 的时候会遇到一些需要 rebase 的情况，要注意识别命令，如果不想让本地仓库被覆盖，就不要同意 rebase。","categories":[{"name":"Git","slug":"Git","permalink":"https://doreality.xyz/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://doreality.xyz/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"https://doreality.xyz/tags/GitHub/"}]},{"title":"HTML&CSS 基础篇","slug":"dev/frontend/html&css/mosh-html-css-1","date":"2023-04-17T14:43:54.000Z","updated":"2024-03-03T13:14:59.066Z","comments":true,"path":"posts/85e3e1e6.html","link":"","permalink":"https://doreality.xyz/posts/85e3e1e6.html","excerpt":"本系列共 3 篇，此为 1，后见 2，后见 3。 课程请访问：Code With Mosh 个人学习代码","text":"本系列共 3 篇，此为 1，后见 2，后见 3。 课程请访问：Code With Mosh 个人学习代码 HTML：关注 Semantic !!! 出现 BUG 先去验证 Validation - HTML Validator - CSS Validator 语义 HTML SemanticHTML 不要在 HTML 中使用 &lt;b&gt; 和 &lt;i&gt; 因为 HTML 不再负责样式，而只专注于文档的结构； 如果需要强调内容，可以使用 &lt;em&gt; 和 &lt;strong&gt;，然后用 CSS 修改样式。 SemanticHTML 每个页面有且只有一个 &lt;h1&gt;，根据文档结构使用标题标签 例如，在 &lt;h1&gt; 后使用 &lt;h2&gt;，而不是根据字号选择 &lt;h4&gt; 之类的。样式用 CSS 修改。 转义字符 &amp;; 转义字符；&amp;copy;，&amp;nbsp;（不换行的空格） 如 my&amp;nbsp;dog，my dog 会一直在网页的同一行中显示。 a &lt;a&gt;&lt;/a&gt; 123456&lt;a href=&quot;&quot; download&gt;下载链接的内容&lt;/a&gt;&lt;a href=&quot;mailto:dieofreality@gmail.com&quot;&gt;发邮件&lt;/a&gt;&lt;a href=&quot;&quot; target=&quot;_blank&quot;&gt;新页面打开&lt;/a&gt;&lt;a href=&quot;#id&quot;&gt;跳转到id标签位置&lt;/a&gt;&lt;a href=&quot;#&quot;&gt;Back to Top&lt;/a&gt;&lt;a href=&quot;#top&quot;&gt;Back to Top&lt;/a&gt; img &lt;img src=&quot;&quot; alt=&quot;&quot;&gt; 123img &#123; object-fit: cover;&#125; video &lt;video src=&quot;&quot;&gt;&lt;/video&gt;，&lt;audio&gt;&lt;/audio&gt; HTML 的布尔值：出现在标签里，表示「真」；没出现则表示「假」。 controls：播放按钮，用户可以控制 autoplay：自动播放 loop：循环播放 仍然有浏览器（OperaMini）不支持 &lt;video&gt; 标签： 123&lt;video&gt; Your broswer doesn&#x27;t support videos.&lt;/video&gt; ol / ul / dl &lt;ol&gt; &lt;ul&gt; &lt;dl&gt; ol&gt;li*3 自动生成（Zen Coding） Description Lists, for implementing gloceries and descibing metadata 12345678910&lt;dl&gt; &lt;dt&gt;Description Term: HTML&lt;dt&gt; &lt;dd&gt;Description Details: HyperText Markup Language &lt;/dd&gt; &lt;dt&gt;CSS&lt;/dt&gt; &lt;dd&gt;Cascading Style Sheets&lt;/dd&gt; &lt;dd&gt;some text&lt;/dd&gt; &lt;dd&gt;something else&lt;/dd&gt;&lt;/dl&gt; table &lt;table&gt; SemanticHTML 为了 SEO 和阅读器，使用 &lt;thead&gt; ，&lt;tbody&gt; 和 &lt;tfoot&gt;： 1234567891011121314151617&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;head lable&lt;/th&gt; &lt;/tr&gt; &lt;thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;table date cell&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;th&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt; 123456table,td,th &#123; border: 1px solid grey; border-collapse: collapse;&#125; 通用容器元素 &lt;div&gt; ，&lt;span&gt; block level 元素会占据一整行！！！ inline 的 &lt;span&gt; 适合修饰文本之类的 语义容器元素 SemanticHTML &lt;article&gt;：block，独立、自述的内容片段 &lt;figure&gt;：block，文章搭配的插图，可以包裹 &lt;img&gt; 并在上下加上 &lt;figcaption 图片描述。 &lt;mark&gt;：inline，背景 yellow 高亮 &lt;time&gt;：inline，&lt;time datetime=&quot;2023-03-06 15:00&gt;2023年3月6日，下午3点&lt;/time&gt;&quot; 页面的基本结构 SemanticHTML main：表示页面的主要内容，每个页面只能有一个，否则验证会有问题 section：给相关内容分组，可以放在 main 中，也可以放在 article 中 header，footer：表示内容的开始/结束，可以用于页面、section 或者 article aside：表示和主体内容不相关的部分 一种语义元素应用的例子： 12345678910111213141516171819202122232425&lt;body&gt; &lt;header&gt; &lt;nav&gt; &lt;ul&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/header&gt; &lt;main&gt; &lt;section&gt; &lt;h2&gt;&lt;/h2&gt; &lt;article&gt;&lt;/article&gt; &lt;article&gt;&lt;/article&gt; &lt;/section&gt; &lt;section&gt; &lt;h2&gt;&lt;/h2&gt; &lt;article&gt;&lt;/article&gt; &lt;article&gt;&lt;/article&gt; &lt;/section&gt; &lt;/main&gt; &lt;aside&gt; &lt;/aside&gt; &lt;footer&gt; &lt;nav&gt; &lt;ul&gt;&lt;/ul&gt; &lt;/nav&gt; &lt;/footer&gt;&lt;/body&gt; CSS 样式表优先级 使用 CSS：样式优先级，inline 最高，嵌入其次，外部最低。 Embedded CSS：&lt;head&gt; &lt;style&gt;&lt;/style&gt; &lt;/head&gt; External CSS Seperation of Concerns：&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;.css&quot;&gt;&lt;/head&gt; Inline CSS：&lt;p style=&quot;color:red;&quot;&gt;&lt;/p&gt; Normalize CSS 由于不同浏览器的渲染效果不同，开发时要保持 CSS 一致化。 Selector 基本选择器 Tag：body &#123;&#125; Class：.food &#123;&#125; Id：#product &#123;&#125; Attribute（不常用）：a[href^=&quot;https&quot;][href$=&quot;.com&quot;] &#123;&#125; 关系选择器 Fragile （不要这么用，修改时会很麻烦） 选择内部全部后代（子孙）：.product p 选择内部直接后代（子）：.product &gt; p 选择同级相邻第一个：.product + p 选择同级下方的全部：.product ~ p 伪类选择器 Fragile 子元素第一个：article :first-child &#123;&#125; 子元素中每种类型的第一个：article :first-of-type &#123;&#125; 该类型作为子元素时（作为内部每个块级元素的子元素，都可以匹配一次）：article p:first-child，article p:first-of-type 选中某些行：ul li:nth-child(odd) 奇数行，table tr:nth-child(3n)（thead，tbody 和 tfoot 分别计算自己的行数，从 1 开始） 未访问：a:link 访问过：a:visited 悬停：a:hover, a:focus &#123;&#125; 用 Tab 访问时也可以改变样式 伪元素选择器 ::first-letter ::first-line ::selection &#123;backgroud-color: deeppink; &#125; ::after ::before &#123; content: '...'; &#125; （性能差一点，但是暂时不考虑性能；标签移动后，效果可能会破坏。） Premature optimization is the ROOT of ALL evils. – Donald Knuth 过早优化是一切问题的根源。 选择器优先级 ID (1, 0, 0) Class &amp; Attribute (0, 1, 0) Element (0, 0, 1) 不好的做法：h1 &#123; color:red !important &#125;，!important 会破坏优先级 好的做法：多种选择器叠加：h1#product，.highlight#product 但是也不能过于依赖，会造成很难读的情况 CSS 继承 不要继承：color: initial; 显式继承：border: inherit; Color Color Picker rgb(R, G, B) rgba(R, G, B, Transparency(0-1)) hex: #xxxxxx hsl(色相, 饱和度%, 亮度%) hsl(53deg 50% 60%) hsla( , %, %, 0-1) 渐变 CSS 渐变生成器 background: linear-gradient(to top/right/bottom/left | 45deg, red, green, blue); linear-gradient(to right, red 10%, green 50%) 百分比表示 红色 从0到10% 和绿色从 50% 到 100% 到范围内实色填充，其他区域渐变 radial-gradient(circle at top left, white, yellow) Shapes CSS Shapes box-shadow: 10px 20px 5px blue right bottom radius text-shadow: 同上 rgba(0, 0, 0, 0.2) 带不透明度调节到阴影可以更好融合到背景里 本系列共 3 篇，此为 1，后见 2，后见 3。","categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://doreality.xyz/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://doreality.xyz/tags/CSS/"}]},{"title":"使用 GitHub Actions 自动添加 TOC 到 README","slug":"memos/add-toc-to-readme-with-github-actions","date":"2023-04-02T15:14:35.000Z","updated":"2023-12-04T15:17:17.165Z","comments":true,"path":"posts/9bb3bd63.html","link":"","permalink":"https://doreality.xyz/posts/9bb3bd63.html","excerpt":"在 git push 时，给 main 分支下的 README.md 自动生成目录！","text":"在 git push 时，给 main 分支下的 README.md 自动生成目录！ 找到 Repo 的 「Settings」-「Actions」-「General」-「Workflow permissions」，修改为 Read and write permissions 在 Repo 的 「Actions」中，新建 workflow 选择 「set up a workflow yourself」 配置，可以命名为 toc.yml： 1234567891011121314151617181920212223 on: push: branches: [main] paths: [&#x27;README.md&#x27;] pull_request: branches: [main] paths: [&#x27;README.md&#x27;]jobs: build: runs-on: ubuntu-latest timeout-minutes: 5 steps: - uses: actions/checkout@v2 - run: | curl https://raw.githubusercontent.com/ekalinin/github-markdown-toc/master/gh-md-toc -o gh-md-toc chmod a+x gh-md-toc ./gh-md-toc --insert --no-backup README.md rm -f ./gh-md-toc - uses: stefanzweifel/git-auto-commit-action@v4 with: commit_message: Auto update markdown TOC Commit 后，目录中生成 .github/workflow/toc.yml。 之后再 push 的时候，就会自动调用 workflow 在 README.md 生成目录了。 注意：一定要把「Settings」里的读写打开，否则会生成失败。","categories":[{"name":"Memos","slug":"Memos","permalink":"https://doreality.xyz/categories/Memos/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://doreality.xyz/tags/GitHub/"}]},{"title":"JavaScript 基础篇","slug":"dev/frontend/js/mosh-js-basics","date":"2023-04-02T09:39:14.000Z","updated":"2024-03-03T13:15:36.793Z","comments":true,"path":"posts/318faa67.html","link":"","permalink":"https://doreality.xyz/posts/318faa67.html","excerpt":"本系列 2 篇，此为 1，后见 2 课程请访问：Code With Mosh 个人学习代码 Operators &amp; Flow Control &amp; Object &amp; Arrays &amp; Function","text":"本系列 2 篇，此为 1，后见 2 课程请访问：Code With Mosh 个人学习代码 Operators &amp; Flow Control &amp; Object &amp; Arrays &amp; Function Operators == 和 === == 不严格等价，如果两边类型不同，会把右边的操作数自动转换为左边的类型，再判断值是否相等； === 严格等价，值和类型 Value 和 Type 都要相同才真。平时主要用三个等号。 非布尔值进行逻辑运算 false || 1的结果是 1； JS 中存在 Falsy 类假（false）的值： undefined null 0 false '' (empty string) NaN (Not a Number) 其他所有不是 Falsy 的值都是 Truthy。 || 短路原则 false || 1 || 2 的结果是 1 1234let userColor = undefined;let defaultColor = &#x27;blue&#x27;;// 如果用户没有选择颜色，那么就使用默认颜色。let currentColor = userColor || defaultColor; Bitwise: | &amp; 1234567let readPermission = 4; // 00000100let writePermission = 2; // 00000010let executePermission = 1; // 00000001let myPermission = readPermission | writePermission | executePermission; // 给用户权限let message = (myPermission &amp; readPermission) ? &#x27;yes&#x27; : &#x27;no&#x27;; // 三元表达式：判断用户是否具有某权限 注意事项 变量命名要有意义； 函数单一性功能； 密切相关的代码放在一起，和别的空行。 Flow Control switch if-else 替代 switch（过时） do-while do-while 的函数体至少会执行一次 for…in：对象遍历 123for (let key in obj) &#123; console.log(key, obj[key]);&#125; for…of：数组遍历 123for (let value of arr) &#123; console.log(value);&#125; Object 工厂函数和构造函数 （效果一样，随便用哪个） Factory Function 1234567891011121314// Factory Functionfunction createCircle(radius) &#123; // Camel Notation // return an object return &#123; radius, // use parameter as value draw() &#123; // no need &#x27;function&#x27; keyword console.log(&#x27;draw&#x27;); &#125; &#125;;&#125;const circle1 = createCircle(1);console.log(circle1); Constructor Function 12345678910111213// Constructor Functionfunction Circle(radius) &#123; // Pascal Notation this.radius = radius; this.draw = function() &#123; console.log(&#x27;draw&#x27;); &#125;&#125;// 1. create an empty js object &#123;&#125;, // 2. &#x27;this&#x27; reference to &#123;&#125;// 3. &#x27;this&#x27; creates propeties to obj// &#123;&#125;.radius = radius, &#123;&#125;.draw = ..const circle1 = new Circle(1); const 对象 const obj = new someObj();： 不能 re-assign 可以 动态 增删属性和方法。 1delete obj.property; 对象的构造器 obj.constructor 使用构造函数创建的对象，构造器就是构造函数本身 使用工厂函数创建的对象，构造器是 JavaScript 内置的构造函数 Object()，因为工厂函数使用了 &#123;&#125; （object literal syntax），它在内部就是调用了 Object() 以下的构造对象的方法是等价的： new String() === ' ', &quot; &quot;, ` ` new Boolean()=== true, false new Number() === 1, 2, ... 函数是对象（万物是对象） new Function(parameters, statements) 123456const Circle1 = new Function(&#x27;radius&#x27;,`this.radius = radius;this.draw = function() &#123; console.log(&#x27;draw&#x27;);&#125;`); const circle1 = &#123;&#125;; Circle.call(circle1, 1); === const circle1 = new Circle(1); Circle.call(thisArg, ArgList); 如果不使用 new，this 指向 window Value Type and Reference Type 值拷贝类型 Primitive: Number String Boolean Symbol undefined null 引用（地址）拷贝类型 Object: Object Function Array const 声明的变量： 如果是值拷贝，则不能修改赋值； 如果是引用拷贝，则可以修改对象的属性内容，但不能 re-assign 另一个对象，因为会修改地址。 对象不是可枚举 not iterable，不能直接直接用for..of 遍历： 1234567for (let key in obj)&#123;&#125;;for (let key of Object.keys(obj))&#123;&#125;// each entry is [key, value]for (let entriy of Object.entries(obj))&#123;&#125;; // key if in this objectif (key in object) return true; 对象拷贝 怎么把值拷贝过去？ 遍历拷贝 const newObj = Object.assign(&#123;&#125;, oldObj); separate operator ... ：const another = &#123; ...circle &#125;; JS 的 GC Garbage Collector 垃圾回收是自动进行的。 String Literal 和 Template Literal 123456const message = &#x27; hi there. &#x27;;const s = new String(&#x27;hello then&#x27;);message.trim();message.trimLeft();message.trimRight();message.split(&#x27; &#x27;); Date 123456789const now = new Date();const date1 = new Date(&#x27;May 11 2022 09:00&#x27;);const date2 = new Date(2022, 4, 11, 9);// month from 0 to 11now.getxx();now.setFullYear(2017);now.toDateString();now.toTimeString();now.toISOString(); 用对象的眼光观察 设想，如果是你来设计某个事物，构成一个对象，会需要什么属性和方法。 Arrays 增加 Adding 12345678910let a = [];// Enda.push(&#x27;a&#x27;, &#x27;b&#x27;); // [&#x27;a&#x27;, &#x27;b&#x27;]// Beginninga.unshift(1, 2); // [1, 2, &#x27;a&#x27;, &#x27;b&#x27;]// Mida.splice(2, 0, 3, 4); // [1, 2, 3, 4, &#x27;a&#x27;, &#x27;b&#x27;]// 2 means start index is 2// 0 means delete 0 element// index &gt;= length，则在末尾添加新元素 查找 Finding Primitive 12345678910111213let a = [1, 2, 3, 4, 1];// find firsta.indexOf(1); // 0a.indexOf(&#x27;a&#x27;); // -1a.indexOf(1, 2); // 4 (from index 2 to find)// find lasta.lastIndexOf(1); // 4// exist or notif(a.indexOf(1) !== -1) &#123;&#125;if(a.includes(1))&#123;&#125; Reference 1234567891011121314151617const courses = [ &#123;id: 1, name: &#x27;a&#x27;&#125;, &#123;id: 2, name: &#x27;b&#x27;&#125;];// find first matched element//const course = courses.find(function(course)&#123;// return course.name === &#x27;a&#x27;;//&#125;)// use arrow functionconst course = courses.find(course =&gt; course.name === &#x27;a&#x27;);// find(predicate or callback function)// findIndex()// 当返回值为 true，返回结果；// 当返回值为 false，继续在数组中向后查找。 删除 Removing 1234567891011121314const numbers = [1, 2, 3, 4];// Endconst last = numbers.pop(); // last === 4, // numbers [1, 2, 3]// Beginningconst first = numbers.shift();// Middlenumbers.splice(1, 2);// from index 1, delete 2 elements// return elements that be removed 清空 Emptying 123456789101112131415let numbers = [1, 2, 3, 4];let another = numbers;// Sol 1 单一引用时numbers = []; // 但是 another 还指向那块内存空间// Sol 2 多个引用时numbers.length = 0;// Sol 3numbers.splice(0, numbers.length);// Sol 4 不推荐while (numbers.length &gt; 0) numbers.pop(); 合并拆分 Combining and Slicing 1234567891011const first = [1, 2, 3];const second = [4, 5, 6];// combine [1, 2, 3, 4, 5, 6]const combined = first.concat(second);// sconst slice = combined.slice(1); // from index 1 to end// combined.slice(1, 2): from index 1 copy 2 elem// combined.slice(): copy all 如果拷贝了引用类型，那么拷贝的是它的引用 12345678const a = [&#123;id : 1&#125;];const b = [2, 3, 4];const combined = a.concat(b);// [&#123;id: 1&#125;, 2, 3, 4]a[0].id = 10;// [&#123;id: 10&#125;, 2, 3, 4]// slice 同理，也是拷贝的引用 Spread Operator ... 拆分数组，把每个元素单独返回。 12345678const first = [1, 2, 3];const second = [4, 5, 6];const combined = [...first, &#x27;a&#x27;, ...second, &#x27;b&#x27;];const copy = [...combined];let [a, b, c] = [...first];// a === 1, b === 2, c === 3 遍历 Iterating 123456789const numbers = [1, 2, 3];// for of / for infor (let number of numbers) console.log(number);// forEachnumbers.forEach((number, index) =&gt; console.log(index, number)); 连接 Joining Arrays 12345678910const numbers = [1, 2, 3]// join const joined = numbers.join(&#x27;,&#x27;); // 1,2,3// numbers.join() === &#x27;1,2,3&#x27; 默认用逗号// change space&#x27; &#x27; to hyphen&#x27;-&#x27; in urlconst message = &quot;This is my first message&quot;;const parts = message.split(&#x27; &#x27;); // word arrayconst combined = parts.join(&#x27;-&#x27;); // a string 排序 Sorting 原地修改，不返回新的数组。 不指定回调函数，会按照元素转换为字符串的 Unicode 顺序 ASC numbers.sort() DESC numbers.reverse() Reference 123456789101112131415161718const courses = [&#123;id: 1, name: &#x27;Node.js&#x27;&#125;,&#123;id: 2, name: &#x27;javascript&#x27;&#125;];// 按升序courses.sort(function(a, b) &#123;// a &lt; b =&gt; -1 负数表示 a 前 b 后// a &gt; b =&gt; 1 正数表示 a 后 b 前// a === b =&gt; 0 0 表示不交换顺序// 消除大小写敏感const nameA = a.name.toUpperCase();const nameB = b.name.toUpperCase();if (nameA &lt; nameB) return -1;if (nameA &gt; nameB) return 1;return 0;&#125;); 简单的排序： 12345// a - b &lt; 0 不交换// a - b &gt; 0 交换// a - b === 0 不动// 从小到大arr.sort((a, b) =&gt; a.value - b.value); 测试 Testing Elements 新特性，旧浏览器可能不兼容。 12345678910// 依次搜索每个元素，如果出现了负数就直接返回 false，不向后继续测试const allPositive = numbers.every(function(value)&#123; return value &gt;= 0;&#125;);// 只要出现了符合条件的一个，就返回const atLeastOnePositive = numbers.some(function(value)&#123; return value &gt;= 0;&#125;); 筛选 Filtering 12345const numbers = [1, 2, -1, -3];const filtered = numbers.filter(n =&gt; n &gt;= 0);// [1, 2]// 返回符合条件的元素组合成的数组// 还可以传index等参数 同样可以筛选符合条件的对象。 映射 Mapping 把每个元素映射为其他的东西。 映射成字符串： 12const items = filtered.map(n =&gt; &#x27;&lt;li&gt;&#x27; + n + &#x27;&lt;\\n&gt;&#x27;);const html = &#x27;&lt;ul&gt;&#x27; + items.join(&#x27;&#x27;) + &#x27;&lt;\\ul&gt;&#x27;; 映射成对象： 123// obj 的 &#123;&#125; 会被默认识别为函数体的&#123;&#125;// 所以如果直接返回对象的话，要加一层 ()const items = filtered.map(n =&gt; (&#123;value: n&#125;)); Chaining methods： 链式调用 123456// 依次对前面生成的数组进行处理const items = numbers .filter(n =&gt; n &gt;= 0) .map(n =&gt; (&#123; value: n &#125;)) .filter(obj =&gt; obj.value &gt; 1) .map(obj =&gt; obj.value); 缩减 Reducing 把整个数组缩减成一个单一的值：数字、字符串、对象…… 12345678910111213const numbers = [1, 2, -3, 4];const sum = numbers.reduce( (accumulator, currentValue) =&gt; accumulator + currentValue);// a = 1, c = 2 =&gt; a = 3// a = 3, c = -3 =&gt; a = 0// a = 0, c = 4 =&gt; a = 4// sum = 4// 默认时 a 是第一个元素，c 是第二个元素// 给 reduce() 传入第二个参数初始化 a，但是会多一次运算 Function Hoisting Function declaration will be moved to the top of the file by JavaScript engine when executing. But function expression will not. 函数声明 12345walk();// funtion declarationfunction walk() &#123; console.log(&#x27;walk&#x27;);&#125; 函数表达式 1234567891011// Uncaught ReferenceError:// Cannot access &#x27;run&#x27; before initialization// run();// named / anonymous function expressionconst run = function() &#123; console.log(&#x27;run&#x27;);&#125;;let move = run; // reference to the same afrun();move(); arguments 每个函数内，有一个内置的对象：arguments，因为有迭代器 Symbol.iterator，所以可以使用 for...of 遍历： 1234567function sum() &#123; let total = 0; for (let value of arguments) total += value; return total;&#125;console.log(sum(1, 2, 3, 4)); Rest Parameter ... Rest Operator 和 Spread Operator 区分： let [a, b, c] = [...numbers] 是把 numbers 数组的每个元素单独拿出来 function fn(a, b, ...args) 是将多余的parameters 放到一个数组 args 里 12345function sum(...args) &#123; return args.reduce((a, b) =&gt; a + b);&#125;console.log(sum(1, 2, 3, 4, 5, 6, 7)); 使用 Rest Operator 的参数叫做 Rest Parameter，必须是参数列表的最后一个参数。 Default Parameter 函数的参数列表中，有默认值的参数，在调用函数时，可以不显式赋值。 最佳实践是把有默认值的参数都放在最后，这样调用传参时不用 undefined 占位跳过（很丑） Getters &amp; Setters 12345678910111213141516const person = &#123; firstName: &#x27;Mosh&#x27;, lastName: &#x27;Hamedani&#x27;, get fullName() &#123; return `$&#123;this.firstName&#125; $&#123;this.lastName&#125;`; &#125;, set fullName(value) &#123; const parts = value.split(&#x27; &#x27;); this.firstName = parts[0]; this.lastName = parts[1]; &#125;&#125;;// setter =&gt; change(mutate) propertiesperson.fullName = &#x27;John Smith&#x27;;// getter =&gt; access propertiesconsole.log(person.fullName); try &amp; catch 1234567try &#123; // some codes, then throw new Error(&#x27;An error.&#x27;)&#125; catch(e) &#123; // deal with the error // or give some feedback to user&#125; Scope (Local vs Global) 12345678const color = &#x27;red&#x27;; // globalfunction start() &#123; const color = &#x27;blue&#x27;; // local if (true) &#123; console.log(color); // blue &#125;&#125; 局部变量会覆盖掉同名的全局变量。 全局变量可以在任意地方访问，所以要避免声明和使用全局变量，因为可能在某个位置就把需要的值改变了。 Let vs Var 在函数内部，作用域范围： var 声明的变量是 function-scoped，在函数内部任意位置都能访问 ES6（ES2015）开始使用 let 和 const 声明变量是 block-scoped，在代码块（for 循环 或者 if 语句）之外都无法访问，但是在内部的代码块中可以访问。 全局作用域： var 声明的全局变量，会添加到 window 对象的属性中，而 window 对象是唯一的，可能会覆盖其本身的同名属性。所以应该避免给 window 对象添加成员。 let 不会添加到全局对象。 在 Global 作用域定义的函数，也会添加到 window对象的成员，也应该避免（使用 module）。 另外，var 声明的变量，可以重复声明。 ‘this’ The this keyword references “the object that is executing the current function”. this in: method -&gt; obj function -&gt; global (window in browser, global in node) 1234567891011const video = &#123; title: &#x27;a&#x27;, tags: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], showTags() &#123; this.tags.forEach((tag)=&gt;&#123; console.log(this.title, tag); &#125;, this); &#125;&#125;;video.showTags(); forEach 的第一个参数是一个回调函数 callbackfn，执行回调函数的是 window 对象，而不是 video 对象，所以这个回调函数不是 method，回调函数中使用的 this 就是 window 增加第二个参数 thisArg 传入一个对象，那么回调函数中 this 指代的就是传入的对象。 但是，并不是所有函数都可以传入 thisArg。 Change ‘this’ 中继变量 self bind 方法 箭头函数，继承 this （不好的办法）在 this 被修改之前，给一个别名 const self = this 123456showTags() &#123; const self = this; this.tags.forEach(function(tag) &#123; console.log(self.title, tag); &#125;);&#125; 函数对象的内置方法：call, apply, bind 123456789function playVideo(a, b) &#123; console.log(this);&#125;playVideo.call(&#123; name:&#x27;apple&#x27; &#125;, 1, 2);playVideo.apply(&#123; name:&#x27;apple&#x27; &#125;, [1, 2]);playVideo.bind(&#123; name:&#x27;apple&#x27; &#125;, [1, 2])();playVideo(); // window call() 把第一个参数绑定 this，单独传入参数，调用； apply() 把第一个参数绑定 this，用数组方式传入参数，调用； bind() 把第一个参数绑定 this，不调用。 （旧办法）bind 匿名函数 12345showTags() &#123; this.tags.forEach(function(tag) &#123; console.log(this.title, tag); &#125;.bind(this));&#125; （ES6 新办法）箭头函数会继承容器函数的 this： 12345showTags() &#123; this.tags.forEach(tag =&gt; &#123; console.log(this.title, tag); &#125;);&#125; 本系列 2 篇，此为 1，后见 2","categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doreality.xyz/tags/JavaScript/"}]},{"title":"终端命令提示符 prompt 样式定制","slug":"memos/macOS/oh-my-zsh-prompt","date":"2022-07-15T02:40:15.000Z","updated":"2023-12-04T15:17:13.108Z","comments":true,"path":"posts/47012712.html","link":"","permalink":"https://doreality.xyz/posts/47012712.html","excerpt":"终端的命令提示符样式定制：macOS / Linux","text":"终端的命令提示符样式定制：macOS / Linux 如果使用的是 oh-my-zsh，不同的主题就可以对应不同的命令提示符配置，但是要个性化配置可以参考如下： oh-my-zsh修改主题添加全路径显示 Linux 终端命令提示符总结","categories":[{"name":"Memos","slug":"Memos","permalink":"https://doreality.xyz/categories/Memos/"}],"tags":[{"name":"oh-my-zsh","slug":"oh-my-zsh","permalink":"https://doreality.xyz/tags/oh-my-zsh/"}]},{"title":"macOS 修改主机名等","slug":"memos/macOS/mac-hostname-and-other-names","date":"2022-07-15T02:37:48.000Z","updated":"2023-12-04T15:17:06.533Z","comments":true,"path":"posts/66790ec6.html","link":"","permalink":"https://doreality.xyz/posts/66790ec6.html","excerpt":"修改终端上显示的主机名。","text":"修改终端上显示的主机名。 Mac 修改主机名、计算机名、本地主机名、xcode作者名、终端前缀","categories":[{"name":"Memos","slug":"Memos","permalink":"https://doreality.xyz/categories/Memos/"}],"tags":[{"name":"macOS","slug":"macOS","permalink":"https://doreality.xyz/tags/macOS/"}]},{"title":"在终端中进入 Python 的 venv","slug":"memos/python/go-into-venv-in-shell","date":"2022-06-24T14:38:56.000Z","updated":"2023-12-04T15:18:51.839Z","comments":true,"path":"posts/4f8c09df.html","link":"","permalink":"https://doreality.xyz/posts/4f8c09df.html","excerpt":"怎么从终端进入一个 Python 的虚拟环境 venv？","text":"怎么从终端进入一个 Python 的虚拟环境 venv？ 进入 1$ source &quot;the venv root path&quot;/bin/activate","categories":[{"name":"Memos","slug":"Memos","permalink":"https://doreality.xyz/categories/Memos/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://doreality.xyz/tags/Python/"},{"name":"Environment","slug":"Environment","permalink":"https://doreality.xyz/tags/Environment/"}]},{"title":"mac 如何彻底删除 Python","slug":"memos/python/delete-python-on-mac","date":"2022-06-23T08:29:36.000Z","updated":"2023-12-04T15:18:28.763Z","comments":true,"path":"posts/4594a661.html","link":"","permalink":"https://doreality.xyz/posts/4594a661.html","excerpt":"完全删除 mac 中的不同版本的 Python","text":"完全删除 mac 中的不同版本的 Python Mac 删除/卸载 自己安装的python","categories":[{"name":"Memos","slug":"Memos","permalink":"https://doreality.xyz/categories/Memos/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://doreality.xyz/tags/Python/"},{"name":"Environment","slug":"Environment","permalink":"https://doreality.xyz/tags/Environment/"}]},{"title":"使用 Homebrew 安装出现 git 报错","slug":"Q&A/brew-installation-error","date":"2022-06-20T03:12:38.000Z","updated":"2023-04-07T16:26:58.611Z","comments":true,"path":"posts/74a7d1c5.html","link":"","permalink":"https://doreality.xyz/posts/74a7d1c5.html","excerpt":"使用 Homebrew 安装的时候出现 git 的报错。","text":"使用 Homebrew 安装的时候出现 git 的报错。 问题如下： 根据提示，添加两条 git config 即可：","categories":[{"name":"Q&A","slug":"Q-A","permalink":"https://doreality.xyz/categories/Q-A/"}],"tags":[{"name":"Homebrew","slug":"Homebrew","permalink":"https://doreality.xyz/tags/Homebrew/"}]},{"title":"使用 Pyenv 管理 Python","slug":"memos/python/manage-py-by-pyenv","date":"2022-06-20T03:10:51.000Z","updated":"2023-12-04T15:18:55.115Z","comments":true,"path":"posts/e30c74da.html","link":"","permalink":"https://doreality.xyz/posts/e30c74da.html","excerpt":"管理电脑上不同版本的 Python： 参考：https://github.com/pyenv/pyenv 环境：macOS + Homebrew + Zsh","text":"管理电脑上不同版本的 Python： 参考：https://github.com/pyenv/pyenv 环境：macOS + Homebrew + Zsh 安装 Pyenv 12$brew update$brew install pyenv 如果 brew 出现了 git 的报错：解决 Homebrew 出现 git 报错 设置 Shell 添加 $PYENV_ROOT 到 $PATH 添加 pyenv 为 shell 命令 安装 pyenv 到 shell function 123$echo &#x27;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&#x27; &gt;&gt; ~/.zshrc$echo &#x27;command -v pyenv &gt;/dev/null || export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#x27; &gt;&gt; ~/.zshrc$echo &#x27;eval &quot;$(pyenv init -)&quot;&#x27; &gt;&gt; ~/.zshrc 设置完毕，重启 shell 安装指定版本的 Python 首先安装依赖： 1$brew install openssl readline sqlite3 xz zlib tcl-tk 安装 Python 例如安装 Python 3.6.10： 1$pyenv install 3.6.10 然后经过漫长的等待，出现下列语句表示安装成功： 1Installed Python-3.6.15 to /Users/doreality/.pyenv/versions/3.6.15 使用 Pyenv 1234$pyenv versions # 查看已安装的版本$pyenv global 3.6.15 # 指定全局模式下的 Python 版本为 3.6.15$pyenv local 3.10.10 # 指定当前目录下的 Python 版本为 3.10.10$pyenv uninstall 3.6.15 # 删除 3.6.15 版本 Pyenv 虚拟环境 想在现有的Python版本基础上，创建某个虚拟环境。 1234567891011# 创建一个虚拟环境，名为 myenv$pyenv virtualenv 3.6.15 myenv # 进入$pyenv activate myenv# 退出$pyevn deactivate myenv# 删除$pyenv uninstall myenv# 删除 Pyenv 管理的所有虚拟环境$pyenv uninstall --all","categories":[{"name":"Memos","slug":"Memos","permalink":"https://doreality.xyz/categories/Memos/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://doreality.xyz/tags/Python/"},{"name":"Environment","slug":"Environment","permalink":"https://doreality.xyz/tags/Environment/"},{"name":"Pyenv","slug":"Pyenv","permalink":"https://doreality.xyz/tags/Pyenv/"}]},{"title":"「LCTHW」函数与指针篇（EX 14-18）","slug":"dev/backend/c/lcthw/lcthw-ex14-18","date":"2022-06-01T14:59:03.000Z","updated":"2023-04-07T16:30:46.814Z","comments":true,"path":"posts/4b675d3.html","link":"","permalink":"https://doreality.xyz/posts/4b675d3.html","excerpt":"Learn C The Hard Way, notes for ex14 to ex18.","text":"Learn C The Hard Way, notes for ex14 to ex18. Exercise 14. Writing and Using Functions 用 for 读一个字符串：不用判断长度，可以判断 \\0 123for (i = 0; arg[i] != &#x27;\\0&#x27;; i++) &#123; char ch = arg[i];&#125; ctype.h funtion meaning isalnum() checks for an alphanumeric character; it is equivalent to (isalpha© || isdigit©). isalpha() checks for an alphabetic character; in the standard “C” locale, it is equivalent to (isupper© || islower©). In some locales, there may be additional characters for which isalpha() is true–letters which are neither uppercase nor lowercase. isascii() checks whether c is a 7-bit unsigned char value that fits into the ASCII character set. isblank() checks for a blank character; that is, a space or a tab. iscntrl() checks for a control character. isdigit() checks for a digit (0 through 9). isgraph() checks for any printable character except space. islower() checks for a lowercase character. isprint() checks for any printable character including space. ispunct() checks for any printable character which is not a space or an alphanumeric character. isspace() checks for white-space characters. In the “C” and “POSIX” locales, these are: space, form-feed (‘\\f’), newline (‘\\n’), carriage return (‘\\r’), horizontal tab(‘\\t’), and vertical tab (‘\\v’). isupper() checks for an uppercase letter. isxdigit() checks for hexadecimal digits, that is, one of 0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F. Forward Declaration 12345678910111213141516// forward declarations: solve chicken-and-egg problems// use it before actually define it.int can_print_it(char ch);void print_letters(char arg[], int len);void print_arguments(int argc, char *argv[])&#123; // call can_print_it // call print_letters&#125;int main(int argc, char *argv[])&#123; print_letters(argc, argv);&#125; 原因： 最终要创建自己的头文件，头文件中包含的都是前置声明 headers: declare define， enum， type，funtions 避免 children-and-egg 问题 如果两个函数互相调用，那么谁先定义呢？ 避免了调用嵌套的困扰，不用按照调用的方式顺序定义 calling order 可以按照一些逻辑顺序进行函数的定义 logical order：例如实际使用的函数次序 main() 放在最后：更习惯的用法 can_print_it() 定义成函数的原因： 可以方便修改里面的内容 可以多个地方调用 不要使用 K&amp;R C 的函数声明方法 Exercise 15. Pointers, Dreaded Pointers ages[i]: i: an index / address since it’s a location inside ages that we want ages: (base) address a location in the computer’s memory where all of these integers start C compiler will replace ages anywhere you type it with the address of the very first integer in ages C 把大块的字节数组（也就是内存），抽象为不同大小的类型 C thinks your whole computer is one massive array of bytes What C does is layer on top of this massive array of bytes the concept of types and sizes of those types Pointers A pointer is simply an address pointing somewhere inside the computer’s memory with a type specifier so that you get the right size of data with it. Pointers are just numbers. Ask the OS for a chunk of memory and use a pointer to work with it. This includes strings and something you haven’t seen yet, structs Ask the OS for a chunk of memory and use a pointer to work with it. This includes strings and something you haven’t seen yet, structs Take the address of a function, so you can use it as a dynamic callback. Scan complex chunks of memory, converting bytes off of a network socket into data structures or parsing files. 其他情况，几乎都可以用 arrays 来解决，用数组的操作方法来使用指针（索引）。 These days, the syntax to access an array versus a pointer are translated into the same machine code and optimized in the same way. 只有在十分确定的情况，再用指针来优化。 Pointers NOT Arrays 12int arr[] = &#123;1, 2, 3, 4, 5&#125;;int *ptr = arr; sizeof() sizeof(ptr) 得到的是指针的大小，32 位机器是 4 Bytes，64 位机器是 8 Bytes； sizeof(arr) 得到的是数组的大小，5 * sizeof(int) 赋值 ptr = arr，是把数组的起始地址给 ptr arr = ptr，error: assignment to expression with array type 增减 ptr++，让指针指向接下来一个该类型的元素 arr++，error: lvalue required as increment operand，数组名 arr 不是左值 数组名也不是常指针（即指针常量，a const pointer is pointed at a static address）type *const ptr，由上述三点可以判断。 1234567891011121314151617181920// a constant integer Aint const A;const int A; // a pointer B, point at an constant integer // 常量指针 / 指向常量的指针// B 可以指向别的常量，B 的值可变// 但是不能修改其地址内的内容，*B 不可变const int *B;int const *B;// a constant pointer C // 常指针/指针常量// C 指向的地址不再变化，C 的值不可变// 但是可以修改其地址内的内容，*C 可变int *const C;// a constant pointer D points at a constant integer// D 和 *D 都不可变const int *const D; 指针数组和数组指针 123456789101112// 指针数组，每个元素 names[i] 是一个指针char *names[] = &#123; &quot;Alan&quot;, &quot;Frank&quot;&#125;;printf(&quot;%s, %s, %s, %s\\n&quot;, names[1], *(names + 1));// 数组指针，是一个指针，指向一维数组的地址// name[i] == names + i，移动 i * N 个内存单元char string[N] = &#123; &quot; &quot; &#125;;char (*names)[N] = &amp;string;printf(&quot;string = %s, names = %s, %s\\n&quot;, string, *names, names[0]); Exercise 16. Structs And Pointers to Them strdup(const char *s)，in string.h The strdup() function returns a pointer to a new string which is a duplicate of the string s. Memory for the new string is obtained with malloc(3), and can be freed with free(3). char *a = strdup(&quot;Hello, world&quot;); char a[20]; strcpy(a, &quot;Hello, world&quot;); free(frank); frank = NULL; 释放之后，把指针置空，否则后面如果还访问这个指针，可能会读到奇怪的内容 free() 把指针指向的内容清空（或者说，告诉 OS 不再使用），但是指针的值没有改，可能还可以正常输出内容 Valgrind 可以提示这个错误 invalid read / invalid free() Memory Leak 使用 Valgrind 检查内存泄漏： valgrind --leak-check=full --show-reachable=yes -v ./ex16 Exercise 17. Heap and Stack Memory Allocation make a prototype to initialize it 1struct Address addr = &#123;.id = i, .set = 0&#125;; nested arrow 1struct Address *addr = &amp;conn-&gt;db-&gt;rows[i]; &amp;conn-&gt;db-&gt;rows[i] that reads “get the i element of rows, which is in db, which is in conn, then get the address of (&amp;) it.” atoi 123int atoi(const char *nptr);long atol(const char *nptr);long long atoll(const char *nptr); The atoi() function converts the initial portion of the string pointed to by nptr to int. The behavior is the same as strtol(nptr, NULL, 10); except that atoi() does not detect errors. 1long int strtol(const char *nptr, char **endptr, int base); fread 12345678910111213141516size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);FILE *fopen(const char *path, const char *mode);int fclose(FILE *stream);int fflush(FILE *stream);int fseek(FILE *stream, long offset, int whence);long ftell(FILE *stream);void rewind(FILE *stream);int fgetpos(FILE *stream, fpos_t *pos);int fsetpos(FILE *stream, const fpos_t *pos); The function fread() reads nmemb items of data, each size bytes long, from the stream pointed to by stream, storing them at the location given by ptr. 成功返回读写的数据项的个数，失败返回0. 回到文件开头：rewind(stream) == (void) fseek(stream, 0L, SEEK_SET) strncpy 12char *strcpy(char *dest, const char *src);char *strncpy(char *dest, const char *src, size_t n); The strncpy() function is similar, except that at most n bytes of src are copied. Warning: If there is no null byte among the first n bytes of src, the string placed in dest will not be null-terminated. So add the null byty '\\0' manually. Heap and Stack C is using the real CPU’s actual machinery to do its work, and that involves a chunk of RAM called the stack and another called the heap. Heap：malloc and free. ask OS to register a piece of memory, return a pointer after using, give it back to OS, so that won’t leak Stack Just like a stack data struction, LIFO Store the local variables, even those in main function. prevent leak 堆和栈的三个主要问题： 如果在函数中，使用 malloc 申请了一块内存，而指针是在栈上定义的，那么函数结束之后，指针会出栈，然后内存就丢失（泄漏） 如果在栈上申请了太大的数据（large structs and array），可能会造成 stack overflow 栈溢出，导致错误。这时应该用 malloc。 如果在函数定义的局部变量，使用指针返回，那么就会得到 segmentation fault 段错误，因为变量在函数结束的时候已经出栈消失，指针指向一个 dead space 程序结束后，操作系统会回收空间，但是有时候不会立刻回收；所以使用错误退出，exit(1)，让操作系统当作错误，直接回收。","categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"}],"tags":[{"name":"C","slug":"C","permalink":"https://doreality.xyz/tags/C/"}]},{"title":"「LCTHW」C 语言基础篇（EX 1-13）","slug":"dev/backend/c/lcthw/lcthw-ex1-13","date":"2022-06-01T14:50:55.000Z","updated":"2023-04-07T16:30:54.773Z","comments":true,"path":"posts/5fed90c.html","link":"","permalink":"https://doreality.xyz/posts/5fed90c.html","excerpt":"Learn C The Hard Way, notes for ex01 to ex13.","text":"Learn C The Hard Way, notes for ex01 to ex13. Exercise 2. Using Makefiles to Build How Make Works? Implied dependencies and ancient lore. 1make ex1 可以通过 ex1 来推测要用来构建的文件是 ex1.c，同名的其他后缀的文件。 是几十年来的经验，和隐含的依赖。 Exercise 3. Formatted Printing 使用变量不进行初始化：可能是0，也可能是随机的数据。 所以一定要初始化：要么是要用的值，要么是错误值（-1 或 NULL）。 printf() 格式输出、对齐、宽度、精度： https://blog.csdn.net/muge323/article/details/123402431 %-8.2f： .2 保留2位精度（包括整数部分） -左对齐 8占8位宽度 Exercise 4. Using a Debugger GBD / LLDB 总结：GDB / LLDB 常用命令 一个参考：Beej’s Quick Guide to GDB 打印所有线程的栈 ：thread apply all bt 123456(gdb) thread apply all btThread 1 (process 917):#0 0x0000000000400704 in crash () at ex3.c:8#1 0x00000000004007d4 in main (argc&#x3D;1, argv&#x3D;0xfffffffffd48) at ex3.c:24(gdb) 运行程序，并在出错的时候直接返回调用栈信息： gdb --batch --ex r --ex bt --ex q --args 12345678910111213141516root@ddafb7ecb5fe:~&#x2F;lc# gdb --batch --ex r --ex bt --ex q --args .&#x2F;ex3I am 100 years old.I am 72 inches tall.a[20] &#x3D; 022.1 ,Program received signal SIGSEGV, Segmentation fault.0x0000000000400704 in crash () at ex3.c:88 printf(&quot;%c&quot;, test[i]);#0 0x0000000000400704 in crash () at ex3.c:8#1 0x00000000004007d4 in main (argc&#x3D;1, argv&#x3D;0xfffffffffd48) at ex3.c:24A debugging session is active. Inferior 1 [process 911] will be killed.Quit anyway? (y or n) [answered Y; input not from terminal] Valgrind Valgrind 安装 安装和使用：Valgrind 的安装介绍 LINT apt-get install splint splint ex3.c AddressSanitizer AddressSanitizer GitHub Wiki GCC 4.8 之后自带。 12$gcc -fsanitize=address -fno-omit-frame-pointer -O1 -g test.c -o test$./test Address Sanitizer 用法 Exercise 7. Variables and Types 12345678910111213141516171819char first_name[] = &quot;Zed&quot;;// covered the last byte &#x27;\\0&#x27;first_name[3] = &#x27;$&#x27;;// the pointer has lost the array&#x27;s beginningprintf(&quot;I have a first name %s.\\n&quot;, first_name + 100);// 10737418240000000000// -7709325833709551616 // unsigned 把负数的补码最高位解释为正数1，而在内存中的二进制形式不变unsigned long universe_of_defects = 4294967296L * 4294967295L;printf(&quot;The entire universe has %lu bugs.\\n&quot;, universe_of_defects);printf(&quot;sizeof(long)=%d.\\n&quot;, sizeof(long));// unsigned = 2147483649// int = -2147483647int a = 0b10000000000000000000000000000001;printf(&quot;a = %d.\\n&quot;, a); char * int doesn’t matter long: linux 64bit sizeof = 8 Exercise 8. If, Else-If, Else NO BOOLEAN: any integer that’s 0 is false or otherwise it’s true. 0 真，非 0 假。 Exercise 9. While-Loop and Boolean Expressions 写 while 循环的时候，一定注意： 循环变量初始化了吗？ 每次循环最后，循环变量的值更新了吗？ 如果有 continue 和 break，一定要搞清楚结果是什么 continue 进入下一步循环的时候，循环变量是否改变？ break 跳出循环的时候，是不是想要的结果边界值？ Exercise 10. Switch Statements Always include a default: branch so that you catch any missing inputs. Don’t allow fall through unless you really want it. It’s also a good idea to add a //fallthrough comment so people know it’s on purpose. Always write the case and the break before you write the code that goes in it. Try to use if-statements instead if you can. 初始化 写 case-break 先写 case，然后紧跟着写 break，然后再写代码逻辑 写 default 不要忘记，为了覆盖所有的情况，即使不会运行到，也要打印一些错误信息，同理 else 也要这么处理 case 只接受字面量常量值 Exercise 11. Arrays and Strings when you make string literals you should typically use the char *another = &quot;Literal&quot; syntax. The source of almost all bugs in C come from forgetting to have enough space, or forgetting to put a '\\0' at the end of a string. In fact, it’s so common and hard to get right that the majority of good C code just doesn’t use C-style strings. 按照 numbers[-1] 这样字面量地引用数组范围外的内存，会根据类型大小向前或者向后索引到那个位置，然后输出里面的 garbage 正常应该越界就报错，但是可能会在一段范围内能运行，但是超出范围就会 Segmentation Fault Exercise 12. Sizes and Arrays 初始化数组：type name[] = &#123;initializer&#125;; “I want an array of type that is initialized to {…}.” sizeof to ask C how big things are in bytes 所以会计算 '\\0' nul_byte 空字节的大小 Linux： Tips： 在 32 位机器上，指针是 4 字节；64 位机器上，是 8 字节 long 在 64 位 Windows 上是 4 字节，在 macOS / Linux 64 位上是 8 字节 其他每个系统都是一样的 int 的 2 字节应该是在 16 位机器上 SHRT_MAX and INT_MAX must be at least 32767=$2^{15} -1$ sizeof(char) &lt;= sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long) &lt;= sizeof(long long) Exercise 13. For-Loops and Arrays of Strings for 循环 for (Initializer; Test; Incremeneter) &#123;&#125;： 初始化 判断条件： 如果为真，执行循环体，然后进入 3； 如果为假，跳出循环； 执行 Incrementer 循环变量修改，然后进入 2. 执行的文件名 ./ex13 是 argv[0] 创建字符串数组 Array of Strings char *str = &quot;blah&quot; + char str[] = &#123;'b','l','a','h'&#125; = char *states[] = &#123;...&#125; 逗号表达式 123456int i = 0, j = 0;for (i = 0, j = 0; i &lt; 5, j &lt; 10; i++, j++)&#123; // 只要 j &lt; 10 即可进入循环体 // Do something &#125; 用逗号分开的表达式的值分别结算，整个表达式的值是最后一个表达式的值。","categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"}],"tags":[{"name":"C","slug":"C","permalink":"https://doreality.xyz/tags/C/"}]},{"title":"C++ 多态：父类指针指向子类对象","slug":"dev/backend/cpp/cpp-base-class-and-derived-object","date":"2022-05-26T10:09:35.000Z","updated":"2023-04-07T16:36:55.672Z","comments":true,"path":"posts/1466be2b.html","link":"","permalink":"https://doreality.xyz/posts/1466be2b.html","excerpt":"C++ 多态；父类（基类）指针指向子类（派生类）对象。","text":"C++ 多态；父类（基类）指针指向子类（派生类）对象。 一个小例子 遇到了一个小例子（CS 106L）： 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;fstream&gt;//No using namespace std;!!!!using std::cout;using std::endl;using std::string;void writeToOstream(std::ostream&amp; myOstream, int num) &#123; myOstream &lt;&lt; &quot;Write number to ostream: &quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123; int myNum = 42; // : public basic_ostream std::ofstream myOfstream(&quot;out.txt&quot;); writeToOstream(cout, myNum); // print to the screen writeToOstream(myOfstream, myNum); // print to file return 0;&#125; 具体的细节还没掌握，暂时粗浅理解为 std::ofstream 是 std::ostream 的一个派生类，并且重写了 &lt;&lt; 操作符。 在函数 writeToOstream() 参数为基类引用 std::ostream&amp; 时，可以让派生类对象 myOfstream 把内容输出到文件 out.txt。原因是，在基类的成员函数实现为 virtual function 的时候，通过基类指针，可以调用派生类中重写后的相应的成员函数。 这个就是 C++ 多态的实现：动态绑定（Dynamic Binding）。 静态绑定 示例来源。 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;struct A &#123; void f() &#123; cout &lt;&lt; &quot;Class A&quot; &lt;&lt; endl; &#125;&#125;;struct B: A &#123; void f() &#123; cout &lt;&lt; &quot;Class B&quot; &lt;&lt; endl; &#125;&#125;;void g(A&amp; arg) &#123; arg.f();&#125;int main() &#123; B x; g(x);&#125; 输出是：Class A。 原因：x 是 B 类的对象，继承了 A 的所有成员和函数，而通过 g(x) 把 x 传给一个基类 A 的引用 arg，通过静态绑定（Static Binding，编译时绑定），只能访问派生类中属于基类的那部分内容，而不能调用派生类的特有的成员（例如重写的函数也不行）。 动态绑定 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;struct A &#123; virtual void f() &#123; cout &lt;&lt; &quot;Class A&quot; &lt;&lt; endl; &#125;&#125;;struct B: A &#123; void f() &#123; cout &lt;&lt; &quot;Class B&quot; &lt;&lt; endl; &#125;&#125;;void g(A&amp; arg) &#123; arg.f();&#125;int main() &#123; B x; g(x);&#125; 代码输出是： Class B 原因：将基类中的函数添加关键字 virtual 变成虚函数，再在派生类中重写（override），那么派生类中重写的函数也是虚函数。通过基类指针/引用，就可以调用派生类对象的虚函数。这提供了一个打破静态绑定规则的机制。 此时是在运行时实现的动态绑定： 如果基类指针指向基类对象，那么调用的依旧是基类的函数； 如果基类指针指向派生类对象，并且调用的是对基类虚函数进行重写的虚函数，那么调用的就是派生类的成员函数。 重写规则 派生类重定义（redefine）基类的虚函数，会覆盖基类的虚函数。 重写的特点： 作用域不同； 函数名、参数列表、返回值相同； 基类函数是 virtual 若派生类重定义了一个基类虚函数，但是重载（overload，函数名相同，但是返回值和参数列表不同），那么该派生类的函数就不是重写，并且也不是虚函数，同时，会隐藏基类的虚函数。 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;struct A &#123; virtual void f() &#123; cout &lt;&lt; &quot;Class A&quot; &lt;&lt; endl; &#125;&#125;;struct B: A &#123; void f(int) &#123; cout &lt;&lt; &quot;Class B&quot; &lt;&lt; endl; &#125;&#125;;struct C: B &#123; void f() &#123; cout &lt;&lt; &quot;Class C&quot; &lt;&lt; endl; &#125;&#125;;int main() &#123; B b; C c; A* pa1 = &amp;b; A* pa2 = &amp;c;// b.f(); pa1-&gt;f(); pa2-&gt;f();&#125; 输出： 12Class AClass C B::f 是重载，C::f 是重写且是虚函数。 虚函数表 C++ 实现虚函数的原理是虚函数表+虚表指针。 当一个类里存在虚函数时， For Class：编译器会为类创建一个虚函数表，虚函数表是一个数组，数组的元素存放的是类中虚函数的地址。 For Object：编译器为每个类的对象添加一个隐藏成员，该隐藏成员保存了指向该虚函数表的指针。该隐藏成员占据该对象的内存布局的最前端。 所以虚函数表只有一份，而有多少个对象，就对应多少个虚函数表指针。 总结：多态 利用虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。 换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，这种现象称为多态（Polymorphism）。 参考 怎么理解C++多态的“父类指针或引用指向子类对象”？ C++父类指针指向子类对象的实现原理 Virtual functions (C++ only)","categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://doreality.xyz/tags/CPP/"},{"name":"OOP","slug":"OOP","permalink":"https://doreality.xyz/tags/OOP/"}]},{"title":"GDB / LLDB 常用命令","slug":"memos/debugger/gdb-and-lldb-usage","date":"2022-05-22T12:57:29.000Z","updated":"2023-12-04T15:19:41.566Z","comments":true,"path":"posts/3b78b4cb.html","link":"","permalink":"https://doreality.xyz/posts/3b78b4cb.html","excerpt":"GDB 和 LLDB 常用命令汇总，随用随查。","text":"GDB 和 LLDB 常用命令汇总，随用随查。 参考： LCTHW - Learn C The Hard Way 格式：完整命令 | 缩写 GDB GDB = GNU Debugger 小技巧 gdb --args Shell 中使用 传入参数 thread apply all bt GDB 中使用 查看所有线程的调用栈情况 gdb --batch --ex r --ex bt --ex q --args Shell 中使用，后面加可执行程序，例如 ./test 运行程序，如果出错（Bomb）会输出栈回溯（Stack Backtrace）信息 简易版 Valgrind 常用命令 run [args] | r Start your program with [args]. break [file:]function | b Set a break point at [file:]function. backtrace | bt Dump a backtrace of the current calling stack. print expr | p Print the value of expr. continue | c Continue running the program. next | n Next line, but step over function calls. step | s Next line, but step into function calls. quit | q Exit GDB. help | h List the types of commands. You can then get help on the class of command as well as the command. cd, pwd, make This is just like running these commands in your shell. shell Quickly start a shell so you can do other things. clear Clear a breakpoint. info break, info watch Show information about breakpoints and watchpoints. attach pid Attach to a running process so you can debug it. detach Detach from the process. list List out the next ten source lines. Add a - to list the previous ten lines. LLDB The LLDB Debugger (LLDB) is the debugger component of the LLVM (Low Level Virtual Machine) project. run [args] | r Start your program with [args]. breakpoint set --name [file:]function | b Set a break point at [file:]function. thread backtrace | bt Dump a backtrace of the current calling stack. print expr | p Print the value of expr. continue | c Continue running the program. next | n Next line, but step over function calls. step | s Next line, but step into function calls. Shorthand is s. quit | q Exit LLDB. help | h List the types of commands. You can then get help on the class of command as well as the command itself. cd, pwd, make just like running these commands in your shell. shell Quickly start a shell so you can do other things. clear Clear a breakpoint. info break, info watch Show information about breakpoints and watchpoints. attach -p pid Attach to a running process so you can debug it. detach Detach from the process. list List out the next ten source lines. Add a - to list the previous ten sources.","categories":[{"name":"Memos","slug":"Memos","permalink":"https://doreality.xyz/categories/Memos/"}],"tags":[{"name":"GDB","slug":"GDB","permalink":"https://doreality.xyz/tags/GDB/"},{"name":"LLDB","slug":"LLDB","permalink":"https://doreality.xyz/tags/LLDB/"}]},{"title":"Valgrind 安装","slug":"memos/debugger/valgrind-installation","date":"2022-05-22T12:34:37.000Z","updated":"2023-12-04T15:19:44.274Z","comments":true,"path":"posts/8e3c74d.html","link":"","permalink":"https://doreality.xyz/posts/8e3c74d.html","excerpt":"Valgrind：用于内存调试、内存泄漏检测以及性能分析。","text":"Valgrind：用于内存调试、内存泄漏检测以及性能分析。 环境： 12$uname -aLinux ddafb7ecb5fe 5.10.104-linuxkit #1 SMP PREEMPT Thu Mar 17 17:05:54 UTC 2022 aarch64 aarch64 aarch64 GNU/Linux 源码 tar.bz2 安装 官网下载源代码：https://valgrind.org/downloads/ 进入下载路径，解压到当前目录： 1$tar -xjvf valgrind-3.19.0.tar.bz2 进入解压后的目录 valgrind-3.19.0，配置和安装： 12345678910111213$cd valgrind-3.19.0/# a) 设置环境（需要标准的autoconf工具）# apt-get install autoconf$./autogen.sh# b) 配置 Valgrind，常用参数：--prefix=安装路径# 这里/root/Valgrind 是我的Docker的路径，虚拟机或者真机自行选择$./configure --prefix=/root/Valgrind# c) 编译安装$make$make install 验证是否安装成功： 12345$valgrind ls -l==23775== Memcheck, a memory error detector==23775== Copyright (C) 2002-2015, and GNU GPLd, by Julian Seward et al.==23775== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info==23775== Command: ls -l","categories":[{"name":"Memos","slug":"Memos","permalink":"https://doreality.xyz/categories/Memos/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://doreality.xyz/tags/Linux/"},{"name":"Valgrind","slug":"Valgrind","permalink":"https://doreality.xyz/tags/Valgrind/"}]},{"title":"Makefile 使用（一）","slug":"dev/makefile/Using-Makefile-1","date":"2022-05-11T17:26:13.000Z","updated":"2023-04-07T16:07:47.655Z","comments":true,"path":"posts/5dc7c8b1.html","link":"","permalink":"https://doreality.xyz/posts/5dc7c8b1.html","excerpt":"记录一些 Makefile 小 Tips。 简单的规则格式 两个函数 wildcard 和 patsubst 条件：ifdef / ifeq，else 和 endif","text":"记录一些 Makefile 小 Tips。 简单的规则格式 两个函数 wildcard 和 patsubst 条件：ifdef / ifeq，else 和 endif Linux 中，默认情况下，make 命令寻找顺序（当前目录）： GNUmakefile -&gt; makefile -&gt; Makefile -&gt; Make.Linux（自定义的，需要加 -f） 推荐使用 Makefile。 基本的规则 命令前面务必加上一个 TAB： 123456(target): (dependencies) (commands) # 这里是注释myapp: myapp.c gcc -Wall myapp.c -o myapp 两个函数 wildcard：表示通配符 padsubst：Pattern Substring，字符串替换 123456789101112# SRC: 当前目录下所有 .c 文件SRC = $(wildcard *.c)# OBJ: 把 SRC 中所有的 .c 换成 .oOBJ = $(patsubst %.c, %.o, $(SRC)) ALL: hellohello: $(OBJ) gcc $(OBJ) -o hello$(OBJ): $(SRC) gcc -c $(SRC) -o $(OBJ) 条件 ifdef 1234567891011VARIABLE = 1ifdef VARIABLE...else...endif ifeq 123456789101112VARIABLE_1 = 1VARIABLE_2 = 2ifeq ($(VARIABLE), $(VARIABLE_2))...else...endif","categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"}],"tags":[{"name":"Makefile","slug":"Makefile","permalink":"https://doreality.xyz/tags/Makefile/"}]},{"title":"Markdown 绘图：mermaid 和 flow graph","slug":"memos/markdown/mermaid-and-flow-graph-in-md","date":"2022-04-10T03:35:30.000Z","updated":"2023-12-04T15:17:49.582Z","comments":true,"path":"posts/20e330e7.html","link":"","permalink":"https://doreality.xyz/posts/20e330e7.html","excerpt":"Markdown 流程图、框图、甘特图、各种图。","text":"Markdown 流程图、框图、甘特图、各种图。 mermaid: Markdown语法之绘制流程图 flow: MarkDown flow流程图示例 12345678910111213&#96;&#96;&#96;mermaidgraph TD start[开始] -.描述.-&gt; input[输入A,B,C] input --描述--&gt; conditionA&#123;A是否大于B&#125; conditionA -- YES --&gt; conditionC&#123;A是否大于C&#125; conditionA -- NO --&gt; conditionB&#123;B是否大于C&#125; conditionC -- YES --&gt; printA[输出A] conditionC -- NO --&gt; printC[输出C] conditionB -- YES --&gt; printB[输出B] conditionB -- NO --&gt; printC[输出C] printA &#x3D;&#x3D;&gt; stop[结束] printC --&gt; stop printB &#x3D;&#x3D; 描述 &#x3D;&#x3D;&gt; stop 123456789101112131415&#96;&#96;&#96;flowstart&#x3D;&gt;start: 开始input&#x3D;&gt;inputoutput: 输入operation&#x3D;&gt;operation: 操作condition&#x3D;&gt;condition: 操作出错？output&#x3D;&gt;inputoutput: 输出error&#x3D;&gt;operation: 请重新输入end&#x3D;&gt;end: 结束start-&gt;inputinput-&gt;operationoperation-&gt;conditioncondition(no,bottom)-&gt;outputcondition(yes)-&gt;error(top)-&gt;inputoutput-&gt;end","categories":[{"name":"Memos","slug":"Memos","permalink":"https://doreality.xyz/categories/Memos/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://doreality.xyz/tags/Markdown/"}]},{"title":"Cousera 视频快速加载","slug":"memos/how-to-visit-cousera","date":"2022-03-12T09:39:08.000Z","updated":"2023-12-04T15:17:20.156Z","comments":true,"path":"posts/c400d692.html","link":"","permalink":"https://doreality.xyz/posts/c400d692.html","excerpt":"学一些 Coursera 但是视频缓冲好慢。","text":"学一些 Coursera 但是视频缓冲好慢。 配置 DNS 找到 hosts： C:\\Windows\\System32\\drivers\\etc （Windows） /etc/hosts （macOS/Linux，Finder-「前往」-「前往文件夹」-/private/etc） 添加如下内容：(不能直接添加就拷贝一份文件到外面，修改之后覆盖原来的） 123# coursera13.249.162.18 d3njjcbhbojbot.cloudfront.net # 网站18.65.219.131 d3c33hcgiwev3.cloudfront.net # 视频 两个查询 DNS 的网站，可以找到想访问网址对应的各种 DNS 服务器的 IP： https://ping.eu/nslookup/ http://ping.chinaz.com/ 输入的如下网址得到相应的IP： 网站：d3njjcbhbojbot.cloudfront.net 视频：d3c33hcgiwev3.cloudfront.net 可以尝试 ping 一下这些 IP，找到速度比较快的添加到 hosts 中即可。 刷新 DNS，然后重新打开 Coursera即可 在命令行 or 终端里输入下面的命令： 1234# Windows$ipconfig /flushdns# macOS$dscacheutil -flushcache 可以再 ping 一下网站和视频对应的链接，看一看 IP 是否成功。 参考 Coursera视频打不开终极办法 Cousera视频无法播放问题解决","categories":[{"name":"Memos","slug":"Memos","permalink":"https://doreality.xyz/categories/Memos/"}],"tags":[{"name":"DNS","slug":"DNS","permalink":"https://doreality.xyz/tags/DNS/"}]},{"title":"「SNDD」简单网络设备驱动程序","slug":"projects/simpler-eth-driver","date":"2022-01-19T10:42:09.000Z","updated":"2023-04-07T16:44:51.504Z","comments":true,"path":"posts/c73d89f1.html","link":"","permalink":"https://doreality.xyz/posts/c73d89f1.html","excerpt":"本文首发地址：简单网络驱动（基于 Linux-4.15.x 版本内核） 本文设计并实现了一个简单的网络设备驱动程序（基于 Linux-4.15.x 版本内核）—— A Simpler Network Device Driver（下文简称 sndd）。 源码地址（仅供学习交流）：https://gitee.com/doreality/sndd 参考《Linux 设备驱动程序（第3版）》（以下简称“LDD3”）第 17 章“网络驱动程序”的snull模块实现 P.S. 下文所提到的“网络设备驱动程序”、“网络设备驱动”、“网络驱动程序”、“网络驱动”都指的是同一个概念。","text":"本文首发地址：简单网络驱动（基于 Linux-4.15.x 版本内核） 本文设计并实现了一个简单的网络设备驱动程序（基于 Linux-4.15.x 版本内核）—— A Simpler Network Device Driver（下文简称 sndd）。 源码地址（仅供学习交流）：https://gitee.com/doreality/sndd 参考《Linux 设备驱动程序（第3版）》（以下简称“LDD3”）第 17 章“网络驱动程序”的snull模块实现 P.S. 下文所提到的“网络设备驱动程序”、“网络设备驱动”、“网络驱动程序”、“网络驱动”都指的是同一个概念。 前言 几个概念理解 为什么要选择 Linux ？ 在源码公开和支持模块化这样优点的加成下，Linux 系统非常适合作为学习编写设备驱动程序的环境。 什么是设备驱动程序？ 设备驱动程序，是应用程序和除了CPU、内存等硬件设备之外的几乎所有外设打交道的桥梁。应用程序使用OS提供的统一接口——系统调用，就像使用了一把万能钥匙，可以打开并访问各种不同外设，而并不用关心这些设备本身的样子。 例如块设备，应用程序说打开它，然后读写一些数据，那么直接使用open，read，write这些系统调用就好了，并不需要考虑数据是怎么在光盘或者磁盘上使用什么不同的介质存储、被组织排列成什么顺序。 有哪些设备驱动程序？ 正因为有越来越多不同的设备出现，设备驱动也是种类繁杂，一般可以分为三类：字符设备驱动、块设备驱动和网络设备驱动。这样分类有利于模块化编程，但是，当然，对于复杂的设备，也可以把这些都综合为一个模块（以灵活性为代价）。 对于字符设备驱动和块设备驱动来说，Linux 系统都会在/dev目录下创建一个文件节点，把它们都抽象为一个文件，可以打开关闭、可以读写也可以进行配置。 但是网络设备驱动有所不同。 网络设备是要和外界互联的，网络驱动程序要异步地接收来自外界的数据包，然后向内核请求，把这些数据包发送给内核。这和块设备只响应内核的要求、只向固定缓冲区发送数据，是完全不同的。网络驱动没有必要留一个/dev下的节点，因为对它打开关闭也好、读写也罢，并没有实质的意义。网络驱动要做的就是，在收到数据包的时候，发送给内核；在内核要发送数据包的时候，它进行封装（自己的硬件头部）然后发送。 网络驱动在哪里 如果说网络驱动是一把万能钥匙，那也是开大门的钥匙吧，那就是在内核了。这是在应用程序和驱动程序的角度来看。 如果说从网络的分层来看，网络驱动程序就是很底层了。LDD3 中提到，Linux 的网络子系统被设计为和协议完全无关。协议隐藏在驱动程序之后，而物理传输又被隐藏在协议之后。内核和网络驱动之间的交互，可能每次处理的是一个网络数据包。 但是同样值得指出的是，驱动接收的是外界发送的数据包，但是传输时要给上层传递下来的数据包封装一个 MAC 的头部信息。所以驱动会使用硬件协议，但是处理传输的是 IP 数据包。 （图源：百度百科——网络驱动程序接口规范） sndd 设计 sndd 实现一个基于内存的网络驱动模块，模拟了网络接口和远程主机通信的过程。 sndd 中使用的接口不依赖于任何硬件，是纯软件实现的数据包传输和发送。 在二层协议上选择以太网协议，处理传输的是 IP 数据包（对其他非 IP 数据包的修改会破坏原本数据包）。 由于使用以太网协议，在实际测试的时候可以使用 tcpdump 工具进行抓包验证数据包的传输。 网络拓扑 驱动模拟了四个网络接口，接口名：sndd0，sndd1，sndd2 和 sndd3 对应的主机名为 lc0，lc1，lc2 和 lc3 四个接口位于四个不同的子网，网络名分别为 snet0，snet1，snet2 和 snet3 在三个网段中，各自分别有一台主机，主机名：rm0，rm1，rm2 和 rm3 网络结构如下图所示： 驱动要实现的功能如下： 从主机发送到 rm0 的数据包，要从 sn3 接收到 从主机发送到 rm3 的数据包，要从 sn0 接收到 从主机发送到 rm1 的数据包，要从 sn2 接收到 从主机发送到 rm2 的数据包，要从 sn1 接收到 为了实现上述功能，给各接口和主机分配 IP 地址如下： 123456789101112131415# 网络号 &#x2F;etc&#x2F;networkssnet0 192.168.4.0snet1 192.168.5.0snet2 192.168.6.0snet3 192.168.7.0# 主机号 &#x2F;etc&#x2F;hosts192.168.4.1 lc0 192.168.4.2 rm0192.168.5.2 lc1192.168.5.1 rm1192.168.6.1 lc2192.168.6.2 rm2192.168.7.2 lc3192.168.7.1 rm3 同时，在终端里配置网络接口： 1234$ sudo ifconfig sndd0 lc0 netmask 255.255.255.0$ sudo ifconfig sndd1 lc1 netmask 255.255.255.0$ sudo ifconfig sndd2 lc2 netmask 255.255.255.0$ sudo ifconfig sndd3 lc3 netmask 255.255.255.0 根据所设置的 IP 地址，为了实现功能，要在驱动中接收到数据包时，修改 IP 数据包的头部中的源 IP 地址和目的 IP 地址： 把第 3 个 octet 依次修改（4-&gt;5，5-&gt;4，6-&gt;7，7-&gt;6） 把第 4 个 octet 修改（1-&gt;2，2-&gt;1） 模块结构 实现一个简单的模块，至少需要包含如下几个部分： 模块注册和注销 模块初始化 模块的具体操作 对于要实现的简单网络设备驱动， 包含的数据结构： 接口数据结构 struct net_device * 操作数据结构 struct header_ops struct net_device_ops 自定义数据包 struct sndd_packet 接口的私有信息 struct sndd_priv 包含操作： 注册 sndd_init_module() 注销 sndd_cleanup() 初始化 sndd_init() 打开 sndd_open() 关闭 sndd_release() 传输 / 接收 传输 sndd_tx() 接收 sndd_rx() 数据处理 修改 header sndd_header() 单个缓冲区 sndd_get_tx_buffer() sndd_release_buffer() 缓冲池 建立：sndd_setup_pool() 回收：sndd_teardown_pool() 缓冲队列 sndd_enqueue_buf() sndd_dequeue_buf() 中断 sndd_regular_interrupt() 统计 net_device_stats *sndd_stats() I / O 控制 sndd_ioctl() 使用一些简化： 传输和接收采用中断机制，而不是轮询（NAPI） 不设置传输超时判断 硬件地址由软件模拟 不使用 ARP，采用软件模拟 不修改 MTU sndd 实现 模块的注册、注销和初始化 首先是每个模块的注册和注销函数： 12module_init(sndd_init_module);module_exit(sndd_cleanup); 注册，完成的功能就是给每个接口申请内存（在这个步骤里要进行接口的初始化 sndd_init），最关键的就是使用注册函数register_netdev(sndd_devs[i])，把接口注册到内核中。 12345678910111213141516171819202122232425262728293031323334/* * Register the module */int sndd_init_module(void)&#123; int result, i, ret = -ENOMEM; sndd_interrupt = sndd_regular_interrupt; /* Allocate the devices */ sndd_devs[0] = alloc_netdev(sizeof(struct sndd_priv), &quot;sndd%d&quot;, NET_NAME_UNKNOWN, sndd_init); sndd_devs[1] = alloc_netdev(sizeof(struct sndd_priv), &quot;sndd%d&quot;, NET_NAME_UNKNOWN, sndd_init); sndd_devs[2] = alloc_netdev(sizeof(struct sndd_priv), &quot;sndd%d&quot;, NET_NAME_UNKNOWN, sndd_init); sndd_devs[3] = alloc_netdev(sizeof(struct sndd_priv), &quot;sndd%d&quot;, NET_NAME_UNKNOWN, sndd_init); if (sndd_devs[0] == NULL || sndd_devs[1] == NULL) goto out; ret = -ENODEV; for (i = 0; i &lt; 4; i++) if ((result = register_netdev(sndd_devs[i]))) printk(&quot;sndd: error %i registering device \\&quot;%s\\&quot;\\n&quot;, result, sndd_devs[i]-&gt;name); else ret = 0; out: if (ret) sndd_cleanup(); return ret;&#125; 注销，就是注册的倒序，先从内核中注销，然后清除内部的数据结构，最后释放接口。 12345678910111213141516/* * Unregister the module */void sndd_cleanup(void)&#123; int i; for (i = 0; i &lt; 4; i++) &#123; if (sndd_devs[i]) &#123; unregister_netdev(sndd_devs[i]); sndd_teardown_pool(sndd_devs[i]); free_netdev(sndd_devs[i]); &#125; &#125; return;&#125; 初始化： 12345678910111213141516171819202122232425262728293031/* * The init function (sometimes called probe). * It is invoked by register_netdev() */void sndd_init(struct net_device *dev)&#123; struct sndd_priv *priv; /* * Then, assign other fields in dev, using ether_setup() and some * hand assignments */ ether_setup(dev); /* assign some of the fields */ dev-&gt;netdev_ops = &amp;sndd_netdev_ops; dev-&gt;header_ops = &amp;sndd_header_ops; /* keep the default flags, just add NOARP */ dev-&gt;flags |= IFF_NOARP; dev-&gt;features |= NETIF_F_HW_CSUM; /* * Then, initialize the priv field. This encloses the statistics * and a few private fields. */ priv = netdev_priv(dev); memset(priv, 0, sizeof(struct sndd_priv)); spin_lock_init(&amp;priv-&gt;lock); priv-&gt;dev = dev; sndd_rx_ints(dev, 1); /* enable receive interrupts */ sndd_setup_pool(dev);&#125; 数据包的传输 从上层接收到的数据包，要先封装硬件协议（这里是以太网协议）的头部，然后放入发送队列。 每一个数据包都包含在一个 sk_buff 结构中，就是一个 socket 缓冲区。 最后调用 sndd_hw_tx 实现网络驱动的具体操作，就是修改源和目的，实现一个回环功能。 123456789101112131415161718192021222324252627/* * Transmit a packet (called by the kernel) */int sndd_tx(struct sk_buff *skb, struct net_device *dev)&#123; int len; char *data, shortpkt[ETH_ZLEN]; struct sndd_priv *priv = netdev_priv(dev); data = skb-&gt;data; len = skb-&gt;len; if (len &lt; ETH_ZLEN) &#123; memset(shortpkt, 0, ETH_ZLEN); memcpy(shortpkt, skb-&gt;data, skb-&gt;len); len = ETH_ZLEN; data = shortpkt; &#125; netif_trans_update(dev); /* Remember the skb, so we can free it at interrupt time */ priv-&gt;skb = skb; /* actual deliver of data is device-specific, and not shown here */ sndd_hw_tx(data, len, dev); return 0; /* Our simple device can not fail */&#125; 数据包的接收 由于是使用中断驱动，当数据包异步到达的时候，中断程序调用 sndd_rx 将数据包和附加信息发送到上层。 1234567891011121314151617181920212223242526272829303132/* * Receive a packet: retrieve, encapsulate and pass over to upper levels */void sndd_rx(struct net_device *dev, struct sndd_packet *pkt)&#123; struct sk_buff *skb; struct sndd_priv *priv = netdev_priv(dev); /* * The packet has been retrieved from the transmission * medium. Build an skb around it, so upper layers can handle it */ skb = dev_alloc_skb(pkt-&gt;datalen + 2); if (!skb) &#123; if (printk_ratelimit()) printk(KERN_NOTICE &quot;sndd rx: low on mem - packet dropped\\n&quot;); priv-&gt;stats.rx_dropped++; goto out; &#125; skb_reserve(skb, 2); /* align IP on 16B boundary */ memcpy(skb_put(skb, pkt-&gt;datalen), pkt-&gt;data, pkt-&gt;datalen); /* Write metadata, and then pass to the receive level */ skb-&gt;dev = dev; skb-&gt;protocol = eth_type_trans(skb, dev); skb-&gt;ip_summed = CHECKSUM_UNNECESSARY; /* don&#x27;t check it */ priv-&gt;stats.rx_packets++; priv-&gt;stats.rx_bytes += pkt-&gt;datalen; netif_rx(skb); out: return;&#125; 更多具体的实现可见源代码并参考 LDD3 中的 snull 模块。 sndd 测试 利用 Makefile 生产 .ko 加载到内核之后，使用 ping 和 tcpdump 可以测试本驱动。 Makefile 和 LDD3 中所给示例基本是一样的。 1234567891011121314151617181920212223242526272829303132333435# Comment/uncomment the following line to disable/enable debugging#DEBUG = y# Add your debugging flag (or not) to CFLAGSifeq ($(DEBUG),y) DEBFLAGS = -O -g -DSNULL_DEBUG # &quot;-O&quot; is needed to expand inlineselse DEBFLAGS = -O2endifEXTRA_CFLAGS += $(DEBFLAGS)EXTRA_CFLAGS += -I..ifneq ($(KERNELRELEASE),)# call from kernel build systemobj-m := sndd.oelseKERNELDIR ?= /lib/modules/$(shell uname -r)/buildPWD := $(shell pwd)default: $(MAKE) -C $(KERNELDIR) M=$(PWD) modulesendifclean: rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions *.mod modules.order *.symversdepend .depend dep: $(CC) $(EXTRA_CFLAGS) -M *.c &gt; .dependifeq (.depend,$(wildcard .depend))include .dependendif 模块测试 编译并装载模块 12$ make$ sudo insmod sndd.ko 模块加载到内核之后，模拟的网络接口就出现了，使用 ifconfig 命令可以查看： 配置网络 如前所述，配置网络和主机号，同时绑定接口的 IP。 测试 测试效果如下图。 当发出ping -c1 1 rm0命令，发送目的地址为 rm0 的数据包请求时，按顺序发送了如下事件： 在 sndd0 上观察到，从 lc0 &gt; rm0 发起了一次请求； 在 sndd1 上观察到，从 rm1 &gt; lc1 发起了一次请求； 在 sndd1 上观察到，从 lc1 &gt; rm1 发起了一次回应； 在 sndd0 上观察到，从 rm0 &gt; lc0 发起了一次回应。 这个过程就实现了一个扩展的回环网络，从 lc0 到 lc1，然后从 lc1 再到 lc0，实现了一次双向的通信。 同理，使用 ping 访问 rm1，rm2 和 rm3 时，也实现了这样的过程。 小结 模块化编程要注意，卸载模块的时候，一定要把申请的所有内存都释放，否则会影响内核下一次启动； 网络驱动比起字符驱动和块设备驱动，会更抽象一点，实际的使用需要结合具体的网络设备来编写； 配置测试接口的 IP 时，要多测试一下，如果突然不好用了重新使用 ifconfig 配置一下； 在实际网络中使用的时候，必须要有传输超时和并发控制（这里没有给出，但是 LDD3 中都有涉及）； 除了中断的方式处理数据接收和发送，还可以使用轮询（NAPI）的方式，常用于流量非常大的高速接口（如宽带接口）； 网络驱动其实并不关注协议内容，也不关注头部和数据的划分，但是，需要比较了解协议的结构，才能在传输和发送时更好处理。 参考 LDD3 的 snull 示例参考代码（基于新版内核修改）：https://github.com/martinezjavier/ldd3 snull 在新版内核上编译不通过问题：Linux设备驱动程序(LDD)中snull的编译问题","categories":[{"name":"Projects","slug":"Projects","permalink":"https://doreality.xyz/categories/Projects/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://doreality.xyz/tags/Linux/"},{"name":"Device Driver","slug":"Device-Driver","permalink":"https://doreality.xyz/tags/Device-Driver/"}]},{"title":"Jupyter Notebook 基础使用","slug":"memos/python/easy-use-jupyter-notebook","date":"2022-01-05T04:49:40.000Z","updated":"2023-12-04T15:18:47.919Z","comments":true,"path":"posts/4342490b.html","link":"","permalink":"https://doreality.xyz/posts/4342490b.html","excerpt":"Jupyter Notebook 安装与使用。","text":"Jupyter Notebook 安装与使用。 安装 12$ pip3 install ipython$ pip3 install &quot;ipython[notebook]&quot; 启动 1$ ipython notebook","categories":[{"name":"Memos","slug":"Memos","permalink":"https://doreality.xyz/categories/Memos/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://doreality.xyz/tags/Python/"},{"name":"Jupyter Notebook","slug":"Jupyter-Notebook","permalink":"https://doreality.xyz/tags/Jupyter-Notebook/"}]},{"title":"终端运行 .sh 文件报错：zsh operation not permitted","slug":"Q&A/zsh-operation-not-permitted","date":"2022-01-04T16:38:47.000Z","updated":"2023-04-07T16:06:30.406Z","comments":true,"path":"posts/46c2dc33.html","link":"","permalink":"https://doreality.xyz/posts/46c2dc33.html","excerpt":"","text":"M1 芯片运行.sh文件报zsh: operation not permitted","categories":[{"name":"Q&A","slug":"Q-A","permalink":"https://doreality.xyz/categories/Q-A/"}],"tags":[{"name":"macOS","slug":"macOS","permalink":"https://doreality.xyz/tags/macOS/"},{"name":"zsh","slug":"zsh","permalink":"https://doreality.xyz/tags/zsh/"}]},{"title":"使用自定义端口号打开 Flask App","slug":"memos/python/open-flask-app-by-user-defined-port","date":"2022-01-02T16:33:02.000Z","updated":"2023-12-04T15:19:03.058Z","comments":true,"path":"posts/6590c97f.html","link":"","permalink":"https://doreality.xyz/posts/6590c97f.html","excerpt":"Flask 默认启动端口号是 5000，如果被占用，就会报错，启动失败。 这时就需要自定义使用其他的端口号。","text":"Flask 默认启动端口号是 5000，如果被占用，就会报错，启动失败。 这时就需要自定义使用其他的端口号。 打开时指定 1$ env FLASK_APP=app.py flask run -p 5030 在代码中指定 12if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;, port=5030) 但是在这种情况下，执行命令： 1$ env FLASK_APP=app.py flask run 仍是从 5000 端口打开。 此时应该直接执行如下命令： 1$ python3.9 app.py 就是按照代码指定的端口打开了，访问 localhost:5030 即可。","categories":[{"name":"Memos","slug":"Memos","permalink":"https://doreality.xyz/categories/Memos/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://doreality.xyz/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://doreality.xyz/tags/Flask/"}]},{"title":"Markdown 数学符号和公式输入","slug":"memos/markdown/formula-in-md","date":"2022-01-02T10:01:48.000Z","updated":"2023-12-04T15:17:47.181Z","comments":true,"path":"posts/78e38634.html","link":"","permalink":"https://doreality.xyz/posts/78e38634.html","excerpt":"Markdown 中的数学符号输入：脚标、公式等。","text":"Markdown 中的数学符号输入：脚标、公式等。 非常详尽的参考：markdown中公式编辑教程 行内： $...$ 块：$$...$$ 脚标 上标：O(n2) = O(n&lt;sup&gt;2&lt;/sup&gt;) 下标：H2 = H&lt;sub&gt;2&lt;/sub&gt;","categories":[{"name":"Memos","slug":"Memos","permalink":"https://doreality.xyz/categories/Memos/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://doreality.xyz/tags/Markdown/"}]},{"title":"Docker Linux 中使用 GDB 出现警告","slug":"Q&A/docker-gdb-warning","date":"2021-12-23T13:50:30.000Z","updated":"2023-04-07T16:05:29.774Z","comments":true,"path":"posts/8a332699.html","link":"","permalink":"https://doreality.xyz/posts/8a332699.html","excerpt":"在 Docker 容器中使用 GDB 调试出现警告： warning: Error disabling address space randomization: Operation not permitted","text":"在 Docker 容器中使用 GDB 调试出现警告： warning: Error disabling address space randomization: Operation not permitted 参考解决：DockerContainer下gdb无法正常工作的解决办法 问题截图 解决方案 1$ docker run --privileged -it -v $PWD/codes/lcthw:/home/ ubuntu /bin/bash 注意，是创建一个容器，而不是进入之前的容器 docker exec。 重新创建容器后，进入 GDB 正常：","categories":[{"name":"Q&A","slug":"Q-A","permalink":"https://doreality.xyz/categories/Q-A/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://doreality.xyz/tags/Docker/"}]},{"title":"Docker 基本使用","slug":"dev/docker/docker-easy-use","date":"2021-12-23T11:28:11.000Z","updated":"2023-12-04T15:10:52.854Z","comments":true,"path":"posts/726dca2.html","link":"","permalink":"https://doreality.xyz/posts/726dca2.html","excerpt":"Docker 的简单使用：镜像、容器、Ubuntu。","text":"Docker 的简单使用：镜像、容器、Ubuntu。 问题来自学 C 语言要使用的一个工具 Valgrind，但是它现在还没有支持 M1 的版本。 所以可以在 Docker 虚拟出一个 Linux 环境，跑一下。 （暂时用不到完整的虚拟机） 环境准备 下载安装 Docker Desktop for Mac 就可以了。 简单使用 CLI 方式 使用参考：Memory Leak Testing with Valgrind on macOS using Docker Containers 创建一个文件夹，写一个 Dockerfile 12345FROM ubuntu:16.04 RUN apt-get updateRUN apt-get upgrade -yRUN apt-get install g++ valgrind -y 具体安装什么命令，可以根据需求修改（后面创建好之后也可以使用容器更新镜像）。 在当前目录，打开终端，运行 1$ docker build -t image-name . image-name 是自定义的镜像名称。 创建好之后可以查看镜像 1$ docker images 在 Docker Desktop 中也可以查看。 运行，即使用镜像创建容器 1$ docker run -ti image-name /bin/bash docker run -ti 是基础的交互运行 Docker 镜像的命令； /bin/bash 这个位置是容器要执行的命令，此处是打开命令行。 如果需要挂载目录： 1$ docker run -ti -v host-mount-path:container-mount-path image-name /bin/bash -v 指令用于挂载主机文件到容器中，具体是把主机的 host-mount-path 目录，通过冒号 : 分隔，挂载到容器的 container-mount-path 目录。 例如，要把当前目录挂载到容器的 /home/ 目录，就可以写： 1$ docker run -ti -v $PWD:/home/ image-name /bin/bash Docker Desktop 方式 第一次打开 Docker Desktop，会有一个新手教程。 镜像获取：https://hub.docker.com 搜索镜像： 1$ docker search ubuntu # 搜索镜像 结果如下： 拉取（下载）镜像： 123$ docker pull ubuntu # 下载镜像# 或者指定版本的下载$ docker pull ubuntu:16.04 下载镜像之后在客户端里就可以看到了，打开使用即可。 需要注意的是，创建容器时，挂载本地的目录： 在 Host Path 中填写本地目录，在 Container Path 中填写挂载到的容器中的目录。 从客户端打开命令行之后，输入bash，之后就可以正常使用一些功能，例如记录之前执行的命令、source 命令等。 修改并更新镜像 如果当前镜像的环境有修改，并且需要保存经常使用，可以把当前容器保存为新的镜像。 查看容器的 ID 1$ docker containers ls 会有如下显示： 根据容器创建镜像 1$ docker commit -m=&quot;commit info&quot; -a=&quot;committer name&quot; container-id new-image-name 然后再使用 docker images 就可以查看到新的镜像 new-image-name 了。 命令行进入容器 查看容器的ID 1$ docker ps 打开容器 1$ docker exec -it container-id /bin/bash 容器命名和重命名 创建时命名 1$ docker run -ti --name [容器名称] [镜像名称] /bin/bash 重命名 查看旧名： 1$ docker ps -a 修改容器名： 1$ docker rename [旧容器名] [新容器名] 操作结果如下： 参考 Memory Leak Testing with Valgrind on macOS using Docker Containers docker update_docker 镜像的使用 Docker和宿主机之间共享文件","categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"}],"tags":[{"name":"Environment","slug":"Environment","permalink":"https://doreality.xyz/tags/Environment/"},{"name":"Docker","slug":"Docker","permalink":"https://doreality.xyz/tags/Docker/"}]},{"title":"基于 HMM 的中文分词","slug":"aiml/nlp/nlp-hmm","date":"2021-12-21T09:46:15.000Z","updated":"2023-12-04T15:33:19.392Z","comments":true,"path":"posts/6377499.html","link":"","permalink":"https://doreality.xyz/posts/6377499.html","excerpt":"课程：NLP-HMM隐马尔可夫+维特比分词，代码+数据+讲解 源码：GitHub 仓库：nlp-hmm-word-cut","text":"课程：NLP-HMM隐马尔可夫+维特比分词，代码+数据+讲解 源码：GitHub 仓库：nlp-hmm-word-cut 中文分词任务 什么是中文分词 把一句话，切分成词语：（英文天然就分好词了，但中文需要分词） 今天天气真好 = 今天/天气/真好 今天天气真好 = 今天/天气/真/好 「真」和「好」同时出现，是否分开，取决于语料库。 方法 基于规则：基于词典，前向、后向最大匹配，应对新词没法处理 基于统计：HMM、CRF 基于深度学习：BiLSTM+CRF，非常流行，准确率在逐渐提高 为什么要分词 更好理解语义 为了处理更重要的任务 命名实体识别、情感分析、文本分类、语义识别…… （但不是所有任务都需要分词） 应用场景需要 搜索：淘宝、百度…… 语料库 人工标注而来。 每一行是一篇“文章” 每篇文章用空格分开 语料库的准确性，严重影响分词结 理论上，语料库越大越好 标识 每个字都有一个标识（“隐藏状态”），可以根据语料库得到所有标识。 B：词语开始 M：词语中间 E：词语结束 S：单独成词 根据已知状态进行分词，即在 E 和 S 后加入空格。 根据已经分好的词（就是语料库），得到每个字的状态。 根据状态，统计三个矩阵。 根据三个矩阵，可以得到序列，分词结束。 HMM 分词 训练与预测 训练：根据语料库求三个矩阵：初始概率矩阵、转移概率矩阵和发射矩阵。 预测：根据输入的句子，利用上述三个矩阵计算所有路径（每个字有4种可能状态）可能性的概率。再使用维特比算法，从所有可能性得到概率最大的那条路径，在 E 和 S 后加空格即可。 初始、转移、发射矩阵 初始矩阵 统计每一篇文章的第一个字的状态：统计频次，归一化。 M 和 E 为 0. 转移矩阵 当前状态到下一状态的概率：统计频次，归一化。 总共 4 种状态，转移矩阵就是 4 * 4 的矩阵。 行代表当前状态，列代表下一状态。 每一行归一化。有些概率一定是0，例如 B -&gt; B， B -&gt; S 等等。如果出错了可能是代码写错，或者是语料库有问题。 发射矩阵 统计某种状态下，所有字出现的次数（概率） 几种状态就是几行，遍历语料库的所有字，对于每一个字属于某种状态的次数统计。 例如：今作为 B 出现了 1 次。 1&#123; B: &#123; 今 : 1 &#125;&#125; 对每一个状态归一化，分母是该状态出现的总次数。 预测 Start -&gt; 初始矩阵 -&gt; 转移概率 * 发射概率 路径的概率 = 初始概率 * 第一个字的发射概率 * 之后每一个字的（转移概率 * 发射概率） 寻找概率最大的路径。 会有很多（一半）条路径的概率是 0 维特比算法 从众多路径中，快速选出最优路径。 首先找局部最优： 从 Start 到 第一个字的所有路径都要选择。 从 第一个字 转移到 第二个字，每一个状态留一条最优路径。 从 第二个字 转移到 第三个字，每一个状态留一条最优路径。 直到最后一个字，才能找到全局最优。 最后也只保留了状态数（4）条总路径。","categories":[{"name":"AIML","slug":"AIML","permalink":"https://doreality.xyz/categories/AIML/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://doreality.xyz/tags/Python/"},{"name":"NLP","slug":"NLP","permalink":"https://doreality.xyz/tags/NLP/"}]},{"title":"macOS 下端口占用问题","slug":"Q&A/mac-port-used-already","date":"2021-12-20T12:16:49.000Z","updated":"2023-12-04T15:21:17.429Z","comments":true,"path":"posts/73881320.html","link":"","permalink":"https://doreality.xyz/posts/73881320.html","excerpt":"使用 Python 做 socket 编程时遇到： OSError: [Errno 48] Address already in use","text":"使用 Python 做 socket 编程时遇到： OSError: [Errno 48] Address already in use 查看占用端口的进程号： 1$ sudo lsof -i:port 杀死进程： 1$ kill PID 有时候不显示，可能是客户端在[CLOSE_WAIT]阶段，一般是等一会儿就好了。 为了避免这种情况，可以“曲线救国”一下，先挂起进程，然后杀死进程。 ctrl + z：挂起进程 jobs -l：可以查看挂起进程 ctrl+ c：终止当前进程","categories":[{"name":"Q&A","slug":"Q-A","permalink":"https://doreality.xyz/categories/Q-A/"}],"tags":[{"name":"macOS","slug":"macOS","permalink":"https://doreality.xyz/tags/macOS/"},{"name":"Environment","slug":"Environment","permalink":"https://doreality.xyz/tags/Environment/"}]},{"title":"Hexo 报错：Node Sass 版本问题","slug":"Q&A/hexo-node-sass-edition","date":"2021-12-05T09:35:09.000Z","updated":"2023-04-07T16:05:34.705Z","comments":true,"path":"posts/5ed7d52f.html","link":"","permalink":"https://doreality.xyz/posts/5ed7d52f.html","excerpt":"使用 hexo clean 的时候，Sass 报错。","text":"使用 hexo clean 的时候，Sass 报错。 原因可能是重新配置了一些环境里的 node 的版本。 然后 hexo clean 的时候报错： 1Node Sass does not yet support your current environment: OS X Unsupported architecture (arm64) with Node.js 14.x 成功的方法 1$ npm install node-sass@npm:sass 来自 StackOverFlow 的 问题 Node Sass with apple m1, Big Sur and arm64： 失败的方法 直接升级（未解决） 1$ npm install node-sass --dev 重新安装（未解决） 12$ rm -rf node_modules$ npm install","categories":[{"name":"Q&A","slug":"Q-A","permalink":"https://doreality.xyz/categories/Q-A/"}],"tags":[{"name":"macOS","slug":"macOS","permalink":"https://doreality.xyz/tags/macOS/"},{"name":"Node","slug":"Node","permalink":"https://doreality.xyz/tags/Node/"},{"name":"Sass","slug":"Sass","permalink":"https://doreality.xyz/tags/Sass/"}]},{"title":"「JavaScript 网络编程」Express 基本使用","slug":"dev/frontend/js/netpr-express-basic","date":"2021-12-03T07:15:44.000Z","updated":"2023-04-07T16:36:04.505Z","comments":true,"path":"posts/a1b3f005.html","link":"","permalink":"https://doreality.xyz/posts/a1b3f005.html","excerpt":"Node，Express 基本使用方法，介绍 ReSTful API","text":"Node，Express 基本使用方法，介绍 ReSTful API 基本使用 Node Node 是 JavaScript 的运行环境，不同于浏览器，不使用 document 或者 window 对象，但是添加了关于操作系统、文件、网络等内容。 Node 是使用 C++ 封装了 Chrome V8 引擎的客户端，可以执行 JavaScript 程序。 使用 npm 进行包管理，生成 package.json： 123$ npm init# 或者 直接全部默认$ npm init --yes 安装包 123$ npm install package_name# 或者$ npm i package_name 会自动添加到 package.json 的 dependencies 中，并保存在 node_modules 文件夹中。 Semantic Versioning - SemVer 123456&#123; &quot;dependencies&quot;: &#123; &quot;mongoose&quot;: &quot;^4.13.6&quot;, // 4.x, Major.Minor.Patch &quot;underscore&quot;: &quot;~1.8.3&quot; // 1.8.x &#125;&#125; 依赖 1234567891011121314151617181920212223$ npm list$ npm list --depth=0# 查看某个package的依赖$ npm view mongoose$ npm view mongoose dependencies# 查看package的历史版本$ npm view mongoose versions# 查看当前安装的包版本是否过时$ npm outdated# 更新$ npm update # 只更新次版本号和补丁版本$ npm i -g npm-check-updates$ npm-check-updates$ ncu -u # upgrade package.json$ npm i # 开发环境的依赖，不打包到生产环境$ npm i jshint --save-dev 卸载包 123$ npm uninstall mongoose# 或者$ npm un mongoose Express Hello World 创建目录和依赖 12345$ mkdir myapp$ cd myapp$ npm init# entry point 填 app.js，其他全部回车$ npm install express Hello World 在 myapp 目录下创建 app.js，填入内容： 1234567891011const express = require(&#x27;express&#x27;)const app = express()const port = 3000app.get(&#x27;/&#x27;, (req, res) =&gt; &#123; res.send(&#x27;Hello World!&#x27;)&#125;)app.listen(port, () =&gt; &#123; console.log(`Example app listening at http://localhost:$&#123;port&#125;`)&#125;) 运行 1$ node app.js RESTful API http module 使用 node 的 builtin module， http 模块： 12345678910111213const http = require(&#x27;http&#x27;);const server = http.createServer((req, res) =&gt; &#123; if (req.url === &#x27;/&#x27; ) &#123; // ... &#125; if (req.url === &#x27;/api/course&#x27;) &#123; // ... &#125;&#125;);server.listen(3000); RESTful API REST = Representational State Transfer 使用 REST 实现 Http 的 CRUD（Create、Update、Read、Delete）。 例如：http://vidly.com/api/customers 把 customers 看作是一种资源，对于该资源的增删改查都是通过向这个 end point 发送请求完成的。 请求的种类（HTTP METHODS）对应着操作的类型： GET POST PUT DELETE 使用有语义的地址来公开资源，可以使用 HTTP 的规则来对资源操作。 创建目录并安装 express 1234$ mkdir express-demo$ cd express-demo$ npm init --yes$ npm i express 新建 index.js 1234567891011121314151617const express = require(&#x27;express&#x27;);const app = express();// route handler 或者 callback app.get(&#x27;/&#x27;, (req, res) =&gt; &#123; res.send(&#x27;Hello World&#x27;);&#125;);app.get(&#x27;/api/courses&#x27;, (req, res) =&gt; &#123; // 实际要从数据库读出数据并返回 res.send([1, 2, 3]);&#125;);// PORTconst port = process.env.PORT || 3000;app.listen(port, () =&gt; console.log(`Listening on $&#123;port&#125;...`)); 不再使用 if 作为路由，而是通过 app.get() 的方式，这样可以方便归类。 查询某一个数据 12345app.get(&#x27;/api/posts/:year/:month&#x27;, (req, res) =&gt; &#123; res.send(req.params);&#125;);// 访问 /api/posts/2021/12// 返回：&#123;&quot;year&quot;:&quot;2021&quot;,&quot;month&quot;:&quot;12&quot;&#125; query string 12345app.get(&#x27;/api/posts/:year/:month&#x27;, (req, res) =&gt; &#123; res.send(req.query);&#125;);// 访问 /api/posts/2021/12?sortBy=name// 返回：&#123;&quot;sortBy&quot;:&quot;name&quot;&#125; 处理 GET 请求 如果请求一个资源，但是在服务器中没有，应该返回 404 状态码。 cmd + R 刷新，在开发者工具中选择 Network 可看状态码。 123456789101112131415161718const courses = [ &#123; id:1, name: &#x27;course1&#x27; &#125;, &#123; id:2, name: &#x27;course2&#x27; &#125;, &#123; id:3, name: &#x27;course3&#x27; &#125;,];// get all coursesapp.get(&#x27;/api/courses&#x27;, (req, res) =&gt; &#123; // 实际要从数据库读出数据并返回 res.send(courses);&#125;);// get single course app.get(&#x27;/api/courses/:id&#x27;, (req, res) =&gt; &#123; const course = courses.find(c =&gt; c.id === parseInt(req.params.id)); if (!course) return res.status(404).send(&#x27;The course with the given ID was not found.&#x27;); res.send(course);&#125;); 处理 POST 请求 为了向终端发送请求，需要使用 Chrome 的扩展 Postman。 12345678910app.post(&#x27;/api/courses&#x27;, (req, res) =&gt; &#123; // 读取req的消息体，获得新的数据，来创建新的对象 const course = &#123; id: courses.length + 1, name: req.body.name &#125;; courses.push(course); // 惯例，当我们让服务器创建了新的对象或资源，服务器应该在反馈中包含创建的新资源 res.send(course);&#125;); 在 Postman 中发送一个 POST 请求到终端 http://localhost:3000/api/course： 123&#123; &quot;name&quot;: &quot;new course&quot;&#125; 返回： 1234&#123; &quot;id&quot;: 4, &quot;name&quot;: &quot;new course&quot;&#125; 状态码 200 OK。 使用 Joi 进行输入验证 在项目目录中安装 Joi： 1$ npm i joi 在 index.js 中使用： 1234567891011121314151617181920const Joi = require(&#x27;joi&#x27;); // class app.post(&#x27;/api/courses&#x27;, (req, res) =&gt; &#123; const schema = &#123; name: Joi.string().min(3).required() &#125;; const result = Joi.validate(req.body, schema); if (result.error) return res.status(400).send(result.error.details[0].message); // 读取req的消息体，获得新的数据，来创建新的对象 const course = &#123; id: courses.length + 1, name: req.body.name &#125;; courses.push(course); // 惯例，当我们让服务器创建了新的对象或资源，服务器应该在反馈中包含创建的新资源 res.send(course);&#125;); 处理 PUT 请求 进行一些复用： 123456789101112131415161718192021app.put(&#x27;/api/courses/:id&#x27;, (req, res) =&gt; &#123; // Look up the course // if not existing ,return 404 const course = courses.find(c =&gt; c.id === parseInt(req.params.id)); if (!course) return res.status(404).send(&#x27;The course with the given ID was not found.&#x27;); // Validate // If invalid, return 400 - bad request const schema = &#123; name: Joi.string().min(3).required() &#125;; const result = Joi.validate(req.body, schema); if (result.error) return res.status(400).send(result.error.details[0].message); // Update course course.name = req.body.name; // return the updated course res.send(course);&#125;); 处理 DELETE 请求 1234567891011121314app.delete(&#x27;/api/courses/:id&#x27;, (req, res) =&gt; &#123; // Look up the course // Not existing, return 404 const course = courses.find(c =&gt; c.id === parseInt(req.params.id)); if (!course) return res.status(404).send(&#x27;The course with the given ID was not found.&#x27;); // Delete const index = courses.indexOf(course); courses.splice(index, 1); // Return the same course res.send(course);&#125;); 基本路由 https://www.expressjs.com.cn/starter/basic-routing.html 参考资料 关于 package.json ： https://docs.npmjs.com/cli/v8/configuring-npm/package-json","categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doreality.xyz/tags/JavaScript/"},{"name":"Express","slug":"Express","permalink":"https://doreality.xyz/tags/Express/"},{"name":"Node","slug":"Node","permalink":"https://doreality.xyz/tags/Node/"},{"name":"Mongodb","slug":"Mongodb","permalink":"https://doreality.xyz/tags/Mongodb/"}]},{"title":"「JavaScript 网络编程」Vue 入门","slug":"dev/frontend/js/netpr-vue3-basic","date":"2021-12-01T09:02:15.000Z","updated":"2023-04-07T16:10:31.985Z","comments":true,"path":"posts/797f6d09.html","link":"","permalink":"https://doreality.xyz/posts/797f6d09.html","excerpt":"从工具使用入门到建立一个前端应用的 Demo。 「Vue Mastery 课程 —— Intro to Vue 3」 「Vue Mastery 课程 —— Real World Vue 3」","text":"从工具使用入门到建立一个前端应用的 Demo。 「Vue Mastery 课程 —— Intro to Vue 3」 「Vue Mastery 课程 —— Real World Vue 3」 基本使用 CDN 方式使用 Vue 创建 Vue App 1const app = Vue.createApp(&#123;&#125;) &#123;&#125;中，需要传递Options Object（不是可选的optional，而是至少需要一个，即使是空对象） 1234567const app = Vue.createApp(&#123; data() &#123; return&#123; product: &#x27;Socks&#x27; &#125; &#125;&#125;) data()用来返回数据；product是属性，传递给 HTML。 123&lt;div id=&#x27;app&#x27;&gt; &lt;h1&gt;&#123;&#123; product &#125;&#125;&lt;/h1&gt;&lt;/div&gt; &#123;&#123; &#125;&#125;称为mustache syntax，通过它使用 JavaScript 表达式，例如： 12345&lt;p&gt;&#123;&#123; firstName + &#x27; &#x27; + lastName &#125;&#125;&lt;/p&gt;&lt;span&gt;&#123;&#123; clicked ? true : false &#125;&#125;&lt;/span&gt;&lt;div&gt;&#123;&#123; message.method() &#125;&#125;&lt;/div&gt; 引入和挂载 Vue App 12345678910111213141516&lt;head&gt; &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- Body --&gt; &lt;/div&gt; &lt;!-- Import App --&gt; &lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt; &lt;!-- Mount App --&gt; &lt;script&gt; const mountedApp = app.mount(&#x27;#app&#x27;) &lt;/script&gt;&lt;/body&gt; v-bind 动态绑定属性和表达式。当属性值更新了，相应标签的渲染效果也会更新。 12345678const app = Vue.createApp(&#123; data() &#123; return&#123; product: &#x27;Socks&#x27;, image: &#x27;./assets/images/socks_green.jpg&#x27; &#125; &#125;&#125;) 添加image属性。 1&lt;img v-bind:src=&quot;image&quot;&gt; 此处，src为 HTML attribute，image是 JavaScript expression。 通过v-bind，相当于 src=&#123;&#123; image &#125;&#125;。 等价写法： 12345678&lt;img :src=&quot;image&quot;&gt;&lt;!-- 例如 --&gt;&lt;img :alt=&quot;description&quot;&gt;&lt;a :href=&quot;url&quot;&gt;&lt;div :class=&quot;isActive&quot;&gt;&lt;span :style=&quot;isActive&quot;&gt;&lt;span :disabled=&quot;isDisabled&quot;&gt; v-if, v-else, v-show 条件渲染，根据条件判断是否显示标签。 123456789const app = Vue.createApp(&#123; data() &#123; return&#123; product: &#x27;Socks&#x27;, image: &#x27;./assets/images/socks_green.jpg&#x27;, inStock: true &#125; &#125;&#125;) 使用 v-if 和 v-else 12&lt;p v-if=&quot;inStock&quot;&gt;In Stock&lt;/p&gt;&lt;p v-else&gt;Out of Stock&lt;/p&gt; 效果是向 DOM 中添加或者删除元素；可以单独使用 v-if（就是可以不用 v-else)。 使用 v-show 1&lt;p v-show=&quot;inStock&quot;&gt;In Stock&lt;/p&gt; 不会删除元素，会给 &lt;p&gt; 标签添加属性 style=&quot;display: none;。 使用 v-if，v-else-if 和 v-else 123&lt;p v-if=&quot;inventory &gt; 10&quot;&gt;In Stock&lt;/p&gt;&lt;p v-else-if=&quot;inventory &lt;= 10 &amp;&amp; inventory &gt; 0&quot;&gt;Almost sold out!&lt;/p&gt;&lt;p v-else&gt;Out of Stock&lt;/p&gt; v-for 列表渲染，循环。 1234567const app = Vue.createApp(&#123; data() &#123; return&#123; details: [&#x27;50% cotton&#x27;, &#x27;30% wool&#x27;, &#x27;20% polyester&#x27;] &#125; &#125;&#125;) 使用无序列表 &lt;ul&gt; 显示： 123&lt;ul&gt; &lt;li v-for=&quot;detail in details&quot;&gt;&#123;&#123; detail &#125;&#125;&lt;/li&gt;&lt;/ul&gt; key 属性 使用 v-bind 的方式，给每一个 DOM 元素一个 :key，很有用。 12345678910const app = Vue.createApp(&#123; data() &#123; return&#123; variants: [ &#123; id: 2234, color: &#x27;green&#x27; &#125;, &#123; id: 2235, color: &#x27;blue&#x27; &#125;, ] &#125; &#125;&#125;) 遍历或者抓取其中一个元素的时候，可以使用 :key 属性，类似于 id。 1&lt;div v-for=&quot;variant in variants&quot; :key=&quot;variant.id&quot;&gt;&#123;&#123; variant.color &#125;&#125;&lt;/div&gt; v-on 监听事件。 1234567const app = Vue.createApp(&#123; data() &#123; return&#123; cart: 0 &#125; &#125;&#125;) v-on: (== @) + 监听的事件 click + 事件触发时做 cart += 1 12&lt;div class=&quot;cart&quot;&gt;Cart(&#123;&#123; cart &#125;&#125;)&lt;/div&gt;&lt;button class=&quot;button&quot; v-on:click=&quot;cart += 1&quot;&gt;Add to Cart&lt;/button&gt; 当处理逻辑复杂时，可以使用函数封装： 123456789101112const app = Vue.createApp(&#123; data() &#123; return&#123; cart: 0 &#125; &#125;, methods: &#123; addToCart() &#123; this.cart += 1 &#125; &#125;&#125;) 1&lt;button class=&quot;button&quot; v-on:click=&quot;addToCart&quot;&gt;Add to Cart&lt;/button&gt; 等价写法：v-on:click == @click 1&lt;button class=&quot;button&quot; @click=&quot;addToCart&quot;&gt;Add to Cart&lt;/button&gt; hover 的 Vue 版本的事件：@mouseover class 和 style 使用 v-bind 动态渲染。 1&lt;div :style=&quot; &#123; backgroundColor = variant.color &#125;&quot;&gt;&lt;/div&gt; 对于每个 variant，对应设置背景颜色。 Camel-case：&#123; backgroundColor = variant.color &#125; 是一个 JavaScript 对象，在此处是 style object。 Kebab-case：&#123; 'background-color': variant.color &#125; 不使用 inline： 1&lt;div :style=&quot;styles&quot;&gt;&lt;/div&gt; 在 data 对象中创建一个对象，用于指代。 12345678data() &#123; return &#123; styles: &#123; color: &#x27;red&#x27;, fontSize: &#x27;14px&#x27; &#125; &#125;&#125; 等价于：&lt;div style=&quot;color: red; font-size: 14px&quot;&gt;&lt;/div&gt; 对 class 进行渲染： 1&lt;div :class=&quot;&#123; disabledButton: !inStock &#125;&quot;&gt;&lt;/div&gt; 给标签添加多个 class 属性 1234&lt;div class=&quot;color-circle&quot; :class=&quot;&#123; &#x27;active&#x27; : activeClass &#125;&quot;&gt;&lt;/div&gt; 如果 activeClass 是 true，那么最终结果：class=&quot;color-circle active&quot;，此处 active是类名 可以使用三目操作符 1234&lt;div class=&quot;color-circle&quot; :class=&quot; [isActive ? &#x27;active&#x27; : &#x27;&#x27; ]&quot;&gt;&lt;/div&gt; 如果 isActive 是 true，结果同上。 Computed Property 对于复杂逻辑的响应，例如，模板中需要显示好几个 data() 和 method() 的属性通过计算之后的结果，直接写在模板中会很复杂，例如： 1&lt;h1&gt;&#123;&#123; brand + &#x27; &#x27; + product &#125;&#125;&lt;/h1&gt; 其中使用的表达式已经不是声明性的了，变得复杂，可以使用计算属性： 12345678910111213const app = Vue.createApp(&#123; data() &#123; return &#123; brand: &#x27;Vue Mastery&#x27;, product: &#x27;Socks&#x27;, &#125; &#125;, computed: &#123; title() &#123; return this.brand + &#x27; &#x27; + this.product &#125; &#125;&#125;) 这样就可以直接使用 title 这个计算属性： 1&lt;h1&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt; 当 brand 或者 product 更新的时候，title 也会动态更新。 好处是，不修改的时候，使用的是缓存，需要修改的时候才会重新读取。 Components &amp; Props 复用的模板可以封装成组件（Component），使用 Props 属性向组件中传递数据。 12345678910111213app.component(&#x27;example-component&#x27;, &#123; template: /*html*/ `html here`, data() &#123; return &#123; &#125; &#125;, methods: &#123; &#125;, computed: &#123; &#125;&#125;) 在模板前写 /*html*/ 是为了使用 VScode 的插件 es6-string-html，可以按照 HTML 语法高光显示。 然后在主 HTML 中调用： 1234&lt;example-component&gt;&lt;/example-component&gt;&lt;!-- Import Component --&gt;&lt;script src=&quot;./components/example-component.js&quot;&gt;&lt;/script&gt; 一个组件可以多次调用。 如果父模板需要给组件传数据（即组件要接收外来数据），可以给模板增加 Props，使用其中定义的属性： 1234567891011app.component(&#x27;example-component&#x27;, &#123; props: &#123; someprop: &#123; type: Boolean, required: true &#125; &#125;, template : `` ...&#125;) 这样，就给 &lt;example-component&gt; 这个标签，添加了属性名 sompeprop，只需要使用 v-bind 方法绑定即可。 1&lt;example-component :someprop=&quot;propvalue&quot;&gt;&lt;/example-component&gt; 可以插入到主 HTML 中或者另一个组件中，propvalue 是该模板或者组件的一个参数，data 类型或者 computed 类型。 组件事件 当组件中，发生了事件，怎么通知给别的组件或者父模板？ 激活和监听：在组件中，发生了事件，使用 this.$emit('an-event')，在组件属性中监听事件 @an-event=&quot;toSolve&quot; 123456789app.component(&#x27;example-component&#x27;, &#123; template: `&lt;button @click=&quot;event&quot;&gt;&lt;/button&gt;`, methods: &#123; event() &#123; this.$emit(&#x27;an-event&#x27;) &#125; &#125;&#125;) 在使用该组件的地方： 1&lt;example-component @an-event=&quot;toSolve&quot;&gt;&lt;/example-component&gt; 然后，在 js 中： 1234567const app = Vue.createApp(&#123; methods: &#123; toSolve() &#123; // do something to solve the event &#125; &#125;&#125;) Forms 使用 V-model 进行模板和数据的双向绑定。 template 中，对输入框使用 v-model 绑定： 123&lt;input id=&quot;name&quot; v-model=&quot;name&quot;&gt;&lt;textarea id=&quot;review&quot; v-model=&quot;review&quot;&gt;&lt;/textarea&gt;&lt;select id=&quot;rating&quot; v-model.number=&quot;rating&quot;&gt; 在 data() 中声明绑定的变量： 1234567data() &#123; return &#123; name: &#x27;&#x27;, review: &#x27;&#x27;, rating: null &#125;&#125; 在 &lt;form&gt; 使用 submit.prevent 避免在提交表单时刷新浏览器： 123&lt;form class=&quot;review-form&quot; @submit.prevent=&quot;onSubmit&quot;&gt; &lt;input class=&quot;button&quot; type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/form&gt; onSubmit 在 methods 中实现即可。 123456789101112131415161718methods: &#123; onSubmit() &#123; if (this.name === &#x27;&#x27; || this.review === &#x27;&#x27; || this.rating === null) &#123; alert(&#x27;Review is incomplete. Please fill out every field.&#x27;) return &#125; let productReview = &#123; name: this.name, review: this.review, rating: this.rating &#125; this.$emit(&#x27;review-submitted&#x27;, productReview) this.name = &#x27;&#x27; this.review = &#x27;&#x27; this.rating = null &#125;&#125; 在其他模板中引用 &lt;review-form @review-submitted=&quot;addReview&quot;&gt;，在引用的组件中实现 addReview 方法。 Vue-CLI + Element Plus el-input 无法输入 去掉边框 怎么设置全局背景色 uuid 滚动条 绑定回车","categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://doreality.xyz/tags/Vue/"},{"name":"Vuex","slug":"Vuex","permalink":"https://doreality.xyz/tags/Vuex/"},{"name":"Element UI","slug":"Element-UI","permalink":"https://doreality.xyz/tags/Element-UI/"}]},{"title":"「JavaScript 网络编程」搭建环境","slug":"dev/frontend/js/netpr-vue-express-environment","date":"2021-11-29T05:38:55.000Z","updated":"2023-04-07T16:36:12.952Z","comments":true,"path":"posts/8477f2ec.html","link":"","permalink":"https://doreality.xyz/posts/8477f2ec.html","excerpt":"JavaScript 网络程序设计的 Lab 简介和开发环境搭建。 From 2021《网络程序设计》","text":"JavaScript 网络程序设计的 Lab 简介和开发环境搭建。 From 2021《网络程序设计》 Lab 介绍 先学习 Web 网络编程的热门技术，然后选做一个课程设计：基于Web的聊天室系统设计与实现。 技术要点 Vue 组件化响应式编程 Express（node.js） 异步调用 Ajax Session Websocket 开发流程 环境搭建（Lab + Pro） 工具入门（Lab） Demo 实现（Lab） 需求分析与设计（Pro） 代码实现（Pro） 测试（Pro） 开发环境：macOS 12（Apple Silicon） 开始之前的准备： 主机安装了最新版的 Node.js，可以通过命令行使用npm工具 使用 VScode 作为开发环境 安装插件 es6-string-html 使用 Chrome 作为运行调试环境 使用 git 进行版本管理 前端环境 建立 Vue 的开发环境，需要使用如下工具： Vue-CLI Webpack Vuex Element UI Vue Vue 的官方文档给出了几种安装使用方法（CDN、下载自托管、npm下载、Vue-CLI等）。 这里记录两种最常用的使用方法： CDN 通过&lt;script&gt;在 HTML 中引用，是最简单的方式： 1&lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt; 对于生产环境，推荐链接到明确版本号和构建文件。 Vue-CLI CLI（Command Line Interface」）是命令行工具，Vue-CLI 是官方提供的「为单页面应用 (SPA) 快速搭建繁杂的脚手架」。 安装： 123$ npm install -g @vue/cli# OR$ yarn global add @vue/cli 创建一个项目： 123$ vue create my-project# OR$ vue ui 运行一个项目 1$ vue serve Webpack 打包工具。 安装： 1$ npm install -g webpack Vuex Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。 它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 CDN https://unpkg.com/vuex@4 或者指定版本：https://unpkg.com/vuex@4.0.0/dist/vuex.global.js 使用时，在 Vue 后直接引用即可 12345&lt;script src=&quot;/path/to/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/path/to/vuex.js&quot;&gt;&lt;/script&gt;&lt;!-- 例如都使用 unpkg 的版本 --&gt;&lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://unpkg.com/vuex@4&quot;&gt;&lt;/script&gt; npm 在项目的目录下安装： 1$ npm install vuex@next --save Element+ Element Plus 是基于 Vue 3 的桌面端组件库。 安装： npm 1$ npm install element-plus --save unpkg CDN 12345678&lt;head&gt; &lt;!-- 导入样式 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;//unpkg.com/element-plus/dist/index.css&quot; /&gt; &lt;!-- 导入 Vue 3 --&gt; &lt;script src=&quot;//unpkg.com/vue@next&quot;&gt;&lt;/script&gt; &lt;!-- 导入组件库 --&gt; &lt;script src=&quot;//unpkg.com/element-plus&quot;&gt;&lt;/script&gt;&lt;/head&gt; 在 Vue-CLI 中使用： 123$ vue create my-app$ cd my-app$ vue add element-plus 后端环境 Express mongodb mysql Express 通过 npm 安装 在本地任意路径下，新建一个文件夹 myapp (任意名称）： 12$ mkdir myapp$ cd myapp 使用 npm init 命令，创建 package.json，用于配置依赖。 1$ npm init 命令执行后，会提示输入若干参数（应用的名称、版本等信息），根据情况填写即可。 注意其中一个参数 entry point，它的值是当前 App 的入口文件（需要自己手动创建）。 可以使用默认的 index.js，或者根据实际情况使用相应的。 然后在 myapp 目录下，安装 Express： 保存到依赖列表 1$ npm install express --save 临时安装 1$ npm install express --no-save Express 应用程序生成器 生成器工具是 express-generator，可以快速创建一个应用的蓝本。 安装： 1$ npm install -g express-generator 创建应用（目录名为 myapp，路径为当前目录下）： 1$ express ./myapp 之后，会自动创建一个规范的目录结构和相关依赖。 进入 myapp 目录，执行命令启动应用： 12$ cd myapp$ DEBUG=myapp:* npm start 在浏览器中打开 http://localhost:3000/ 就可以查看该应用了。 MongoDB MongoDB 检查x-code 1$ xcode-select --install 安装包管理器 Homebrew 使用 brew 安装 mongodb 12$ brew tap mongodb/brew$ brew install mongodb-community@5.0 安装失败可能是由于某些依赖需要手动安装： c-ares：brew install c-ares libnghttp2：brew intall libnghttp2 ca-certificates： node@14 123$ echo &#x27;export PATH=&quot;/opt/homebrew/opt/node@14/bin:$PATH&quot;&#x27; &gt;&gt; ~/.zshrc$ export LDFLAGS=&quot;-L/opt/homebrew/opt/node@14/lib&quot;$ export CPPFLAGS=&quot;-I/opt/homebrew/opt/node@14/include&quot; mongosh 成功安装： 12==&gt; Summary🍺 /opt/homebrew/Cellar/mongodb-community/5.0.4: 11 files, 181.4MB, built in 2 seconds 运行 注意： 因为某种原因，安装的是默认的x86版本（安装时也提醒了不兼容 macOS 12），在开启服务前使用 Roseta： 1$ softwareupdate --install-rosetta （推荐用法） 作为服务运行：As a macOS Service 123456$ brew services start mongodb-community@5.0==&gt; Successfully started `mongodb-community` (label: homebrew.mxcl.mongodb-commu$ brew services stop mongodb-community@5.0Stopping `mongodb-community`... (might take a while)==&gt; Successfully stopped `mongodb-community` (label: homebrew.mxcl.mongodb-commu 通过 brew services list 可以查看是否开启成功： 123$ brew services listName Status User Plistmongodb-community started doreality /Users/doreality/Library/LaunchAgents/homebrew.mxcl.mongodb-community.plist 作为后台进程运行：As a background process on Intel processors： 1$ mongod --config /usr/local/etc/mongod.conf --fork on Apple M1 processors: 1$ mongod --config /opt/homebrew/etc/mongod.conf --fork MongoDB Compass MongoDB 的 GUI 应用程序。 在下载页面安装需要的版本： 1.29.5 OS X 64bit dmg mongoose 参考资料 http://nodejs.cn https://v3.cn.vuejs.org https://www.vuemastery.com/courses/intro-to-vue-3/intro-to-vue3 https://element-plus.gitee.io/zh-CN/guide/design.html https://www.expressjs.com.cn https://www.mongodb.com https://webpack.docschina.org","categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doreality.xyz/tags/JavaScript/"},{"name":"Express","slug":"Express","permalink":"https://doreality.xyz/tags/Express/"},{"name":"Vue","slug":"Vue","permalink":"https://doreality.xyz/tags/Vue/"}]},{"title":"Android Kotlin 项目构建报错：No native library","slug":"Q&A/android-kotlin-error-no-native","date":"2021-11-08T06:32:07.000Z","updated":"2023-04-07T16:24:55.424Z","comments":true,"path":"posts/8eb87749.html","link":"","permalink":"https://doreality.xyz/posts/8eb87749.html","excerpt":"在高版本 SDK 的 Android Studio 中，构建 Kotlin 的项目的常见错误。","text":"在高版本 SDK 的 Android Studio 中，构建 Kotlin 的项目的常见错误。 错误 1：No native library 这个错误是说： 1Caused by: java.lang.Exception: No native library is found for os.name&#x3D;Mac and os.arch&#x3D;aarch64. path&#x3D;&#x2F;org&#x2F;sqlite&#x2F;native&#x2F;Mac&#x2F;aarch64 总之就是找不到库了。 解决方案 点击查看解决方案： 在build.gradle(Project)中添加 1234567allprojects &#123; configurations.all &#123; resolutionStrategy &#123; force &#39;org.xerial:sqlite-jdbc:3.34.0&#39; &#125; &#125;&#125; 错误 2：使用 intent-filter，无法运行 如果当前的 TargetSDK 版本高的话，有可能以前的项目无法运行。 原因是，高版本（我是TargetSDK用的最新的版本，31），Activity 需要一个新的参数。 具体设置： 在 AndroidManifest.xml 中，对使用了 intent-filter 的 Activity 增加一条属性设置： android:exported=&quot;true&quot;","categories":[{"name":"Q&A","slug":"Q-A","permalink":"https://doreality.xyz/categories/Q-A/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://doreality.xyz/tags/Kotlin/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"https://doreality.xyz/tags/Android-Studio/"}]},{"title":"「讲座」开源技术在机器学习中的应用","slug":"aiml/ml-scikit-learn","date":"2021-11-01T06:16:21.000Z","updated":"2023-12-04T15:33:14.494Z","comments":true,"path":"posts/c04c3a43.html","link":"","permalink":"https://doreality.xyz/posts/c04c3a43.html","excerpt":"讲座来自IBM SPSS公司。 简单介绍机器学习的概念、常用的流程和指标 开源Scikit-learn的介绍和使用方法 高维数据可视化的介绍 行业前辈的经验分享","text":"讲座来自IBM SPSS公司。 简单介绍机器学习的概念、常用的流程和指标 开源Scikit-learn的介绍和使用方法 高维数据可视化的介绍 行业前辈的经验分享 What is machine learning? Data Model Predict KNN： K Nearest Neighbor 物以类聚，人以群分。 K-Means 无监督学习，根据均值 分类——决策 Scikit-learn 语言 Python R 软件 MATLAB Octave Forge：开源 Python中的： 数据处理库 numpy scipy pandas 图形化展示 matplotlib scikit-learn cheet sheet Evaluation 常见指标 ​ 举例：雷达兵 混淆矩阵 混淆矩阵衍生出的评价指标 阿里天池：F1score Pics from Wiki：Confusion Matrix / ROC 可信度 ROC/AUC Why Should I Trust You？ LIME 举例：分类结果正确，但是分类的原因和原本设想的不同 不光是指标，还要关注具体分类的原因 Visualize High Dimension Datasets Agenda 高维信息投射到低维空间，肯定会丢掉高维坐标的信息，但是还想保留用来比较的相似信息，很难。 把一个手写字符，分成 8 * 8 个field 通过算法可以高维降低到二维，很好地分类 为了增强可信度，除了 LIME，可以让过程变得透明，可视化 Machine learning needs more transparency 网站：https://distll.pub Experience 对于学生：编程 + 算法 + 行业知识 既懂编程又会算法——降维打击，行业知识：实际收益 数学统计算法、数学分析课程：加强竞争能力 工作时，学习行业的知识，在行业里产生价值，学以致用 工作经验 准时 &gt; 提早：不是提前多久完成，就算好了 除了编程，还要测试（性能测试、压力测试）、翻译、法律风险 许多步骤已经按照日程安排 提早是没有意义的，准时按质提交 项目有时间、资源、人员能力的压力 不能一直追求完美，影响自己的生活 会有各种限制，所以相对最优 项目失败很可能是项目管理 一两个加班 大多数人加班：项目管理出现问题 复盘 如果回到最初，项目管理是否能够更好 平衡 Work Balance 在工作时间，把工作完成 不要把工作带回家，不要让工作称为生活的全部 勇于接纳 努力学好基础知识 创造更美好的未来","categories":[{"name":"AIML","slug":"AIML","permalink":"https://doreality.xyz/categories/AIML/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://doreality.xyz/tags/Python/"},{"name":"Scikit-learn","slug":"Scikit-learn","permalink":"https://doreality.xyz/tags/Scikit-learn/"}]},{"title":"Git 分支（三）","slug":"git/git-branch-3","date":"2021-10-30T09:57:23.000Z","updated":"2023-04-07T16:29:39.233Z","comments":true,"path":"posts/476d1e25.html","link":"","permalink":"https://doreality.xyz/posts/476d1e25.html","excerpt":"前面学习了下载远程仓库（clone）、下载最新更新（fetch）并同步（pull）、上传更新并同步（push）这些命令的缺省用法。 那么 o/main 和 main 到底有什么关系？为什么 git clone 会有本地分支和远程分支，为什么可以同步更新？ 还有，使用 GitHub 的时候，那些 push 后面加的参数是什么意思？ 这篇继续学习神奇的网站，最后一点内容。","text":"前面学习了下载远程仓库（clone）、下载最新更新（fetch）并同步（pull）、上传更新并同步（push）这些命令的缺省用法。 那么 o/main 和 main 到底有什么关系？为什么 git clone 会有本地分支和远程分支，为什么可以同步更新？ 还有，使用 GitHub 的时候，那些 push 后面加的参数是什么意思？ 这篇继续学习神奇的网站，最后一点内容。 远程跟踪分支 main 和 o/main 的关联关系是由分支的“remote tracking”属性决定的。main 被设定为跟踪 o/main —— 这意味着为 main 分支指定了推送的目的地以及拉取后合并的目标。 当你克隆时，Git 会为远程仓库中的每个分支在本地仓库中创建一个远程分支（比如 o/main）。然后再创建一个跟踪远程仓库中活动分支的本地分支，默认情况下这个本地分支会被命名为 main。 克隆完成后，你会得到一个本地分支（如果没有这个本地分支的话，你的目录就是“空白”的），但是可以查看远程仓库中所有的分支（如果你好奇心很强的话）。这样做对于本地仓库和远程仓库来说，都是最佳选择。 pull 操作时, 提交记录会被先下载到 o/main 上，之后再合并到本地的 main 分支。 push 操作时, 我们把工作从 main 推到远程仓库中的 main 分支(同时会更新远程分支 o/main) 。 两种方式，指定分支去跟踪远程分支： 方法一：git checkout -b git checkout -b totallyNotMain o/main 创建一个名为 totallyNotMain 的分支，它跟踪远程分支 o/main 方法二： git branch -u git branch -u o/main foo 让 foo 分支跟踪 o/main git branch -u o/main 让当前分支跟踪 o/main 有了远程跟踪分支的概念，就可以解释之前的 push、fetch、pull 的缺省参数了。 Git Push 分支同名 语法：git push &lt;remote&gt; &lt;place&gt; 示例：git push origin main 切到本地仓库中的 main 分支，获取所有的提交 再到远程仓库 origin 中找到 main 分支 将远程仓库中没有的提交记录都添加上去 注意： 通过 &lt;place&gt;，就是提交记录来自 &lt;place&gt;，并且要提交到远程仓库的 &lt;place&gt; 指定 &lt;place&gt;，可以忽略当前的检出分支的属性。 分支不同名 语法：git push &lt;remote&gt; &lt;source&gt;:&lt;destination&gt; 示例： git push origin foo:main 把本地仓库中的 foo 分支所有更新，提交到远程仓库中的 main 分支 git push origin foo^:main 把本地仓库中的 foo 分支的父提交节点所有更新，提交到远程仓库中的 main 分支 git push origin main:newBranch 把本地仓库中的 main 分支的父提交节点所有更新，提交到远程仓库中的新创建的 newBranch 分支 Git Fetch 参数缺省：git fetch，下载所有更新。 分支同名 语法：git fetch &lt;remote&gt; &lt;place&gt; 示例：git fetch origin foo 下载了远程仓库中 foo 分支中的最新提交记录 并更新了 o/foo 分支不同名 语法：git fetch &lt;remote&gt; &lt;source&gt;:&lt;destination&gt; 示例：git fetch origin foo~1:bar 将 foo~1 解析成一个 origin 仓库的位置，然后将那些提交记录下载到了本地的 bar 分支（一个本地分支）上。 注意由于指定了目标分支，foo 和 o/foo 都没有被更新。 注意： 不能在当前检出分支使用。 没有 source 的 source push &lt;source&gt; 部分留空，可以用来删除远程仓库的分支。 示例：git push origin :foo 通过给 push 传空值 source，删除远程仓库中的 foo 分支，远程分支 o/foo 也没了。 fetch &lt;source&gt; 部分留空，可以用来在本地仓库创建分支。 示例：git fetch origin :bar 在本地创建一个 bar 分支 Git Pull git pull origin foo == git fetch origin foo; git merge o/foo 通过 foo 更新 o/foo o/foo合并到 当前检出分支 git pull origin bar~1:bugFix == git fetch origin bar~1:bugFix; git merge bugFix 在本地创建 bugFix的分支 从远程仓库中的 bar~1 分支中下载提交记录，并合并到 bugFix 然后再 merge 到当前检出分支上 git pull 唯一关注的是提交最终合并到哪里（也就是为 git fetch 所提供的 &lt;destination&gt; 参数） 好了，这套教程走了一遍。 第一遍的学习最难，简直就是教程复制机器，还得多用！用！用！ Proactice makes perfect，加油。","categories":[{"name":"Git","slug":"Git","permalink":"https://doreality.xyz/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://doreality.xyz/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"https://doreality.xyz/tags/GitHub/"}]},{"title":"Git 分支（二）","slug":"git/git-branch-2","date":"2021-10-21T16:04:01.000Z","updated":"2023-04-19T04:51:12.424Z","comments":true,"path":"posts/a73bd77.html","link":"","permalink":"https://doreality.xyz/posts/a73bd77.html","excerpt":"根据上一篇提到的教程，学习一下第二部分：远程仓库。 学习的内容一多起来，就发现好难管理，而且容易到处新建，到处分类。快点掌握远程仓库的用法吧！ 大喊一句：当然要CLI！","text":"根据上一篇提到的教程，学习一下第二部分：远程仓库。 学习的内容一多起来，就发现好难管理，而且容易到处新建，到处分类。快点掌握远程仓库的用法吧！ 大喊一句：当然要CLI！ 一、创建远程仓库 1$ git clone 在本地创建一个远程仓库的拷贝。 在任意一个要保存这个仓库的目录下 git clone，会出现仓库的文件夹，同时会有两个分支：本地分支 main 和远程分支 o/main。 远程仓库的默认名字是 origin，常用缩写 o 表示。 二、远程分支 远程分支反映了在你最后一次与远程仓库通信时，远程仓库的状态。 远程分支是使用 git clone 后，在本地仓库出现的分支。 命名方式：&lt;remote name&gt;/&lt;branch name&gt;。 如果分支名字为 main，那么远程分支就是 origin/main，常用缩写 o/main 表示。 远程分支的特点： 对远程分支检出（git checkout o/main），则会自动进入 HEAD 分离状态。 这个时候添加提交，远程分支 o/main 并不会移动到新的提交上，因为要和远程仓库中相应的分支同步更新。 注意：本地分支 main 与此无关，在 main 上提交后，分支指针保持正常移动。 三、从远程仓库获取更新 当我们从远程仓库获取数据时，远程分支也会更新，以反映最新的远程仓库。 1$git fetch 把远程仓库 origin 的分支 main 中有，而本地仓库的远程分支 origin/main 中没有的提交下载下来，并且更新远程分支。 通常通过互联网（使用 http:// 或 git:// 协议）与远程仓库通信。 简单说，这条命令做了两件事： 1. 从远程仓库下载本地仓库缺失的提交记录 2. 更新远程分支指针 o/main 这条命令没有做的事情： 1. 没有同步更新本地分支 main 2. 没有同步更新本地仓库和远程仓库 origin 再简单点说：git fetch 仅仅把更新下载到了 o/main 中，没有对 main 做任何操作。 四、合并更新到本地分支 两步走：git fetch + 任意合并分支指令 第一步，获取远程仓库的更新，同步远程分支：git fetch 第二步，把本地分支和远程分支同步到远程分支（检出 main）（任一条即可）： git merge o/main git rebase o/main git cherry-pick o/main 等等 一步到位：git pull 一步下载更新，并同步更新本地分支。 git pull 等价于 git fetch + git merge o/main git pull --rebase 等价于 git fetch + git rebase o/main 五、上传到远程仓库并合并 git push 不带任何参数时的行为与 Git 的一个名为 push.default 的配置有关。 它的默认值取决于你正使用的 Git 的版本，但是在教程中我们使用的是 upstream。 这没什么太大的影响，但是在你的项目中进行推送之前，最好检查一下这个配置。 使用命令：git push 把本地分支main的更新提交到远程仓库 更新远程仓库的分支 同时远程分支o/main也更新到本地分支main的位置 就是说，所有的分支都同步了。 六、偏离的历史提交 无法git push：本地的工作基于旧的提交，Git 会拒绝你直接推送到远程仓库。 方法：让本地的新工作，和远程仓库的更新，合并，再提交。 git fetch -&gt; git rebase o/main -&gt; git push git rebase 让本地更新移到了最新的工作记录下 git fetch -&gt; git merge o/main -&gt; git push git merge 创建新的提交，包含了本地更新和远程仓库最新的工作记录 git pull --rebase -&gt; git push git pull -&gt; git push 总之，就是要把远程仓库的最新情况下载下来，把自己的更新和最新的合并，然后才能再发布到远程仓库。 七、远程服务器拒绝 ! [远程服务器拒绝] main -&gt; main (TF402455: 不允许推送(push)这个分支; 你必须使用pull request来更新这个分支.) 在一个大的项目里，main可能会被锁定。 正确做法： 创建一个新的分支 git push 提交Pull Request 如果忘记创建分支，直接提交，就会卡住，回退解决： 回退：git reset HEAD^ / git reset C1 （C1 是 o/main 所指节点） 创建新分支：git checkout -b feature C2 提交：git push 八、合并特性分支（rebase） 特性分支是指为一个特定的需求/任务/缺陷创建的分支，在其上完成相应开发后，一般会把它合并到集成/发布分支，与其他改动(若有)一起集成并最终发布。 12345$git checkout main # 1. 进入当前分支 main$git rebase feature1 # 2. 将特性分支集成到 main 上$git rebase feature2$git pull --rebase # 3. 将更新 rebase 到远程分支到最新提交记录$git push # 4. 推送到远程仓库 Tips：因为 rebase 是在一条线上不断更新，所以最后一步 rebase 一定是要 rebase 到远程仓库的最新记录。 九、合并特性分支（merge） 在开发社区里，有许多关于 merge 与 rebase 的讨论。以下是关于 rebase 的优缺点： 优点: Rebase 使你的提交树变得很干净, 所有的提交都在一条线上 缺点: Rebase 修改了提交树的历史 一些开发人员喜欢保留提交历史，因此更偏爱 merge。 而其他人可能更喜欢干净的提交树，于是偏爱 rebase。 使用git merge完成合并特性分支： 12345$git checkout main # 1. 进入 main 分支$git pull # 2. 获取远程更新$git merge side1 # 3. 将特性分支合并到 main$git merge side2$git push # 4. 推送并更新远程仓库 Tips：merge 需要父节点，所以一定要注意，在祖先节点里包含远程仓库的最新纪录。","categories":[{"name":"Git","slug":"Git","permalink":"https://doreality.xyz/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://doreality.xyz/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"https://doreality.xyz/tags/GitHub/"}]},{"title":"Git 分支（一）","slug":"git/git-branch-1","date":"2021-10-17T15:49:59.000Z","updated":"2023-04-07T16:29:36.412Z","comments":true,"path":"posts/e01b0c7d.html","link":"","permalink":"https://doreality.xyz/posts/e01b0c7d.html","excerpt":"发现了一个神奇的网站，可以图形化交互式学习 Git。 趁此机会，好好学习了一下关于分支操作的命令～ 重点： 简单的分支操作：创建、跳转、合并 在分支上前进和后退 修改提交树的结构 高级技巧","text":"发现了一个神奇的网站，可以图形化交互式学习 Git。 趁此机会，好好学习了一下关于分支操作的命令～ 重点： 简单的分支操作：创建、跳转、合并 在分支上前进和后退 修改提交树的结构 高级技巧 早分支，早享受。 基础篇 Git Commit Git 仓库中的提交记录保存的是你的目录下所有文件的快照，就像是把整个目录复制。 它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。 Git 还保存了提交的历史记录。把提交记录看作是项目的快照。提交记录非常轻量，可以快速地在这些提交记录之间切换。 使用命令：git commit 表示从父节点的记录更新了东西，变成了新节点。 一般需要附带选项 -m &quot;comment&quot;，对新的提交记录进行简要注释。 高级篇 移动提交记录 技巧杂项 高级操作 git branch git branch -m newname git branch -f somewhere git checkout somebranchname git merge git rebase 更多学习 a simple git branching model OneFlow – a Git branching model and workflow","categories":[{"name":"Git","slug":"Git","permalink":"https://doreality.xyz/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://doreality.xyz/tags/Git/"}]},{"title":"Python 根据源码生成类图","slug":"memos/python/python-code-generate-uml-class-package-graph","date":"2021-10-13T14:58:25.000Z","updated":"2023-12-04T15:19:10.215Z","comments":true,"path":"posts/e471ba7e.html","link":"","permalink":"https://doreality.xyz/posts/e471ba7e.html","excerpt":"","text":"Pyreverse 首先安装graphviz，用于绘图 pyreverse能方便的生成uml类图，pylint里自带了pyreverse这个工具 pip install pylint 使用 pyreverse -ASmy -o esp -p _后缀 目录/ 参考：python代码自动生成类图_python逆向工程：通过代码生成类图 PyCharm 在 PyCharm 中，右键点击想分析的模块文件，或者在编辑器中右键，选择Diagrams-&gt;Show Diagrams，就可以生成当前代码的类图。","categories":[{"name":"Memos","slug":"Memos","permalink":"https://doreality.xyz/categories/Memos/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://doreality.xyz/tags/Python/"},{"name":"PyCharm","slug":"PyCharm","permalink":"https://doreality.xyz/tags/PyCharm/"},{"name":"UML","slug":"UML","permalink":"https://doreality.xyz/tags/UML/"}]},{"title":"Android Studio SDK 配置","slug":"memos/Android/Android Studio中SDK配置","date":"2021-10-10T08:54:00.000Z","updated":"2023-12-04T15:42:18.023Z","comments":true,"path":"posts/5cd6b5b7.html","link":"","permalink":"https://doreality.xyz/posts/5cd6b5b7.html","excerpt":"刚开始学习 Android 开发，比较迷惑。不想安装太多SDK，还有想知道各个版本的SDK的区别，就了解了一下。 最后结论就是，M1 的 macOS，看来最低版本的 SDK 只能是 7.0 了，因为从 7.0 才开始有ARM64的支持。","text":"刚开始学习 Android 开发，比较迷惑。不想安装太多SDK，还有想知道各个版本的SDK的区别，就了解了一下。 最后结论就是，M1 的 macOS，看来最低版本的 SDK 只能是 7.0 了，因为从 7.0 才开始有ARM64的支持。 SDK Platform 看官方手册中的关于SDK Platform： 对于每个 SDK Platform 版本，必须至少安装一下三个选项： Android SDK Platform：必须下载 System Image：下载对应自己电脑体系结构的版本即可（至少要有一个） Sources for Android：Platform 的源代码。在调试时可能会显示其中的代码行。 SDK Tools 官方手册中关于SDK Tools： 一些必要的工具，每个版本都向后兼容，所以只需要下载安装一个最新的即可。 配置命令行 aapt aapt 是 SDK Tools 中的一个工具，用于解析应用的资源文件，并翻译成R.java。 找到 SDK 所在的路径 Mac环境下，安装过 Android Studio 并进行上述配置后，SDK的目录如下： 1$ cd /Users/your-username/Library/Android/sdk your-username替换为自己实际的用户名即可。 查看 build-tools 版本 在 SDK 目录下，执行如下： 1234$ ls$ cd build-tools$ ls$ cd 31.0.0 #就是上面在 Android Studio 中配置的 SDK Tools 版本 在此目录下就可以看到aapt工具了。此时，执行pwd，可以打印出当前路径。 回到用户目录，配置Shell 如果是用的 Mac 自带的 bash，打开~/.bash_profile： 12$ cd ~$ vi .bash_profile 如果是使用的 zsh，打开~/.zshrc： 12$ cd ~$ vi .zshrc 之后，在打开的文件中，加入以下内容： 123456789# Android aaptAAPT_HOME&#x3D;&#x2F;Users&#x2F;your-username&#x2F;Library&#x2F;Android&#x2F;sdk&#x2F;build-tools&#x2F;31.0.0export AAPT_HOMEexport PATH&#x3D;$PATH:$AAPT_HOME# 还可以顺便把其他工具也加入环境中ANDROID_HOME&#x3D;&#x2F;Users&#x2F;your-username&#x2F;Library&#x2F;Android&#x2F;sdkexport PATH&#x3D;$PATH:$ANDROID_HOME&#x2F;toolsexport PATH&#x3D;$PATH:$ANDROID_HOME&#x2F;platform-tools 如图所示： Vim 操作： 按i进行插入 按esc退出插入模式 输入:wq再回车，即保存 保存完毕后，重新启动终端，输入aapt v，显示版本号即可。","categories":[{"name":"Memos","slug":"Memos","permalink":"https://doreality.xyz/categories/Memos/"}],"tags":[{"name":"Environment","slug":"Environment","permalink":"https://doreality.xyz/tags/Environment/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"https://doreality.xyz/tags/Android-Studio/"}]},{"title":"「C++ Primer」Chapter 01","slug":"dev/backend/cpp/cpp_primer/cpp-primer-ch01","date":"2021-09-23T04:18:53.000Z","updated":"2023-04-07T16:38:15.643Z","comments":true,"path":"posts/fa96995b.html","link":"","permalink":"https://doreality.xyz/posts/fa96995b.html","excerpt":"《C++ Primer》（第 5 版）的练习代码在这里♡.","text":"《C++ Primer》（第 5 版）的练习代码在这里♡. 第 1 章 开始 环境 macOS big sur（Apple M1，16GB 内存） 已安装 Xcode，Apple Clang Version 12.0.0 编译运行 用命令行编译： 1$ clang++ -std=c++1y -Wall prog1.cc -o prog1 -o选项是设置可执行程序的别名，这里是把源程序prog1.cc生成的可执行文件命名为prog1，如不设置默认是a.out。 -Wall选项是显示所有的warning，可以帮助更加规范编程。 执行： 1$ ./prog1 获得返回值： 1$ echo $? 返回值是 0，表示正常退出；其他值都表示程序异常结束，常见的是-1。 输入输出 标准输入输出 来自iostream库的基础类型：输入流istream和输出流ostream。 标准库定义了 4 个 IO 对象： cin：标准输入，istream类型的对象； cout：标准输出，ostream类型的对象； cerr：标准错误，ostream类型的对象； clog：输出运行时一般信息，ostream类型的对象。 头文件 头文件（header）使用时： #include和头文件的名字必须写在同一行； 通常情况，#include出现在函数之外； 一般，把一个程序所有的#include放在源文件的开始。 写入和读取 &lt;&lt;：输出运算符 接收两个对象，左侧对象必须是一个ostream对象，右侧对象是要打印的值。 计算结果是左侧对象。 endl：操纵符（manipulator） 结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。 缓冲刷新操作可以保证，目前为止程序所产生的所有输出都真正写入输出流中，而不是停留在内存中等待写入流。 ::：作用域运算符 指出命名空间，例如std::cout，使用名为std的命名空间中的名字cout。 &gt;&gt;：输入运算符 与输出运算符类似，左侧对象为istream对象，右侧对象保存左侧读入的数据。 计算结果是左侧对象。 注释 单行注释 1// 单行注释 多行注释 123/* * 界定符注释 */ 要注意的是，界定符注释不能嵌套，因为有就近原则，外层的/*会和内层的*/匹配，导致意外的错误。 控制流 while 语法如下： 123while (condition) &#123; statement&#125; 执行顺序： 判断循环条件，为真，则进入2；为假，跳出循环。 执行循环体，结束后进入1。 for 语法如下： 1234// 依次是：循环变量初始化；循环条件；表达式。for (int it = 0; it &lt; 10; it++) &#123; statement&#125; 执行顺序： 执行初始化语句（没有初始化就跳过这一步）； 判断循环条件，为真，进入 3；为假，跳出循环。 执行循环体内的语句，进入4； 执行表达式，进入2。 可见，初始化语句只在开始进入循环的时候执行一次，且唯一一次。 文件结束符 Windows 系统：Ctrl+Z ，然后按 Enter UNIX 系统（包括 Mac OS X）：Ctrl + D 编译错误 语法错误（syntax error） 类型错误（type error） 声明错误（declaration error） 好的习惯：edit - compile - debug 按照报告的顺序逐个修正错误 在每修正一个错误后就立即重新编译代码 最多是修正了一小部分明显的错误后就重新编译 缩进和格式 保持一致性 牢记：其他可能的程序格式总是存在的 一旦选择了一种风格，就要坚持使用 文件重定向 1$ addItems &lt;infile &gt;outfile","categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://doreality.xyz/tags/CPP/"}]},{"title":"基于 iTerm 2 + oh-my-zsh 的终端配置","slug":"memos/macOS/基于 iTerm 2 + oh-my-zsh 的终端配置","date":"2021-09-13T18:33:56.000Z","updated":"2023-12-04T15:17:03.033Z","comments":true,"path":"posts/e72c762f.html","link":"","permalink":"https://doreality.xyz/posts/e72c762f.html","excerpt":"终端的主题 + 配色方案。","text":"终端的主题 + 配色方案。 在如下位置修改主题： 12$ cd ~$ vi .zshrc 修改配色 首先，从官网上下载 iTerm 2 配色方案。 菜单栏 - iTerm2 - Profiles - Colors - 右下角 Color Presets，导入下载的预设文件。 参考 iTerm 2 配色方案 oh-my-zsh 主题","categories":[{"name":"Memos","slug":"Memos","permalink":"https://doreality.xyz/categories/Memos/"}],"tags":[{"name":"oh-my-zsh","slug":"oh-my-zsh","permalink":"https://doreality.xyz/tags/oh-my-zsh/"},{"name":"zsh","slug":"zsh","permalink":"https://doreality.xyz/tags/zsh/"}]},{"title":"macOS 安装 md5sum 命令","slug":"memos/macOS/macOS安装md5sum命令","date":"2021-09-13T16:30:42.000Z","updated":"2023-12-04T15:17:08.898Z","comments":true,"path":"posts/803b8154.html","link":"","permalink":"https://doreality.xyz/posts/803b8154.html","excerpt":"用 brew 安装 md5sum 起因是《Learn C The Hard Way》的练习 4 里，要使用 Valgrind 工具。安装该工具的时候，作者写着要用源代码方式安装，并且用到了 md5sum 进行匹配，由于之前用过 brew ，所以优先用这个方法安装。","text":"用 brew 安装 md5sum 起因是《Learn C The Hard Way》的练习 4 里，要使用 Valgrind 工具。安装该工具的时候，作者写着要用源代码方式安装，并且用到了 md5sum 进行匹配，由于之前用过 brew ，所以优先用这个方法安装。 在百度搜到的方法命令，一行： 1$ brew install md5sha1sum 然而我的运行结果： 照着这条错误提示：Not a valid ref: refs/remotes/origin/master，找到的方法是卸载 brew，重新安装。 运行卸载命令： 1$ /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/uninstall.sh)&quot; 提示信息如下： 1curl: (35) LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to raw.githubusercontent.com:443 尝试修改代理方法（失败）： 1$ git config --global --unset http.proxy 根据这篇文章，使用国内源： 1$ /bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot; 运行截图如下（会卸载老版本，然后安装新的）： 再次搜索md5sha1sum，搜索出来啦，安装成功～ 用源码安装 去官方网站获取源码，地址如下： http://microbrew.org/tools/md5sha1sum/md5sha1sum-0.9.5.tar.gz 之后，在下载目录进行如下操作： 12345$ tar xvfz md5sha1sum-0.9.5.tar.gz$ cd md5sha1sum-0.9.5$ ./configure$ make$ make install 参考 Macos 安装md5sum、sha1sum、md5deep、sha1deep","categories":[{"name":"Memos","slug":"Memos","permalink":"https://doreality.xyz/categories/Memos/"}],"tags":[{"name":"macOS","slug":"macOS","permalink":"https://doreality.xyz/tags/macOS/"},{"name":"Homebrew","slug":"Homebrew","permalink":"https://doreality.xyz/tags/Homebrew/"}]},{"title":"Git 日常积累（一）","slug":"git/git-summary-1","date":"2021-04-02T13:27:28.000Z","updated":"2024-03-03T13:16:37.481Z","comments":true,"path":"posts/d00de0a5.html","link":"","permalink":"https://doreality.xyz/posts/d00de0a5.html","excerpt":"刚开始使用 Git 和 GitHub，慢慢记录一些自己学到的常用的命令，当作备忘录吧。 本期重点： 从远程仓库下载 上传到仓库 使用 .gitignore 管理目录","text":"刚开始使用 Git 和 GitHub，慢慢记录一些自己学到的常用的命令，当作备忘录吧。 本期重点： 从远程仓库下载 上传到仓库 使用 .gitignore 管理目录 要和 GitHub 有交流，需要配置好 SSH（可以参考同一主机下使用多个的GitHub账号搭建Hexo博客中「生成new账号的SSH」一节）。 从远程仓库下载 12345678$ git clone [仓库链接]# https 方式$ git clone https://xxxxxx.git# ssh 方式 @的后面是你的ssh配置的host# 如果在建立 GitHub 的 ssh 的时候没有额外设置，默认是 github.com$ git clone git@yourHostName:username/reponame.git 上传到仓库 如果是本地文件上传，需要先在 GitHub 上新建一个仓库，之后再操作： 123456$ git init # 新建git仓库$ git add .$ git commit -m &quot;first commit&quot;$ git branch -M main # main 或者 master 看仓库具体分支是什么名字$ git remote add origin git@yourHostName:username/reponame.git$ git push -u origin main 如果是之前已经clone或者其他方式存在的： 123$ git remote add origin git@github.com:username/reponame.git$ git branch -M main$ git push -u origin main 使用 .gitignore 管理目录 使用 .gitignore 可以把不想上传的文件屏蔽掉。 只需要在文件目录下建立一个名为.gitignore的文件即可，内容格式如下： 12345678910111213# comment# 屏蔽掉当前目录下后缀为 .a 的所有文件*.a # 屏蔽当前目录下所有文件和目录* # 屏蔽 dir 目录&#x2F;dir&#x2F; # 屏蔽每一个目录下的相同文件**&#x2F;.DS_Store 除了屏蔽功能，还有可以增加的功能： 123# 增加 dir 目录以及其下所有子目录和文件!&#x2F;dir&#x2F; !&#x2F;dir&#x2F;**&#x2F; 需要注意的一点是，如果进行过git push后再新增或者修改.gitignore，那么想 ignore 的文件在之前如果被 tracked，就会不起作用。这时，需要先清空缓存，把所有的文件变成 untracked ： 1$ git rm -r --cached . 然后再提交即可： 123$ git add . $ git status # 查看被忽略的文件是否已经 untracked $ git commit -m &quot;add .gitignore&quot; 撤回 gid add，可以使用 git reset（对全部文件撤回） 更多 .gitignore 参考 gitignore。","categories":[{"name":"Git","slug":"Git","permalink":"https://doreality.xyz/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://doreality.xyz/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"https://doreality.xyz/tags/GitHub/"}]},{"title":"如何设置 Hexo 博客的永久链接","slug":"memos/hexo/hexo-permanent-link","date":"2021-03-29T13:37:10.000Z","updated":"2023-12-04T15:16:58.147Z","comments":true,"path":"posts/c762735f.html","link":"","permalink":"https://doreality.xyz/posts/c762735f.html","excerpt":"Hexo 支持的永久链接的格式会把中文转换成一长串编码，修改标题或者引用链接都会很麻烦。","text":"Hexo 支持的永久链接的格式会把中文转换成一长串编码，修改标题或者引用链接都会很麻烦。 有提供支持编码的插件，安装再修改配置文件即可。 安装插件 在博客的根目录下，安装插件： 1$ npm install hexo-abbrlink --save 修改配置 安装成功之后，打开_config.yml修改如下： 123456# permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;# permalink_defaults:permalink: posts&#x2F;:abbrlink.htmlabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex 重新生成 配置好之后： 12$ hexo clean$ hexo g 此时，每一篇博客的.md文件的首部都加入abbrlink条目，说明成功生成了这篇文章的永久链接，之后再修改标题都不会影响了。 发布之后，就会看到每篇博客的标题变成了：https://your_domain_name/posts/abbrlink.html 其中，your_domain_name是你的网站域名，abbrlink是这篇文章的永久链接编码。 这样，永久链接就搞定了。 参考 Hexo折腾系列——永久链接优化","categories":[{"name":"Memos","slug":"Memos","permalink":"https://doreality.xyz/categories/Memos/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://doreality.xyz/tags/Hexo/"}]},{"title":"oh-my-zsh 更新之后主题不能用","slug":"Q&A/oh-my-zsh-updated-cannot-use-themes","date":"2021-03-29T07:50:24.000Z","updated":"2023-04-07T16:06:27.110Z","comments":true,"path":"posts/93ed9593.html","link":"","permalink":"https://doreality.xyz/posts/93ed9593.html","excerpt":"前几天打开 iTerm 2 之后，提示我更新，之后就没再用。 今天打开发现之前设置好的主题不能用了。","text":"前几天打开 iTerm 2 之后，提示我更新，之后就没再用。 今天打开发现之前设置好的主题不能用了。 解决问题 打开 iTerm 2 的时候，有一句提示： ~/.oh-my-zsh/themes/agnoster.zsh-theme: 91 parce error near &quot;&lt;&lt;&lt;&quot; 不太懂为什么是语法错误，反正是主题文件出问题了，于是跑到主题的官方页面上用原本的主题文件的内容替换了一下，就好了。 两个简单的 vim 命令 中间用vi定位的时候学到两条命令： :set number：可以标注行号 删除内容（不过不是真的删除，而是剪切，会把删除内容保存到缓冲区）： dd：删除一行 ddp：当前行和下一行交换 ddP：当前行和上一行交换 dG：全部剪切 粘贴的时候就直接在网页里复制，然后在窗口里右键 paste（不用进入编辑模式就可以）。 之后:wq，重启 iTerm 2，搞定。 参考 新手教程：下载安装 iTerm 2 和 oh-my-zsh，并设置主题以及配置相关依赖 agnoster 主题的主页 一个简单的 vi 复制粘贴的教程","categories":[{"name":"Q&A","slug":"Q-A","permalink":"https://doreality.xyz/categories/Q-A/"}],"tags":[{"name":"oh-my-zsh","slug":"oh-my-zsh","permalink":"https://doreality.xyz/tags/oh-my-zsh/"},{"name":"Vim","slug":"Vim","permalink":"https://doreality.xyz/tags/Vim/"}]},{"title":"同一主机下使用多个 GitHub 账号搭建 Hexo 博客","slug":"memos/hexo/one-host-multi-accounts-hexo","date":"2021-03-08T12:37:54.000Z","updated":"2023-12-04T15:16:50.388Z","comments":true,"path":"posts/9fda10db.html","link":"","permalink":"https://doreality.xyz/posts/9fda10db.html","excerpt":"在一台电脑，一个 GitHub 账号的情况下，来搭建 Hexo 博客，可参考 这篇博客。 可是……我又有了一个新的 GitHub 账号，还是这台电脑，要在新账号上搭建一个新的博客（也就是说，要在一台电脑上同时操作两个GitHub账号），就要解决不同的SSH下的远程连接的问题。","text":"在一台电脑，一个 GitHub 账号的情况下，来搭建 Hexo 博客，可参考 这篇博客。 可是……我又有了一个新的 GitHub 账号，还是这台电脑，要在新账号上搭建一个新的博客（也就是说，要在一台电脑上同时操作两个GitHub账号），就要解决不同的SSH下的远程连接的问题。 在这里，默认已经学会了一台电脑一个账号的情况下，搭建 Hexo 博客的方法。 假设： 旧 GitHub 账号，简称 old，邮箱：old@example.com 新 GitHub 账号，简称 new，邮箱：new@example.com 在 old 已经搭建了 Hexo 的情况下： git 已经进行过如下设置： 12$ git config --global user.name &quot;old&quot;$ git config --global user.email &quot;old@example.com&quot; 在用户目录的 .ssh 路径下默认配置了 old 账号的 SSH（敲了三个回车），其中私钥的文件名是 id_rsa，公钥文件名是 id_rsa.pub。 Windows的用户目录：C:\\Users\\username\\.ssh\\ macOS和Linux的用户目录：/users/username/.ssh/（也就是~/.ssh/） 我需要做两件事： 部署 new 账号的 SSH； 利用 new 的 SSH，将新博客部署到 new 账号的 new.github.io 仓库。 建立 new 账号的 Hexo 博客 此处为大致步骤，详细请见 这篇博客。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 此处&lt;folder&gt;假设为new_blog，下面会用到。 生成 new 账号的 SSH SSH 用于本地主机和远程服务器交流，对账户和密码进行加密，直接在本机上生成即可。 本部分的操作在用户目录的.ssh目录下，使用git bash运行命令行。 创建 SSH key 1$ ssh-keygen -t rsa -C &quot;new@example.com&quot; -f &quot;id_rsa_new&quot; 第一个引号中，填写 GitHub 的账号地址； 第二个引号中，自定义填写，不能默认，否则会覆盖之前已经存在的id_rsa和id_rsa.pub。 之后，敲两次回车，默认即可。 添加私钥 由于使用 SSH 时，默认使用id_rsa的私钥，所以要把新建的私钥添加到系统中： 12$ ssh-agent bash$ ssh-add ~/.ssh/rsa_name 此时提示Identity added:……即完成。 设置 SSH config 依旧在.ssh路径下，新建config文件： 1$ touch config 打开config文件（用文本编辑器），输入以下内容： 1234Host newgithub # 名称，自定义，会影响后续指令，用于连接 GitHub 仓库HostName github.com # 主机名，用于 GitHub 连接的 SSH，HostName 必须是“github.com&quot;User newgit # 用户名，自己决定IdentityFile C:\\Users\\Administrater\\.ssh\\id_rsa_new # 刚才新建的 rsa 私钥路径，具体看文件夹中路径 注意，对于默认生成的 SSH，Host条目的默认值是github.com，所以不要使用，会冲突。 此外，如果是用于别的服务器连接，HostName 可以是其他的域名，例如：gitgee.com 等。 部署 SSH 到 GitHub 用文本编辑器打开id_rsa_new.pub，复制公钥内容。 打开 「new GitHub 账号」 - 「右上角头像」 - 「Settings」 - 「SSH and GPG Keys」 页面； 然后，新建一个 SSH 条目，Title 自定义，Key 处粘贴公钥。 远程测试 1$ ssh -T git@newgithub # @后面是3.中Host的名字 显示You've successfully authenticated, but GitHub does not provide shell access.说明设置成功。 至此，new 的 SSH 的部署完成。 部署到 new GitHub 接下来，就要把新的 hexo 博客部署到相应的 new GitHub账号了。 修改 deploy 设置 如下设置new_blog目录下的_config.yml即可： 1234deploy: type: git repository: git@newgithub:new&#x2F;new.github.io.git branch: master 注意：@的后面是设置 SSH 时的 Host，并且不要忘记最末尾的.git。 添加 hexo 的 git 部署工具 在new_blog目录中，右键打开git bash，添加hexo-git-deployer工具，用于部署： 1$ npm install hexo-deployer-git –-save 部署 现在，就可以部署了： 12$ hexo g$ hexo d 此时，应该会成功部署到new账号的仓库中，但是上传的用户却是old用户。 原因是之前把old用户设置成了global全局权限，而 Hexo 博客在部署时，默认使用的是全局用户，所以操作时出现了问题。 如果不修改global权限，可以打开new_blog/.deploy_git/.git目录，在config文件中添加下面的内容即可： 123[user] name &#x3D; new email &#x3D; new@example.com 之后再对博客更新，就是new用户了。 到这里，在一台电脑上，就可以用不同的 GitHub 账号分别操作不同的 Hexo 博客了。 附：多 GitHub 账号的文件操作 如果不是搭建博客，而是多个账号分别进行项目管理的话，大致思路是一样的。 首先，也要对新账号建立 SSH 的部署，见正文第二部分。 之后，只要设置好相应的git config的用户信息，就可以正常操作了。 建立 git 仓库 打开项目的目录，新建 git 仓库。 1$ git init 设置 git config 给仓库设置用户和邮箱，在提交时会用到。 12$ git config user.name &quot;username&quot;$ git config user.email &quot;useremail&quot; 将本地仓库和远程仓库连接 如果要从远程仓库中下载原有的项目： 12$ git init$ git clone git@newgithub:new/newproject.git @后面也要使用设置 SSH 时的 Host。 如果要新建项目，利用前文建立好的 SSH，和远程仓库连接： 1$ git remote add origin git@newgithub:yourName/yourRepo.git 其中，yourName是 GitHub 的用户名，yourRepo 是相连的仓库（需提前建立）。 可以测试一下是否连接成功： 1$ git remote -v 之后正常操作，例如： 1234$ git status # 查看文件状态$ git add . # 添加所有文件$ git commit -m &#x27;a new commit&#x27; # 记录$ git push origin master # 上传，master是主分支，按情况修改 参考 git连接github总结 Windows下Git多账号配置，同一电脑多个ssh-key的管理 不想使用全局用户？教你为Hexo博客单独配置指定的git用户 如何生成多个ssh并将hexo博客布置到github 一台电脑使用两个git账号","categories":[{"name":"Memos","slug":"Memos","permalink":"https://doreality.xyz/categories/Memos/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://doreality.xyz/tags/GitHub/"},{"name":"Hexo","slug":"Hexo","permalink":"https://doreality.xyz/tags/Hexo/"},{"name":"SSH","slug":"SSH","permalink":"https://doreality.xyz/tags/SSH/"}]},{"title":"第N次：从零搭建 Hexo 博客并部署到 GitHub","slug":"memos/hexo/build-hexo-blog-from-zero","date":"2021-03-08T12:15:41.000Z","updated":"2023-12-04T15:16:10.766Z","comments":true,"path":"posts/4331facb.html","link":"","permalink":"https://doreality.xyz/posts/4331facb.html","excerpt":"第 N 次搭建博客的熟练工表示，搭起来真的很快，但是坚持写下去，好不容易。","text":"第 N 次搭建博客的熟练工表示，搭起来真的很快，但是坚持写下去，好不容易。 为什么选择用 GitHub 来搭载博客？ 至少我可以不用先花钱买个域名，再学习怎么搭个服务器，怎么写个网页，这一系列繁琐的事情都能迅速解决，我能很快投入到纯粹的写作中来。 既然到了这里，那么最基础的要求，就是拥有一个 GitHub 账号和一台能联网的电脑，最好是会一点命令行操作。接下来要怎么办，本文都可以试着帮你解决。 环境准备 下载安装如下工具： Git 客户端（适合你的操作系统的） 最新版的 Node.js 本篇博客的使用的环境如下： Windows 10 64bit Node.js v14.16.0 Git version 2.30.0.windows.1 搭建博客 搭建本地博客 关于 Hexo 的一切都可以看官方文档。 先打开一个路径，右键 git bash，在这里开始搭建博客。 首先，安装 Hexo： 1$npm install hexo-cli -g 其次，建立博客目录（这里是 blog，可以自己随便命名）： 123$hexo init blog$cd blog$npm install 顺利执行完毕，博客需要的基本内容就准备好了。 想要本地预览一下，可以输入命令： 1$hexo server 根据提示，到 localhost:4000 就能看到使用原始主题 landscape 的博客。（关于博客的主题更换，可以看本文最后“附”部分）。 这样，本地博客就准备就绪了。 连接 GitHub 本地连接 GitHub 可以用两种方式。 SSH 方式 可以绑定一台主机和一个远程服务器，每次不需要手动输入账号和密码，方便快捷，但是每更换一台电脑就需要重新设置 SSH。 HTTPS 方式 更加便捷，没有绑定，但是每次需要手动输入账号密码，有一点麻烦。 这里使用的是 SSH 的方式，所以要把主机和 GitHub 账号进行一次“绑定”。 在用户目录，找到 .ssh 文件夹，打开之后 git bash，邮箱是 GitHub 账号的注册邮箱： 1$ssh-keygen -t rsa -C &quot;youremail&quot; 之后敲击三次回车，会在该目录下生成私钥文件 id_rsa 和公钥文件 id_rsa.pub。 打开 id_rsa.pub 文件，复制公钥的内容，然后打开 GitHub 主页，右上角头像里找到 Settings，进入 SSH and GPG keys 页面，点击 New SSH key，新建一个 SSH，title 自己随便填，再把剪贴板粘贴在 key 部分，保存即可。 可以输入以下命令，测试一下是否顺利连接： 1$ssh -T git@github.com 出现提示 Are you sure you want to continue connecting (yes/no)?，输入 yes。 之后看到 Hi &quot;username&quot;! You've successfully authenticated, but GitHub does not provide shell access. 说明已经顺利连接。 &quot;username&quot; 部分是你的 GitHub 的用户名。 建立仓库 新建一个名为 username.github.io 的 public 仓库，等到部署之后，就可以通过 http://username.github.io 网址来访问你的博客了。 同上，username 部分是用户名，每一个 GitHub 账号可以创建唯一一个这样的仓库，用于展示静态网页。 部署博客 进入本地博客的目录，打开git bash： 首先，设置 git 的账号，和 GitHub 账号保持一致： 12$git config --global user.name &quot;username&quot; # 可以随便写$git config --global user.email &quot;useremail&quot; # GitHub 账号的邮箱 为了把博客部署到 GitHub，需要安装插件： 1$npm install hexo-deployer-git --save 然后，就可以部署了： 1$hexo deploy # 或者 hexo d 到此，就完成了。 使用个性域名（可选） 首先要购买一个域名，我购买域名的网站是 GoDaddy，因为之前有用过，就懒得换了。 也有其他可选的网站，在阿里云、腾讯云、华为云上都可以购买，而且很多辅助的项目可以勾选，网站邮箱和安全保护之类的，总之都很方便，也都差不多价格。 主要问题就是如何把已经购买好的域名和username.github.io这个网址绑定起来。 配置域名的 DNS 首先，通过在命令里，使用命令 ping username.github.io，得到博客主页的 IP 地址。 然后，到域名的管理页面，找到 DNS 配置。把域名的 DNS 解析配置为两个： A记录：主机名是@，值为刚才ping到的 IP 地址。 CNAME：主机名是www，值为username.github.io 添加 CNAME 文件 在博客的本地文件目录下，找到source文件夹，添加文件CNAME（无后缀名），在里面写上刚刚购买的域名地址（加上https://前缀），保存即可。 上传发布 123$hexo clean$hexo g$hexo d 在博客所在仓库的Settings页面，找到最下方的Custom domain栏，可以看到，已经是自己的域名了。 附 ：如何写作和配置主题 写一篇博客 新建，在 blog 目录下： 1$hexo new &quot;title&quot; 会在 source/_posts/ 中，看到一个以该标题 title 命名的 Markdown 文件，这就是可以编辑的文档。 写作 用喜欢的文本编辑器打开这个文件（我比较喜欢Typora，目前在用 Obsidian），会发现里面已经有一些信息了，例如：title，date，还（可能）有tags等属性，自己也可以添加属性，不过具体要看选择的主题支不支持。 自己可以填写一些这些信息： 1234567tags:- atag- btagcategories:- a_cat- b_cat--- 在---下面开始写正文。 另外，如果在首页不想显示文章的全部，那么就在分隔的位置写一行&lt;!-- more --&gt;就可以了（根据具体使用的主题而言）。 引用图片 和直接用 Markdown 的语法引用超链接不同，插入图片需要提前进行配置。 Hexo 官网给了两种解决方案；这里选了浏览和整理时更清晰的一种——为每篇文档新建一个资源文件夹。 先进行插入图片的设置： 打开博客根目录下的_config.yml，找到相关条目，修改并添加： 1234post_asset_folder: truemarked: prependRoot: true postAsset: true 设置好之后，再新建文档，会同时建立一个和文档同名的文件夹，用来放这篇文档需要的图片文件。（如果是之前的文章，没有创建资源文件夹，自己手动新建一个即可。） 图片的引用格式 相对引用，可以使用 Markdown 的 ![](image.jpg)，直接写图片的名字即可。 Hexo 3 版本下，使用新的资源引用方法： 1&#123;% asset_img example.jpg This is an example image %&#125; 配置主题 在 GitHub 上搜索 hexo theme，就能搜到很多主题，找一个自己喜欢的，按照给的教程下载配置即可。 主要是修改博客根目录下的 _config.yml 中的 theme 的值。 参考 Hexo 官网 使用hexo+github搭建免费个人博客详细教程 Hexo+Github 绑定域名 GitHub+Hexo 搭建个人网站详细教程","categories":[{"name":"Memos","slug":"Memos","permalink":"https://doreality.xyz/categories/Memos/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://doreality.xyz/tags/GitHub/"},{"name":"Hexo","slug":"Hexo","permalink":"https://doreality.xyz/tags/Hexo/"}]}],"categories":[{"name":"Development","slug":"Development","permalink":"https://doreality.xyz/categories/Development/"},{"name":"Memos","slug":"Memos","permalink":"https://doreality.xyz/categories/Memos/"},{"name":"Q&A","slug":"Q-A","permalink":"https://doreality.xyz/categories/Q-A/"},{"name":"Git","slug":"Git","permalink":"https://doreality.xyz/categories/Git/"},{"name":"Projects","slug":"Projects","permalink":"https://doreality.xyz/categories/Projects/"},{"name":"AIML","slug":"AIML","permalink":"https://doreality.xyz/categories/AIML/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doreality.xyz/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"https://doreality.xyz/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://doreality.xyz/tags/CSS/"},{"name":"Hexo","slug":"Hexo","permalink":"https://doreality.xyz/tags/Hexo/"},{"name":"Environment","slug":"Environment","permalink":"https://doreality.xyz/tags/Environment/"},{"name":"zsh","slug":"zsh","permalink":"https://doreality.xyz/tags/zsh/"},{"name":"Python","slug":"Python","permalink":"https://doreality.xyz/tags/Python/"},{"name":"Pyenv","slug":"Pyenv","permalink":"https://doreality.xyz/tags/Pyenv/"},{"name":"Conda","slug":"Conda","permalink":"https://doreality.xyz/tags/Conda/"},{"name":"Git","slug":"Git","permalink":"https://doreality.xyz/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"https://doreality.xyz/tags/GitHub/"},{"name":"oh-my-zsh","slug":"oh-my-zsh","permalink":"https://doreality.xyz/tags/oh-my-zsh/"},{"name":"macOS","slug":"macOS","permalink":"https://doreality.xyz/tags/macOS/"},{"name":"Homebrew","slug":"Homebrew","permalink":"https://doreality.xyz/tags/Homebrew/"},{"name":"C","slug":"C","permalink":"https://doreality.xyz/tags/C/"},{"name":"CPP","slug":"CPP","permalink":"https://doreality.xyz/tags/CPP/"},{"name":"OOP","slug":"OOP","permalink":"https://doreality.xyz/tags/OOP/"},{"name":"GDB","slug":"GDB","permalink":"https://doreality.xyz/tags/GDB/"},{"name":"LLDB","slug":"LLDB","permalink":"https://doreality.xyz/tags/LLDB/"},{"name":"Linux","slug":"Linux","permalink":"https://doreality.xyz/tags/Linux/"},{"name":"Valgrind","slug":"Valgrind","permalink":"https://doreality.xyz/tags/Valgrind/"},{"name":"Makefile","slug":"Makefile","permalink":"https://doreality.xyz/tags/Makefile/"},{"name":"Markdown","slug":"Markdown","permalink":"https://doreality.xyz/tags/Markdown/"},{"name":"DNS","slug":"DNS","permalink":"https://doreality.xyz/tags/DNS/"},{"name":"Device Driver","slug":"Device-Driver","permalink":"https://doreality.xyz/tags/Device-Driver/"},{"name":"Jupyter Notebook","slug":"Jupyter-Notebook","permalink":"https://doreality.xyz/tags/Jupyter-Notebook/"},{"name":"Flask","slug":"Flask","permalink":"https://doreality.xyz/tags/Flask/"},{"name":"Docker","slug":"Docker","permalink":"https://doreality.xyz/tags/Docker/"},{"name":"NLP","slug":"NLP","permalink":"https://doreality.xyz/tags/NLP/"},{"name":"Node","slug":"Node","permalink":"https://doreality.xyz/tags/Node/"},{"name":"Sass","slug":"Sass","permalink":"https://doreality.xyz/tags/Sass/"},{"name":"Express","slug":"Express","permalink":"https://doreality.xyz/tags/Express/"},{"name":"Mongodb","slug":"Mongodb","permalink":"https://doreality.xyz/tags/Mongodb/"},{"name":"Vue","slug":"Vue","permalink":"https://doreality.xyz/tags/Vue/"},{"name":"Vuex","slug":"Vuex","permalink":"https://doreality.xyz/tags/Vuex/"},{"name":"Element UI","slug":"Element-UI","permalink":"https://doreality.xyz/tags/Element-UI/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://doreality.xyz/tags/Kotlin/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"https://doreality.xyz/tags/Android-Studio/"},{"name":"Scikit-learn","slug":"Scikit-learn","permalink":"https://doreality.xyz/tags/Scikit-learn/"},{"name":"PyCharm","slug":"PyCharm","permalink":"https://doreality.xyz/tags/PyCharm/"},{"name":"UML","slug":"UML","permalink":"https://doreality.xyz/tags/UML/"},{"name":"Vim","slug":"Vim","permalink":"https://doreality.xyz/tags/Vim/"},{"name":"SSH","slug":"SSH","permalink":"https://doreality.xyz/tags/SSH/"}]}